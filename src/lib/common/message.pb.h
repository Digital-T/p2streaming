// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace p2message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class peer_info;
class buffermap_info;
class piece_info;
class live_channel_info;
class vod_channel_info;
class s2ts_channel_report_msg;
class s2ts_create_channel_msg;
class s2ts_channel_status_req;
class ts2s_channel_status;
class ts2p_challenge_msg;
class p2ts_login_msg;
class ts2p_login_reply_msg;
class p2ts_peer_request_msg;
class ts2p_peer_reply_msg;
class p2ts_logout_msg;
class p2ts_failure_report_msg;
class p2ts_local_info_report_msg;
class ts2p_kickout_msg;
class p2ts_kickout_msg;
class ts2p_room_info_msg;
class p2ts_ban_msg;
class p2ts_quality_report_msg;
class cached_channel_info;
class p2ts_cache_announce_msg;
class s2p_recommend_seed_msg;
class s2p_piece_notify;
class p2s_info_report_msg;
class p2p_handshake_msg;
class p2p_buffermap_request_msg;
class p2p_neighbor_table_exchange;
class p2p_supervise_request_msg;
class relay_msg;
class broadcast_msg;
class buffermap_exchange_msg;
class join_channel_msg;
class media_request_msg;
class media_subscription_msg;
class punch_request_msg;
class media_sent_confirm_msg;
class no_piece_msg;
class time_server_2_tracker;
class ctrl2m_create_channel_msg;
class ctrl2s_create_channel_msg;
class mds_cmd_msg;
class c2s_cmd_reply_msg;
class c2s_auth_msg;
class alive_alarm_report_msg;

enum peer_nat_type {
  NAT_UNKNOWN = 0, 
  NAT_OPEN_OR_FULL_CONE = 1, 
  NAT_IP_RESTRICTED = 2, 
  NAT_IP_PORT_RESTRICTED = 3, 
  NAT_SYMMETRIC_NAT = 4, 
  NAT_UDP_BLOCKED = 5
};
bool peer_nat_type_IsValid(int value);
const peer_nat_type peer_nat_type_MIN = NAT_UNKNOWN;
const peer_nat_type peer_nat_type_MAX = NAT_UDP_BLOCKED;
const int peer_nat_type_ARRAYSIZE = peer_nat_type_MAX + 1;

enum peer_type {
  SERVER = 0, 
  ASSIST_SERVER = 1, 
  ASSIST_PEER = 2, 
  NORMAL_PEER = 3
};
bool peer_type_IsValid(int value);
const peer_type peer_type_MIN = SERVER;
const peer_type peer_type_MAX = NORMAL_PEER;
const int peer_type_ARRAYSIZE = peer_type_MAX + 1;

// ===================================================================

class peer_info : public ::google::protobuf::MessageLite {
 public:
  peer_info();
  virtual ~peer_info();

  peer_info(const peer_info& from);

  inline peer_info& operator=(const peer_info& from) {
    CopyFrom(from);
    return *this;
  }

  static const peer_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const peer_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(peer_info* other);

  // implements Message ----------------------------------------------

  peer_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const peer_info& from);
  void MergeFrom(const peer_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes peer_id = 1;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // required .p2message.peer_nat_type nat_type = 2 [default = NAT_UNKNOWN];
  inline bool has_nat_type() const;
  inline void clear_nat_type();
  static const int kNatTypeFieldNumber = 2;
  inline ::p2message::peer_nat_type nat_type() const;
  inline void set_nat_type(::p2message::peer_nat_type value);

  // required uint32 upload_capacity = 3 [default = 64000];
  inline bool has_upload_capacity() const;
  inline void clear_upload_capacity();
  static const int kUploadCapacityFieldNumber = 3;
  inline ::google::protobuf::uint32 upload_capacity() const;
  inline void set_upload_capacity(::google::protobuf::uint32 value);

  // required .p2message.peer_type peer_type = 4 [default = NORMAL_PEER];
  inline bool has_peer_type() const;
  inline void clear_peer_type();
  static const int kPeerTypeFieldNumber = 4;
  inline ::p2message::peer_type peer_type() const;
  inline void set_peer_type(::p2message::peer_type value);

  // required uint64 join_time = 5 [default = 0];
  inline bool has_join_time() const;
  inline void clear_join_time();
  static const int kJoinTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 join_time() const;
  inline void set_join_time(::google::protobuf::uint64 value);

  // required uint32 info_version = 6 [default = 0];
  inline bool has_info_version() const;
  inline void clear_info_version();
  static const int kInfoVersionFieldNumber = 6;
  inline ::google::protobuf::uint32 info_version() const;
  inline void set_info_version(::google::protobuf::uint32 value);

  // required uint32 external_ip = 7 [default = 0];
  inline bool has_external_ip() const;
  inline void clear_external_ip();
  static const int kExternalIpFieldNumber = 7;
  inline ::google::protobuf::uint32 external_ip() const;
  inline void set_external_ip(::google::protobuf::uint32 value);

  // required uint32 external_udp_port = 8 [default = 0];
  inline bool has_external_udp_port() const;
  inline void clear_external_udp_port();
  static const int kExternalUdpPortFieldNumber = 8;
  inline ::google::protobuf::uint32 external_udp_port() const;
  inline void set_external_udp_port(::google::protobuf::uint32 value);

  // required uint32 external_tcp_port = 9 [default = 0];
  inline bool has_external_tcp_port() const;
  inline void clear_external_tcp_port();
  static const int kExternalTcpPortFieldNumber = 9;
  inline ::google::protobuf::uint32 external_tcp_port() const;
  inline void set_external_tcp_port(::google::protobuf::uint32 value);

  // required uint32 internal_ip = 10 [default = 0];
  inline bool has_internal_ip() const;
  inline void clear_internal_ip();
  static const int kInternalIpFieldNumber = 10;
  inline ::google::protobuf::uint32 internal_ip() const;
  inline void set_internal_ip(::google::protobuf::uint32 value);

  // required uint32 internal_udp_port = 11 [default = 0];
  inline bool has_internal_udp_port() const;
  inline void clear_internal_udp_port();
  static const int kInternalUdpPortFieldNumber = 11;
  inline ::google::protobuf::uint32 internal_udp_port() const;
  inline void set_internal_udp_port(::google::protobuf::uint32 value);

  // required uint32 internal_tcp_port = 12 [default = 0];
  inline bool has_internal_tcp_port() const;
  inline void clear_internal_tcp_port();
  static const int kInternalTcpPortFieldNumber = 12;
  inline ::google::protobuf::uint32 internal_tcp_port() const;
  inline void set_internal_tcp_port(::google::protobuf::uint32 value);

  // repeated uint32 other_internal_ip = 13;
  inline int other_internal_ip_size() const;
  inline void clear_other_internal_ip();
  static const int kOtherInternalIpFieldNumber = 13;
  inline ::google::protobuf::uint32 other_internal_ip(int index) const;
  inline void set_other_internal_ip(int index, ::google::protobuf::uint32 value);
  inline void add_other_internal_ip(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      other_internal_ip() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_other_internal_ip();

  // required int32 relative_playing_point = 14 [default = -1];
  inline bool has_relative_playing_point() const;
  inline void clear_relative_playing_point();
  static const int kRelativePlayingPointFieldNumber = 14;
  inline ::google::protobuf::int32 relative_playing_point() const;
  inline void set_relative_playing_point(::google::protobuf::int32 value);

  // optional float playing_quality = 15;
  inline bool has_playing_quality() const;
  inline void clear_playing_quality();
  static const int kPlayingQualityFieldNumber = 15;
  inline float playing_quality() const;
  inline void set_playing_quality(float value);

  // optional float global_remote_to_local_lost_rate = 16;
  inline bool has_global_remote_to_local_lost_rate() const;
  inline void clear_global_remote_to_local_lost_rate();
  static const int kGlobalRemoteToLocalLostRateFieldNumber = 16;
  inline float global_remote_to_local_lost_rate() const;
  inline void set_global_remote_to_local_lost_rate(float value);

  // optional bytes user_info = 17;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 17;
  inline const ::std::string& user_info() const;
  inline void set_user_info(const ::std::string& value);
  inline void set_user_info(const char* value);
  inline void set_user_info(const void* value, size_t size);
  inline ::std::string* mutable_user_info();
  inline ::std::string* release_user_info();
  inline void set_allocated_user_info(::std::string* user_info);

  // optional float version = 18 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 18;
  inline float version() const;
  inline void set_version(float value);

  // repeated bytes cache_server_ipport = 19;
  inline int cache_server_ipport_size() const;
  inline void clear_cache_server_ipport();
  static const int kCacheServerIpportFieldNumber = 19;
  inline const ::std::string& cache_server_ipport(int index) const;
  inline ::std::string* mutable_cache_server_ipport(int index);
  inline void set_cache_server_ipport(int index, const ::std::string& value);
  inline void set_cache_server_ipport(int index, const char* value);
  inline void set_cache_server_ipport(int index, const void* value, size_t size);
  inline ::std::string* add_cache_server_ipport();
  inline void add_cache_server_ipport(const ::std::string& value);
  inline void add_cache_server_ipport(const char* value);
  inline void add_cache_server_ipport(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cache_server_ipport() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cache_server_ipport();

  // @@protoc_insertion_point(class_scope:p2message.peer_info)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_nat_type();
  inline void clear_has_nat_type();
  inline void set_has_upload_capacity();
  inline void clear_has_upload_capacity();
  inline void set_has_peer_type();
  inline void clear_has_peer_type();
  inline void set_has_join_time();
  inline void clear_has_join_time();
  inline void set_has_info_version();
  inline void clear_has_info_version();
  inline void set_has_external_ip();
  inline void clear_has_external_ip();
  inline void set_has_external_udp_port();
  inline void clear_has_external_udp_port();
  inline void set_has_external_tcp_port();
  inline void clear_has_external_tcp_port();
  inline void set_has_internal_ip();
  inline void clear_has_internal_ip();
  inline void set_has_internal_udp_port();
  inline void clear_has_internal_udp_port();
  inline void set_has_internal_tcp_port();
  inline void clear_has_internal_tcp_port();
  inline void set_has_relative_playing_point();
  inline void clear_has_relative_playing_point();
  inline void set_has_playing_quality();
  inline void clear_has_playing_quality();
  inline void set_has_global_remote_to_local_lost_rate();
  inline void clear_has_global_remote_to_local_lost_rate();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* peer_id_;
  int nat_type_;
  ::google::protobuf::uint32 upload_capacity_;
  ::google::protobuf::uint64 join_time_;
  int peer_type_;
  ::google::protobuf::uint32 info_version_;
  ::google::protobuf::uint32 external_ip_;
  ::google::protobuf::uint32 external_udp_port_;
  ::google::protobuf::uint32 external_tcp_port_;
  ::google::protobuf::uint32 internal_ip_;
  ::google::protobuf::uint32 internal_udp_port_;
  ::google::protobuf::uint32 internal_tcp_port_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > other_internal_ip_;
  ::google::protobuf::int32 relative_playing_point_;
  float playing_quality_;
  ::std::string* user_info_;
  float global_remote_to_local_lost_rate_;
  float version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cache_server_ipport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static peer_info* default_instance_;
};
// -------------------------------------------------------------------

class buffermap_info : public ::google::protobuf::MessageLite {
 public:
  buffermap_info();
  virtual ~buffermap_info();

  buffermap_info(const buffermap_info& from);

  inline buffermap_info& operator=(const buffermap_info& from) {
    CopyFrom(from);
    return *this;
  }

  static const buffermap_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const buffermap_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(buffermap_info* other);

  // implements Message ----------------------------------------------

  buffermap_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const buffermap_info& from);
  void MergeFrom(const buffermap_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 recent_seqno = 1;
  inline int recent_seqno_size() const;
  inline void clear_recent_seqno();
  static const int kRecentSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 recent_seqno(int index) const;
  inline void set_recent_seqno(int index, ::google::protobuf::uint32 value);
  inline void add_recent_seqno(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      recent_seqno() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_recent_seqno();

  // optional fixed32 bigest_seqno_i_know = 2;
  inline bool has_bigest_seqno_i_know() const;
  inline void clear_bigest_seqno_i_know();
  static const int kBigestSeqnoIKnowFieldNumber = 2;
  inline ::google::protobuf::uint32 bigest_seqno_i_know() const;
  inline void set_bigest_seqno_i_know(::google::protobuf::uint32 value);

  // optional fixed32 smallest_seqno_i_have = 3;
  inline bool has_smallest_seqno_i_have() const;
  inline void clear_smallest_seqno_i_have();
  static const int kSmallestSeqnoIHaveFieldNumber = 3;
  inline ::google::protobuf::uint32 smallest_seqno_i_have() const;
  inline void set_smallest_seqno_i_have(::google::protobuf::uint32 value);

  // optional fixed32 first_seqno_in_bitset = 4;
  inline bool has_first_seqno_in_bitset() const;
  inline void clear_first_seqno_in_bitset();
  static const int kFirstSeqnoInBitsetFieldNumber = 4;
  inline ::google::protobuf::uint32 first_seqno_in_bitset() const;
  inline void set_first_seqno_in_bitset(::google::protobuf::uint32 value);

  // optional fixed32 erased_seq_begin = 5;
  inline bool has_erased_seq_begin() const;
  inline void clear_erased_seq_begin();
  static const int kErasedSeqBeginFieldNumber = 5;
  inline ::google::protobuf::uint32 erased_seq_begin() const;
  inline void set_erased_seq_begin(::google::protobuf::uint32 value);

  // optional fixed32 erased_seq_end = 6;
  inline bool has_erased_seq_end() const;
  inline void clear_erased_seq_end();
  static const int kErasedSeqEndFieldNumber = 6;
  inline ::google::protobuf::uint32 erased_seq_end() const;
  inline void set_erased_seq_end(::google::protobuf::uint32 value);

  // optional bytes bitset = 7;
  inline bool has_bitset() const;
  inline void clear_bitset();
  static const int kBitsetFieldNumber = 7;
  inline const ::std::string& bitset() const;
  inline void set_bitset(const ::std::string& value);
  inline void set_bitset(const char* value);
  inline void set_bitset(const void* value, size_t size);
  inline ::std::string* mutable_bitset();
  inline ::std::string* release_bitset();
  inline void set_allocated_bitset(::std::string* bitset);

  // repeated fixed32 iframe_seqno = 8;
  inline int iframe_seqno_size() const;
  inline void clear_iframe_seqno();
  static const int kIframeSeqnoFieldNumber = 8;
  inline ::google::protobuf::uint32 iframe_seqno(int index) const;
  inline void set_iframe_seqno(int index, ::google::protobuf::uint32 value);
  inline void add_iframe_seqno(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iframe_seqno() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iframe_seqno();

  // @@protoc_insertion_point(class_scope:p2message.buffermap_info)
 private:
  inline void set_has_bigest_seqno_i_know();
  inline void clear_has_bigest_seqno_i_know();
  inline void set_has_smallest_seqno_i_have();
  inline void clear_has_smallest_seqno_i_have();
  inline void set_has_first_seqno_in_bitset();
  inline void clear_has_first_seqno_in_bitset();
  inline void set_has_erased_seq_begin();
  inline void clear_has_erased_seq_begin();
  inline void set_has_erased_seq_end();
  inline void clear_has_erased_seq_end();
  inline void set_has_bitset();
  inline void clear_has_bitset();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > recent_seqno_;
  ::google::protobuf::uint32 bigest_seqno_i_know_;
  ::google::protobuf::uint32 smallest_seqno_i_have_;
  ::google::protobuf::uint32 first_seqno_in_bitset_;
  ::google::protobuf::uint32 erased_seq_begin_;
  ::std::string* bitset_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iframe_seqno_;
  ::google::protobuf::uint32 erased_seq_end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static buffermap_info* default_instance_;
};
// -------------------------------------------------------------------

class piece_info : public ::google::protobuf::MessageLite {
 public:
  piece_info();
  virtual ~piece_info();

  piece_info(const piece_info& from);

  inline piece_info& operator=(const piece_info& from) {
    CopyFrom(from);
    return *this;
  }

  static const piece_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const piece_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(piece_info* other);

  // implements Message ----------------------------------------------

  piece_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const piece_info& from);
  void MergeFrom(const piece_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // required fixed32 seqno = 2;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 2;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.piece_info)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static piece_info* default_instance_;
};
// -------------------------------------------------------------------

class live_channel_info : public ::google::protobuf::MessageLite {
 public:
  live_channel_info();
  virtual ~live_channel_info();

  live_channel_info(const live_channel_info& from);

  inline live_channel_info& operator=(const live_channel_info& from) {
    CopyFrom(from);
    return *this;
  }

  static const live_channel_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const live_channel_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(live_channel_info* other);

  // implements Message ----------------------------------------------

  live_channel_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const live_channel_info& from);
  void MergeFrom(const live_channel_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes channel_uuid = 1;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 1;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // required sfixed32 server_time = 2;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 2;
  inline ::google::protobuf::int32 server_time() const;
  inline void set_server_time(::google::protobuf::int32 value);

  // required fixed32 server_seqno = 3;
  inline bool has_server_seqno() const;
  inline void clear_server_seqno();
  static const int kServerSeqnoFieldNumber = 3;
  inline ::google::protobuf::uint32 server_seqno() const;
  inline void set_server_seqno(::google::protobuf::uint32 value);

  // required uint32 server_packet_rate = 4;
  inline bool has_server_packet_rate() const;
  inline void clear_server_packet_rate();
  static const int kServerPacketRateFieldNumber = 4;
  inline ::google::protobuf::uint32 server_packet_rate() const;
  inline void set_server_packet_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.live_channel_info)
 private:
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();
  inline void set_has_server_time();
  inline void clear_has_server_time();
  inline void set_has_server_seqno();
  inline void clear_has_server_seqno();
  inline void set_has_server_packet_rate();
  inline void clear_has_server_packet_rate();

  ::std::string* channel_uuid_;
  ::google::protobuf::int32 server_time_;
  ::google::protobuf::uint32 server_seqno_;
  ::google::protobuf::uint32 server_packet_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static live_channel_info* default_instance_;
};
// -------------------------------------------------------------------

class vod_channel_info : public ::google::protobuf::MessageLite {
 public:
  vod_channel_info();
  virtual ~vod_channel_info();

  vod_channel_info(const vod_channel_info& from);

  inline vod_channel_info& operator=(const vod_channel_info& from) {
    CopyFrom(from);
    return *this;
  }

  static const vod_channel_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const vod_channel_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(vod_channel_info* other);

  // implements Message ----------------------------------------------

  vod_channel_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const vod_channel_info& from);
  void MergeFrom(const vod_channel_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes channel_link = 1;
  inline bool has_channel_link() const;
  inline void clear_channel_link();
  static const int kChannelLinkFieldNumber = 1;
  inline const ::std::string& channel_link() const;
  inline void set_channel_link(const ::std::string& value);
  inline void set_channel_link(const char* value);
  inline void set_channel_link(const void* value, size_t size);
  inline ::std::string* mutable_channel_link();
  inline ::std::string* release_channel_link();
  inline void set_allocated_channel_link(::std::string* channel_link);

  // required bytes channel_uuid = 2;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 2;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // required int32 film_duration = 3;
  inline bool has_film_duration() const;
  inline void clear_film_duration();
  static const int kFilmDurationFieldNumber = 3;
  inline ::google::protobuf::int32 film_duration() const;
  inline void set_film_duration(::google::protobuf::int32 value);

  // required int32 film_length = 4;
  inline bool has_film_length() const;
  inline void clear_film_length();
  static const int kFilmLengthFieldNumber = 4;
  inline ::google::protobuf::int32 film_length() const;
  inline void set_film_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:p2message.vod_channel_info)
 private:
  inline void set_has_channel_link();
  inline void clear_has_channel_link();
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();
  inline void set_has_film_duration();
  inline void clear_has_film_duration();
  inline void set_has_film_length();
  inline void clear_has_film_length();

  ::std::string* channel_link_;
  ::std::string* channel_uuid_;
  ::google::protobuf::int32 film_duration_;
  ::google::protobuf::int32 film_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static vod_channel_info* default_instance_;
};
// -------------------------------------------------------------------

class s2ts_channel_report_msg : public ::google::protobuf::MessageLite {
 public:
  s2ts_channel_report_msg();
  virtual ~s2ts_channel_report_msg();

  s2ts_channel_report_msg(const s2ts_channel_report_msg& from);

  inline s2ts_channel_report_msg& operator=(const s2ts_channel_report_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const s2ts_channel_report_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const s2ts_channel_report_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(s2ts_channel_report_msg* other);

  // implements Message ----------------------------------------------

  s2ts_channel_report_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s2ts_channel_report_msg& from);
  void MergeFrom(const s2ts_channel_report_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .p2message.live_channel_info channel_info = 1;
  inline bool has_channel_info() const;
  inline void clear_channel_info();
  static const int kChannelInfoFieldNumber = 1;
  inline const ::p2message::live_channel_info& channel_info() const;
  inline ::p2message::live_channel_info* mutable_channel_info();
  inline ::p2message::live_channel_info* release_channel_info();
  inline void set_allocated_channel_info(::p2message::live_channel_info* channel_info);

  // repeated fixed32 iframe_seqno = 2;
  inline int iframe_seqno_size() const;
  inline void clear_iframe_seqno();
  static const int kIframeSeqnoFieldNumber = 2;
  inline ::google::protobuf::uint32 iframe_seqno(int index) const;
  inline void set_iframe_seqno(int index, ::google::protobuf::uint32 value);
  inline void add_iframe_seqno(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iframe_seqno() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iframe_seqno();

  // @@protoc_insertion_point(class_scope:p2message.s2ts_channel_report_msg)
 private:
  inline void set_has_channel_info();
  inline void clear_has_channel_info();

  ::p2message::live_channel_info* channel_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iframe_seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static s2ts_channel_report_msg* default_instance_;
};
// -------------------------------------------------------------------

class s2ts_create_channel_msg : public ::google::protobuf::MessageLite {
 public:
  s2ts_create_channel_msg();
  virtual ~s2ts_create_channel_msg();

  s2ts_create_channel_msg(const s2ts_create_channel_msg& from);

  inline s2ts_create_channel_msg& operator=(const s2ts_create_channel_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const s2ts_create_channel_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const s2ts_create_channel_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(s2ts_create_channel_msg* other);

  // implements Message ----------------------------------------------

  s2ts_create_channel_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s2ts_create_channel_msg& from);
  void MergeFrom(const s2ts_create_channel_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .p2message.peer_info server_info = 1;
  inline bool has_server_info() const;
  inline void clear_server_info();
  static const int kServerInfoFieldNumber = 1;
  inline const ::p2message::peer_info& server_info() const;
  inline ::p2message::peer_info* mutable_server_info();
  inline ::p2message::peer_info* release_server_info();
  inline void set_allocated_server_info(::p2message::peer_info* server_info);

  // optional .p2message.live_channel_info live_channel_info = 2;
  inline bool has_live_channel_info() const;
  inline void clear_live_channel_info();
  static const int kLiveChannelInfoFieldNumber = 2;
  inline const ::p2message::live_channel_info& live_channel_info() const;
  inline ::p2message::live_channel_info* mutable_live_channel_info();
  inline ::p2message::live_channel_info* release_live_channel_info();
  inline void set_allocated_live_channel_info(::p2message::live_channel_info* live_channel_info);

  // optional .p2message.vod_channel_info vod_channel_info = 3;
  inline bool has_vod_channel_info() const;
  inline void clear_vod_channel_info();
  static const int kVodChannelInfoFieldNumber = 3;
  inline const ::p2message::vod_channel_info& vod_channel_info() const;
  inline ::p2message::vod_channel_info* mutable_vod_channel_info();
  inline ::p2message::vod_channel_info* release_vod_channel_info();
  inline void set_allocated_vod_channel_info(::p2message::vod_channel_info* vod_channel_info);

  // required uint32 distribute_type = 4;
  inline bool has_distribute_type() const;
  inline void clear_distribute_type();
  static const int kDistributeTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 distribute_type() const;
  inline void set_distribute_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.s2ts_create_channel_msg)
 private:
  inline void set_has_server_info();
  inline void clear_has_server_info();
  inline void set_has_live_channel_info();
  inline void clear_has_live_channel_info();
  inline void set_has_vod_channel_info();
  inline void clear_has_vod_channel_info();
  inline void set_has_distribute_type();
  inline void clear_has_distribute_type();

  ::p2message::peer_info* server_info_;
  ::p2message::live_channel_info* live_channel_info_;
  ::p2message::vod_channel_info* vod_channel_info_;
  ::google::protobuf::uint32 distribute_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static s2ts_create_channel_msg* default_instance_;
};
// -------------------------------------------------------------------

class s2ts_channel_status_req : public ::google::protobuf::MessageLite {
 public:
  s2ts_channel_status_req();
  virtual ~s2ts_channel_status_req();

  s2ts_channel_status_req(const s2ts_channel_status_req& from);

  inline s2ts_channel_status_req& operator=(const s2ts_channel_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const s2ts_channel_status_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const s2ts_channel_status_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(s2ts_channel_status_req* other);

  // implements Message ----------------------------------------------

  s2ts_channel_status_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s2ts_channel_status_req& from);
  void MergeFrom(const s2ts_channel_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:p2message.s2ts_channel_status_req)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::std::string* channel_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static s2ts_channel_status_req* default_instance_;
};
// -------------------------------------------------------------------

class ts2s_channel_status : public ::google::protobuf::MessageLite {
 public:
  ts2s_channel_status();
  virtual ~ts2s_channel_status();

  ts2s_channel_status(const ts2s_channel_status& from);

  inline ts2s_channel_status& operator=(const ts2s_channel_status& from) {
    CopyFrom(from);
    return *this;
  }

  static const ts2s_channel_status& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ts2s_channel_status* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ts2s_channel_status* other);

  // implements Message ----------------------------------------------

  ts2s_channel_status* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ts2s_channel_status& from);
  void MergeFrom(const ts2s_channel_status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 live_cnt = 1;
  inline bool has_live_cnt() const;
  inline void clear_live_cnt();
  static const int kLiveCntFieldNumber = 1;
  inline ::google::protobuf::uint32 live_cnt() const;
  inline void set_live_cnt(::google::protobuf::uint32 value);

  // required float playing_quality = 2;
  inline bool has_playing_quality() const;
  inline void clear_playing_quality();
  static const int kPlayingQualityFieldNumber = 2;
  inline float playing_quality() const;
  inline void set_playing_quality(float value);

  // required float rtol_lost_rate = 3;
  inline bool has_rtol_lost_rate() const;
  inline void clear_rtol_lost_rate();
  static const int kRtolLostRateFieldNumber = 3;
  inline float rtol_lost_rate() const;
  inline void set_rtol_lost_rate(float value);

  // optional .p2message.p2ts_quality_report_msg quality_info = 4;
  inline bool has_quality_info() const;
  inline void clear_quality_info();
  static const int kQualityInfoFieldNumber = 4;
  inline const ::p2message::p2ts_quality_report_msg& quality_info() const;
  inline ::p2message::p2ts_quality_report_msg* mutable_quality_info();
  inline ::p2message::p2ts_quality_report_msg* release_quality_info();
  inline void set_allocated_quality_info(::p2message::p2ts_quality_report_msg* quality_info);

  // @@protoc_insertion_point(class_scope:p2message.ts2s_channel_status)
 private:
  inline void set_has_live_cnt();
  inline void clear_has_live_cnt();
  inline void set_has_playing_quality();
  inline void clear_has_playing_quality();
  inline void set_has_rtol_lost_rate();
  inline void clear_has_rtol_lost_rate();
  inline void set_has_quality_info();
  inline void clear_has_quality_info();

  ::google::protobuf::uint32 live_cnt_;
  float playing_quality_;
  ::p2message::p2ts_quality_report_msg* quality_info_;
  float rtol_lost_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ts2s_channel_status* default_instance_;
};
// -------------------------------------------------------------------

class ts2p_challenge_msg : public ::google::protobuf::MessageLite {
 public:
  ts2p_challenge_msg();
  virtual ~ts2p_challenge_msg();

  ts2p_challenge_msg(const ts2p_challenge_msg& from);

  inline ts2p_challenge_msg& operator=(const ts2p_challenge_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ts2p_challenge_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ts2p_challenge_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ts2p_challenge_msg* other);

  // implements Message ----------------------------------------------

  ts2p_challenge_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ts2p_challenge_msg& from);
  void MergeFrom(const ts2p_challenge_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes challenge = 1;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 1;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const void* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  inline void set_allocated_challenge(::std::string* challenge);

  // @@protoc_insertion_point(class_scope:p2message.ts2p_challenge_msg)
 private:
  inline void set_has_challenge();
  inline void clear_has_challenge();

  ::std::string* challenge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ts2p_challenge_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_login_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_login_msg();
  virtual ~p2ts_login_msg();

  p2ts_login_msg(const p2ts_login_msg& from);

  inline p2ts_login_msg& operator=(const p2ts_login_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_login_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_login_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_login_msg* other);

  // implements Message ----------------------------------------------

  p2ts_login_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_login_msg& from);
  void MergeFrom(const p2ts_login_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required bytes channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required .p2message.peer_info peer_info = 3;
  inline bool has_peer_info() const;
  inline void clear_peer_info();
  static const int kPeerInfoFieldNumber = 3;
  inline const ::p2message::peer_info& peer_info() const;
  inline ::p2message::peer_info* mutable_peer_info();
  inline ::p2message::peer_info* release_peer_info();
  inline void set_allocated_peer_info(::p2message::peer_info* peer_info);

  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // required bytes shared_key_signature = 5;
  inline bool has_shared_key_signature() const;
  inline void clear_shared_key_signature();
  static const int kSharedKeySignatureFieldNumber = 5;
  inline const ::std::string& shared_key_signature() const;
  inline void set_shared_key_signature(const ::std::string& value);
  inline void set_shared_key_signature(const char* value);
  inline void set_shared_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_shared_key_signature();
  inline ::std::string* release_shared_key_signature();
  inline void set_allocated_shared_key_signature(::std::string* shared_key_signature);

  // required bytes certificate = 6;
  inline bool has_certificate() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 6;
  inline const ::std::string& certificate() const;
  inline void set_certificate(const ::std::string& value);
  inline void set_certificate(const char* value);
  inline void set_certificate(const void* value, size_t size);
  inline ::std::string* mutable_certificate();
  inline ::std::string* release_certificate();
  inline void set_allocated_certificate(::std::string* certificate);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_login_msg)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_peer_info();
  inline void clear_has_peer_info();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_shared_key_signature();
  inline void clear_has_shared_key_signature();
  inline void set_has_certificate();
  inline void clear_has_certificate();

  ::std::string* channel_id_;
  ::p2message::peer_info* peer_info_;
  ::std::string* public_key_;
  ::std::string* shared_key_signature_;
  ::std::string* certificate_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_login_msg* default_instance_;
};
// -------------------------------------------------------------------

class ts2p_login_reply_msg : public ::google::protobuf::MessageLite {
 public:
  ts2p_login_reply_msg();
  virtual ~ts2p_login_reply_msg();

  ts2p_login_reply_msg(const ts2p_login_reply_msg& from);

  inline ts2p_login_reply_msg& operator=(const ts2p_login_reply_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ts2p_login_reply_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ts2p_login_reply_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ts2p_login_reply_msg* other);

  // implements Message ----------------------------------------------

  ts2p_login_reply_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ts2p_login_reply_msg& from);
  void MergeFrom(const ts2p_login_reply_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .p2message.peer_info peer_info_list = 1;
  inline int peer_info_list_size() const;
  inline void clear_peer_info_list();
  static const int kPeerInfoListFieldNumber = 1;
  inline const ::p2message::peer_info& peer_info_list(int index) const;
  inline ::p2message::peer_info* mutable_peer_info_list(int index);
  inline ::p2message::peer_info* add_peer_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
      peer_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
      mutable_peer_info_list();

  // required uint32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required uint32 external_ip = 4;
  inline bool has_external_ip() const;
  inline void clear_external_ip();
  static const int kExternalIpFieldNumber = 4;
  inline ::google::protobuf::uint32 external_ip() const;
  inline void set_external_ip(::google::protobuf::uint32 value);

  // required uint32 external_port = 5;
  inline bool has_external_port() const;
  inline void clear_external_port();
  static const int kExternalPortFieldNumber = 5;
  inline ::google::protobuf::uint32 external_port() const;
  inline void set_external_port(::google::protobuf::uint32 value);

  // required uint32 online_peer_cnt = 6;
  inline bool has_online_peer_cnt() const;
  inline void clear_online_peer_cnt();
  static const int kOnlinePeerCntFieldNumber = 6;
  inline ::google::protobuf::uint32 online_peer_cnt() const;
  inline void set_online_peer_cnt(::google::protobuf::uint32 value);

  // required uint64 join_time = 7;
  inline bool has_join_time() const;
  inline void clear_join_time();
  static const int kJoinTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 join_time() const;
  inline void set_join_time(::google::protobuf::uint64 value);

  // required bytes channel_id = 8;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 8;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // optional .p2message.live_channel_info live_channel_info = 9;
  inline bool has_live_channel_info() const;
  inline void clear_live_channel_info();
  static const int kLiveChannelInfoFieldNumber = 9;
  inline const ::p2message::live_channel_info& live_channel_info() const;
  inline ::p2message::live_channel_info* mutable_live_channel_info();
  inline ::p2message::live_channel_info* release_live_channel_info();
  inline void set_allocated_live_channel_info(::p2message::live_channel_info* live_channel_info);

  // optional .p2message.vod_channel_info vod_channel_info = 10;
  inline bool has_vod_channel_info() const;
  inline void clear_vod_channel_info();
  static const int kVodChannelInfoFieldNumber = 10;
  inline const ::p2message::vod_channel_info& vod_channel_info() const;
  inline ::p2message::vod_channel_info* mutable_vod_channel_info();
  inline ::p2message::vod_channel_info* release_vod_channel_info();
  inline void set_allocated_vod_channel_info(::p2message::vod_channel_info* vod_channel_info);

  // optional bytes cache_tracker_addr = 11;
  inline bool has_cache_tracker_addr() const;
  inline void clear_cache_tracker_addr();
  static const int kCacheTrackerAddrFieldNumber = 11;
  inline const ::std::string& cache_tracker_addr() const;
  inline void set_cache_tracker_addr(const ::std::string& value);
  inline void set_cache_tracker_addr(const char* value);
  inline void set_cache_tracker_addr(const void* value, size_t size);
  inline ::std::string* mutable_cache_tracker_addr();
  inline ::std::string* release_cache_tracker_addr();
  inline void set_allocated_cache_tracker_addr(::std::string* cache_tracker_addr);

  // repeated fixed32 iframe_seqno = 12;
  inline int iframe_seqno_size() const;
  inline void clear_iframe_seqno();
  static const int kIframeSeqnoFieldNumber = 12;
  inline ::google::protobuf::uint32 iframe_seqno(int index) const;
  inline void set_iframe_seqno(int index, ::google::protobuf::uint32 value);
  inline void add_iframe_seqno(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iframe_seqno() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iframe_seqno();

  // @@protoc_insertion_point(class_scope:p2message.ts2p_login_reply_msg)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_external_ip();
  inline void clear_has_external_ip();
  inline void set_has_external_port();
  inline void clear_has_external_port();
  inline void set_has_online_peer_cnt();
  inline void clear_has_online_peer_cnt();
  inline void set_has_join_time();
  inline void clear_has_join_time();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_live_channel_info();
  inline void clear_has_live_channel_info();
  inline void set_has_vod_channel_info();
  inline void clear_has_vod_channel_info();
  inline void set_has_cache_tracker_addr();
  inline void clear_has_cache_tracker_addr();

  ::google::protobuf::RepeatedPtrField< ::p2message::peer_info > peer_info_list_;
  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 external_ip_;
  ::google::protobuf::uint32 external_port_;
  ::google::protobuf::uint64 join_time_;
  ::std::string* channel_id_;
  ::p2message::live_channel_info* live_channel_info_;
  ::p2message::vod_channel_info* vod_channel_info_;
  ::std::string* cache_tracker_addr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iframe_seqno_;
  ::google::protobuf::uint32 online_peer_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ts2p_login_reply_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_peer_request_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_peer_request_msg();
  virtual ~p2ts_peer_request_msg();

  p2ts_peer_request_msg(const p2ts_peer_request_msg& from);

  inline p2ts_peer_request_msg& operator=(const p2ts_peer_request_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_peer_request_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_peer_request_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_peer_request_msg* other);

  // implements Message ----------------------------------------------

  p2ts_peer_request_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_peer_request_msg& from);
  void MergeFrom(const p2ts_peer_request_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .p2message.peer_info peer_info = 2;
  inline bool has_peer_info() const;
  inline void clear_peer_info();
  static const int kPeerInfoFieldNumber = 2;
  inline const ::p2message::peer_info& peer_info() const;
  inline ::p2message::peer_info* mutable_peer_info();
  inline ::p2message::peer_info* release_peer_info();
  inline void set_allocated_peer_info(::p2message::peer_info* peer_info);

  // optional bytes channel_uuid = 3;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 3;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_peer_request_msg)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_peer_info();
  inline void clear_has_peer_info();
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();

  ::p2message::peer_info* peer_info_;
  ::std::string* channel_uuid_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_peer_request_msg* default_instance_;
};
// -------------------------------------------------------------------

class ts2p_peer_reply_msg : public ::google::protobuf::MessageLite {
 public:
  ts2p_peer_reply_msg();
  virtual ~ts2p_peer_reply_msg();

  ts2p_peer_reply_msg(const ts2p_peer_reply_msg& from);

  inline ts2p_peer_reply_msg& operator=(const ts2p_peer_reply_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ts2p_peer_reply_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ts2p_peer_reply_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ts2p_peer_reply_msg* other);

  // implements Message ----------------------------------------------

  ts2p_peer_reply_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ts2p_peer_reply_msg& from);
  void MergeFrom(const ts2p_peer_reply_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // required uint32 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required bytes channel_id = 3;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 3;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // repeated .p2message.peer_info peer_info_list = 4;
  inline int peer_info_list_size() const;
  inline void clear_peer_info_list();
  static const int kPeerInfoListFieldNumber = 4;
  inline const ::p2message::peer_info& peer_info_list(int index) const;
  inline ::p2message::peer_info* mutable_peer_info_list(int index);
  inline ::p2message::peer_info* add_peer_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
      peer_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
      mutable_peer_info_list();

  // optional uint32 cache_peer_cnt = 5;
  inline bool has_cache_peer_cnt() const;
  inline void clear_cache_peer_cnt();
  static const int kCachePeerCntFieldNumber = 5;
  inline ::google::protobuf::uint32 cache_peer_cnt() const;
  inline void set_cache_peer_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.ts2p_peer_reply_msg)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_cache_peer_cnt();
  inline void clear_has_cache_peer_cnt();

  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* channel_id_;
  ::google::protobuf::RepeatedPtrField< ::p2message::peer_info > peer_info_list_;
  ::google::protobuf::uint32 cache_peer_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ts2p_peer_reply_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_logout_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_logout_msg();
  virtual ~p2ts_logout_msg();

  p2ts_logout_msg(const p2ts_logout_msg& from);

  inline p2ts_logout_msg& operator=(const p2ts_logout_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_logout_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_logout_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_logout_msg* other);

  // implements Message ----------------------------------------------

  p2ts_logout_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_logout_msg& from);
  void MergeFrom(const p2ts_logout_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes peer_id = 1;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // required uint32 peer_key = 2;
  inline bool has_peer_key() const;
  inline void clear_peer_key();
  static const int kPeerKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 peer_key() const;
  inline void set_peer_key(::google::protobuf::uint32 value);

  // optional bytes channel_uuid = 3;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 3;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_logout_msg)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_peer_key();
  inline void clear_has_peer_key();
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();

  ::std::string* peer_id_;
  ::std::string* channel_uuid_;
  ::google::protobuf::uint32 peer_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_logout_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_failure_report_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_failure_report_msg();
  virtual ~p2ts_failure_report_msg();

  p2ts_failure_report_msg(const p2ts_failure_report_msg& from);

  inline p2ts_failure_report_msg& operator=(const p2ts_failure_report_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_failure_report_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_failure_report_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_failure_report_msg* other);

  // implements Message ----------------------------------------------

  p2ts_failure_report_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_failure_report_msg& from);
  void MergeFrom(const p2ts_failure_report_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes peer_id = 1;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // optional bytes channel_uuid = 2;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 2;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_failure_report_msg)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();

  ::std::string* peer_id_;
  ::std::string* channel_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_failure_report_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_local_info_report_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_local_info_report_msg();
  virtual ~p2ts_local_info_report_msg();

  p2ts_local_info_report_msg(const p2ts_local_info_report_msg& from);

  inline p2ts_local_info_report_msg& operator=(const p2ts_local_info_report_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_local_info_report_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_local_info_report_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_local_info_report_msg* other);

  // implements Message ----------------------------------------------

  p2ts_local_info_report_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_local_info_report_msg& from);
  void MergeFrom(const p2ts_local_info_report_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .p2message.peer_info peer_info = 2;
  inline bool has_peer_info() const;
  inline void clear_peer_info();
  static const int kPeerInfoFieldNumber = 2;
  inline const ::p2message::peer_info& peer_info() const;
  inline ::p2message::peer_info* mutable_peer_info();
  inline ::p2message::peer_info* release_peer_info();
  inline void set_allocated_peer_info(::p2message::peer_info* peer_info);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_local_info_report_msg)
 private:
  inline void set_has_peer_info();
  inline void clear_has_peer_info();

  ::p2message::peer_info* peer_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_local_info_report_msg* default_instance_;
};
// -------------------------------------------------------------------

class ts2p_kickout_msg : public ::google::protobuf::MessageLite {
 public:
  ts2p_kickout_msg();
  virtual ~ts2p_kickout_msg();

  ts2p_kickout_msg(const ts2p_kickout_msg& from);

  inline ts2p_kickout_msg& operator=(const ts2p_kickout_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ts2p_kickout_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ts2p_kickout_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ts2p_kickout_msg* other);

  // implements Message ----------------------------------------------

  ts2p_kickout_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ts2p_kickout_msg& from);
  void MergeFrom(const ts2p_kickout_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional bytes reasion = 2;
  inline bool has_reasion() const;
  inline void clear_reasion();
  static const int kReasionFieldNumber = 2;
  inline const ::std::string& reasion() const;
  inline void set_reasion(const ::std::string& value);
  inline void set_reasion(const char* value);
  inline void set_reasion(const void* value, size_t size);
  inline ::std::string* mutable_reasion();
  inline ::std::string* release_reasion();
  inline void set_allocated_reasion(::std::string* reasion);

  // @@protoc_insertion_point(class_scope:p2message.ts2p_kickout_msg)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_reasion();
  inline void clear_has_reasion();

  ::std::string* reasion_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ts2p_kickout_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_kickout_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_kickout_msg();
  virtual ~p2ts_kickout_msg();

  p2ts_kickout_msg(const p2ts_kickout_msg& from);

  inline p2ts_kickout_msg& operator=(const p2ts_kickout_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_kickout_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_kickout_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_kickout_msg* other);

  // implements Message ----------------------------------------------

  p2ts_kickout_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_kickout_msg& from);
  void MergeFrom(const p2ts_kickout_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional bytes reasion = 2;
  inline bool has_reasion() const;
  inline void clear_reasion();
  static const int kReasionFieldNumber = 2;
  inline const ::std::string& reasion() const;
  inline void set_reasion(const ::std::string& value);
  inline void set_reasion(const char* value);
  inline void set_reasion(const void* value, size_t size);
  inline ::std::string* mutable_reasion();
  inline ::std::string* release_reasion();
  inline void set_allocated_reasion(::std::string* reasion);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_kickout_msg)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_reasion();
  inline void clear_has_reasion();

  ::std::string* reasion_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_kickout_msg* default_instance_;
};
// -------------------------------------------------------------------

class ts2p_room_info_msg : public ::google::protobuf::MessageLite {
 public:
  ts2p_room_info_msg();
  virtual ~ts2p_room_info_msg();

  ts2p_room_info_msg(const ts2p_room_info_msg& from);

  inline ts2p_room_info_msg& operator=(const ts2p_room_info_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ts2p_room_info_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ts2p_room_info_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ts2p_room_info_msg* other);

  // implements Message ----------------------------------------------

  ts2p_room_info_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ts2p_room_info_msg& from);
  void MergeFrom(const ts2p_room_info_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_peer_cnt = 1;
  inline bool has_online_peer_cnt() const;
  inline void clear_online_peer_cnt();
  static const int kOnlinePeerCntFieldNumber = 1;
  inline ::google::protobuf::uint32 online_peer_cnt() const;
  inline void set_online_peer_cnt(::google::protobuf::uint32 value);

  // repeated bytes offline_peer_list = 2;
  inline int offline_peer_list_size() const;
  inline void clear_offline_peer_list();
  static const int kOfflinePeerListFieldNumber = 2;
  inline const ::std::string& offline_peer_list(int index) const;
  inline ::std::string* mutable_offline_peer_list(int index);
  inline void set_offline_peer_list(int index, const ::std::string& value);
  inline void set_offline_peer_list(int index, const char* value);
  inline void set_offline_peer_list(int index, const void* value, size_t size);
  inline ::std::string* add_offline_peer_list();
  inline void add_offline_peer_list(const ::std::string& value);
  inline void add_offline_peer_list(const char* value);
  inline void add_offline_peer_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& offline_peer_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_offline_peer_list();

  // repeated .p2message.peer_info new_login_peer_list = 3;
  inline int new_login_peer_list_size() const;
  inline void clear_new_login_peer_list();
  static const int kNewLoginPeerListFieldNumber = 3;
  inline const ::p2message::peer_info& new_login_peer_list(int index) const;
  inline ::p2message::peer_info* mutable_new_login_peer_list(int index);
  inline ::p2message::peer_info* add_new_login_peer_list();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
      new_login_peer_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
      mutable_new_login_peer_list();

  // repeated .p2message.peer_info online_peer_list = 4;
  inline int online_peer_list_size() const;
  inline void clear_online_peer_list();
  static const int kOnlinePeerListFieldNumber = 4;
  inline const ::p2message::peer_info& online_peer_list(int index) const;
  inline ::p2message::peer_info* mutable_online_peer_list(int index);
  inline ::p2message::peer_info* add_online_peer_list();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
      online_peer_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
      mutable_online_peer_list();

  // @@protoc_insertion_point(class_scope:p2message.ts2p_room_info_msg)
 private:
  inline void set_has_online_peer_cnt();
  inline void clear_has_online_peer_cnt();

  ::google::protobuf::RepeatedPtrField< ::std::string> offline_peer_list_;
  ::google::protobuf::RepeatedPtrField< ::p2message::peer_info > new_login_peer_list_;
  ::google::protobuf::RepeatedPtrField< ::p2message::peer_info > online_peer_list_;
  ::google::protobuf::uint32 online_peer_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ts2p_room_info_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_ban_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_ban_msg();
  virtual ~p2ts_ban_msg();

  p2ts_ban_msg(const p2ts_ban_msg& from);

  inline p2ts_ban_msg& operator=(const p2ts_ban_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_ban_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_ban_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_ban_msg* other);

  // implements Message ----------------------------------------------

  p2ts_ban_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_ban_msg& from);
  void MergeFrom(const p2ts_ban_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_admin = 1;
  inline bool has_is_admin() const;
  inline void clear_is_admin();
  static const int kIsAdminFieldNumber = 1;
  inline bool is_admin() const;
  inline void set_is_admin(bool value);

  // required bool is_ban = 2;
  inline bool has_is_ban() const;
  inline void clear_is_ban();
  static const int kIsBanFieldNumber = 2;
  inline bool is_ban() const;
  inline void set_is_ban(bool value);

  // required bool is_txt = 3;
  inline bool has_is_txt() const;
  inline void clear_is_txt();
  static const int kIsTxtFieldNumber = 3;
  inline bool is_txt() const;
  inline void set_is_txt(bool value);

  // required bytes dst_peer_id = 4;
  inline bool has_dst_peer_id() const;
  inline void clear_dst_peer_id();
  static const int kDstPeerIdFieldNumber = 4;
  inline const ::std::string& dst_peer_id() const;
  inline void set_dst_peer_id(const ::std::string& value);
  inline void set_dst_peer_id(const char* value);
  inline void set_dst_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_dst_peer_id();
  inline ::std::string* release_dst_peer_id();
  inline void set_allocated_dst_peer_id(::std::string* dst_peer_id);

  // required bytes src_peer_id = 5;
  inline bool has_src_peer_id() const;
  inline void clear_src_peer_id();
  static const int kSrcPeerIdFieldNumber = 5;
  inline const ::std::string& src_peer_id() const;
  inline void set_src_peer_id(const ::std::string& value);
  inline void set_src_peer_id(const char* value);
  inline void set_src_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_src_peer_id();
  inline ::std::string* release_src_peer_id();
  inline void set_allocated_src_peer_id(::std::string* src_peer_id);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_ban_msg)
 private:
  inline void set_has_is_admin();
  inline void clear_has_is_admin();
  inline void set_has_is_ban();
  inline void clear_has_is_ban();
  inline void set_has_is_txt();
  inline void clear_has_is_txt();
  inline void set_has_dst_peer_id();
  inline void clear_has_dst_peer_id();
  inline void set_has_src_peer_id();
  inline void clear_has_src_peer_id();

  ::std::string* dst_peer_id_;
  ::std::string* src_peer_id_;
  bool is_admin_;
  bool is_ban_;
  bool is_txt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_ban_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_quality_report_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_quality_report_msg();
  virtual ~p2ts_quality_report_msg();

  p2ts_quality_report_msg(const p2ts_quality_report_msg& from);

  inline p2ts_quality_report_msg& operator=(const p2ts_quality_report_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_quality_report_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_quality_report_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_quality_report_msg* other);

  // implements Message ----------------------------------------------

  p2ts_quality_report_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_quality_report_msg& from);
  void MergeFrom(const p2ts_quality_report_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required fixed32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required float playing_quality = 3;
  inline bool has_playing_quality() const;
  inline void clear_playing_quality();
  static const int kPlayingQualityFieldNumber = 3;
  inline float playing_quality() const;
  inline void set_playing_quality(float value);

  // required float uplink_lostrate = 4;
  inline bool has_uplink_lostrate() const;
  inline void clear_uplink_lostrate();
  static const int kUplinkLostrateFieldNumber = 4;
  inline float uplink_lostrate() const;
  inline void set_uplink_lostrate(float value);

  // required float downlink_lostrate = 5;
  inline bool has_downlink_lostrate() const;
  inline void clear_downlink_lostrate();
  static const int kDownlinkLostrateFieldNumber = 5;
  inline float downlink_lostrate() const;
  inline void set_downlink_lostrate(float value);

  // required float push_rate = 6;
  inline bool has_push_rate() const;
  inline void clear_push_rate();
  static const int kPushRateFieldNumber = 6;
  inline float push_rate() const;
  inline void set_push_rate(float value);

  // required float duplicate_rate = 7;
  inline bool has_duplicate_rate() const;
  inline void clear_duplicate_rate();
  static const int kDuplicateRateFieldNumber = 7;
  inline float duplicate_rate() const;
  inline void set_duplicate_rate(float value);

  // required float share_rate = 8;
  inline bool has_share_rate() const;
  inline void clear_share_rate();
  static const int kShareRateFieldNumber = 8;
  inline float share_rate() const;
  inline void set_share_rate(float value);

  // required float buffer_health = 9;
  inline bool has_buffer_health() const;
  inline void clear_buffer_health();
  static const int kBufferHealthFieldNumber = 9;
  inline float buffer_health() const;
  inline void set_buffer_health(float value);

  // optional int32 delay = 10;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 10;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);

  // optional int32 cpu = 11;
  inline bool has_cpu() const;
  inline void clear_cpu();
  static const int kCpuFieldNumber = 11;
  inline ::google::protobuf::int32 cpu() const;
  inline void set_cpu(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_quality_report_msg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_playing_quality();
  inline void clear_has_playing_quality();
  inline void set_has_uplink_lostrate();
  inline void clear_has_uplink_lostrate();
  inline void set_has_downlink_lostrate();
  inline void clear_has_downlink_lostrate();
  inline void set_has_push_rate();
  inline void clear_has_push_rate();
  inline void set_has_duplicate_rate();
  inline void clear_has_duplicate_rate();
  inline void set_has_share_rate();
  inline void clear_has_share_rate();
  inline void set_has_buffer_health();
  inline void clear_has_buffer_health();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_cpu();
  inline void clear_has_cpu();

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 ip_;
  float playing_quality_;
  float uplink_lostrate_;
  float downlink_lostrate_;
  float push_rate_;
  float duplicate_rate_;
  float share_rate_;
  float buffer_health_;
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int32 cpu_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_quality_report_msg* default_instance_;
};
// -------------------------------------------------------------------

class cached_channel_info : public ::google::protobuf::MessageLite {
 public:
  cached_channel_info();
  virtual ~cached_channel_info();

  cached_channel_info(const cached_channel_info& from);

  inline cached_channel_info& operator=(const cached_channel_info& from) {
    CopyFrom(from);
    return *this;
  }

  static const cached_channel_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const cached_channel_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(cached_channel_info* other);

  // implements Message ----------------------------------------------

  cached_channel_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const cached_channel_info& from);
  void MergeFrom(const cached_channel_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 healthy = 1;
  inline bool has_healthy() const;
  inline void clear_healthy();
  static const int kHealthyFieldNumber = 1;
  inline ::google::protobuf::int32 healthy() const;
  inline void set_healthy(::google::protobuf::int32 value);

  // required bytes channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:p2message.cached_channel_info)
 private:
  inline void set_has_healthy();
  inline void clear_has_healthy();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::std::string* channel_id_;
  ::google::protobuf::int32 healthy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static cached_channel_info* default_instance_;
};
// -------------------------------------------------------------------

class p2ts_cache_announce_msg : public ::google::protobuf::MessageLite {
 public:
  p2ts_cache_announce_msg();
  virtual ~p2ts_cache_announce_msg();

  p2ts_cache_announce_msg(const p2ts_cache_announce_msg& from);

  inline p2ts_cache_announce_msg& operator=(const p2ts_cache_announce_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2ts_cache_announce_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2ts_cache_announce_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2ts_cache_announce_msg* other);

  // implements Message ----------------------------------------------

  p2ts_cache_announce_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2ts_cache_announce_msg& from);
  void MergeFrom(const p2ts_cache_announce_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .p2message.cached_channel_info cached_channels = 1;
  inline int cached_channels_size() const;
  inline void clear_cached_channels();
  static const int kCachedChannelsFieldNumber = 1;
  inline const ::p2message::cached_channel_info& cached_channels(int index) const;
  inline ::p2message::cached_channel_info* mutable_cached_channels(int index);
  inline ::p2message::cached_channel_info* add_cached_channels();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::cached_channel_info >&
      cached_channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::cached_channel_info >*
      mutable_cached_channels();

  // repeated bytes erased_channels = 2;
  inline int erased_channels_size() const;
  inline void clear_erased_channels();
  static const int kErasedChannelsFieldNumber = 2;
  inline const ::std::string& erased_channels(int index) const;
  inline ::std::string* mutable_erased_channels(int index);
  inline void set_erased_channels(int index, const ::std::string& value);
  inline void set_erased_channels(int index, const char* value);
  inline void set_erased_channels(int index, const void* value, size_t size);
  inline ::std::string* add_erased_channels();
  inline void add_erased_channels(const ::std::string& value);
  inline void add_erased_channels(const char* value);
  inline void add_erased_channels(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& erased_channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_erased_channels();

  // required .p2message.peer_info peer_info = 3;
  inline bool has_peer_info() const;
  inline void clear_peer_info();
  static const int kPeerInfoFieldNumber = 3;
  inline const ::p2message::peer_info& peer_info() const;
  inline ::p2message::peer_info* mutable_peer_info();
  inline ::p2message::peer_info* release_peer_info();
  inline void set_allocated_peer_info(::p2message::peer_info* peer_info);

  // @@protoc_insertion_point(class_scope:p2message.p2ts_cache_announce_msg)
 private:
  inline void set_has_peer_info();
  inline void clear_has_peer_info();

  ::google::protobuf::RepeatedPtrField< ::p2message::cached_channel_info > cached_channels_;
  ::google::protobuf::RepeatedPtrField< ::std::string> erased_channels_;
  ::p2message::peer_info* peer_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2ts_cache_announce_msg* default_instance_;
};
// -------------------------------------------------------------------

class s2p_recommend_seed_msg : public ::google::protobuf::MessageLite {
 public:
  s2p_recommend_seed_msg();
  virtual ~s2p_recommend_seed_msg();

  s2p_recommend_seed_msg(const s2p_recommend_seed_msg& from);

  inline s2p_recommend_seed_msg& operator=(const s2p_recommend_seed_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const s2p_recommend_seed_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const s2p_recommend_seed_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(s2p_recommend_seed_msg* other);

  // implements Message ----------------------------------------------

  s2p_recommend_seed_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s2p_recommend_seed_msg& from);
  void MergeFrom(const s2p_recommend_seed_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ttl = 1 [default = 6];
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 1;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.s2p_recommend_seed_msg)
 private:
  inline void set_has_ttl();
  inline void clear_has_ttl();

  ::google::protobuf::uint32 ttl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static s2p_recommend_seed_msg* default_instance_;
};
// -------------------------------------------------------------------

class s2p_piece_notify : public ::google::protobuf::MessageLite {
 public:
  s2p_piece_notify();
  virtual ~s2p_piece_notify();

  s2p_piece_notify(const s2p_piece_notify& from);

  inline s2p_piece_notify& operator=(const s2p_piece_notify& from) {
    CopyFrom(from);
    return *this;
  }

  static const s2p_piece_notify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const s2p_piece_notify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(s2p_piece_notify* other);

  // implements Message ----------------------------------------------

  s2p_piece_notify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s2p_piece_notify& from);
  void MergeFrom(const s2p_piece_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .p2message.buffermap_info buffermap = 1;
  inline bool has_buffermap() const;
  inline void clear_buffermap();
  static const int kBuffermapFieldNumber = 1;
  inline const ::p2message::buffermap_info& buffermap() const;
  inline ::p2message::buffermap_info* mutable_buffermap();
  inline ::p2message::buffermap_info* release_buffermap();
  inline void set_allocated_buffermap(::p2message::buffermap_info* buffermap);

  // @@protoc_insertion_point(class_scope:p2message.s2p_piece_notify)
 private:
  inline void set_has_buffermap();
  inline void clear_has_buffermap();

  ::p2message::buffermap_info* buffermap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static s2p_piece_notify* default_instance_;
};
// -------------------------------------------------------------------

class p2s_info_report_msg : public ::google::protobuf::MessageLite {
 public:
  p2s_info_report_msg();
  virtual ~p2s_info_report_msg();

  p2s_info_report_msg(const p2s_info_report_msg& from);

  inline p2s_info_report_msg& operator=(const p2s_info_report_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2s_info_report_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2s_info_report_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2s_info_report_msg* other);

  // implements Message ----------------------------------------------

  p2s_info_report_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2s_info_report_msg& from);
  void MergeFrom(const p2s_info_report_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 upload_speed = 1;
  inline bool has_upload_speed() const;
  inline void clear_upload_speed();
  static const int kUploadSpeedFieldNumber = 1;
  inline ::google::protobuf::uint32 upload_speed() const;
  inline void set_upload_speed(::google::protobuf::uint32 value);

  // required float lost_rate = 2;
  inline bool has_lost_rate() const;
  inline void clear_lost_rate();
  static const int kLostRateFieldNumber = 2;
  inline float lost_rate() const;
  inline void set_lost_rate(float value);

  // @@protoc_insertion_point(class_scope:p2message.p2s_info_report_msg)
 private:
  inline void set_has_upload_speed();
  inline void clear_has_upload_speed();
  inline void set_has_lost_rate();
  inline void clear_has_lost_rate();

  ::google::protobuf::uint32 upload_speed_;
  float lost_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2s_info_report_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2p_handshake_msg : public ::google::protobuf::MessageLite {
 public:
  p2p_handshake_msg();
  virtual ~p2p_handshake_msg();

  p2p_handshake_msg(const p2p_handshake_msg& from);

  inline p2p_handshake_msg& operator=(const p2p_handshake_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2p_handshake_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2p_handshake_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2p_handshake_msg* other);

  // implements Message ----------------------------------------------

  p2p_handshake_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2p_handshake_msg& from);
  void MergeFrom(const p2p_handshake_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes playing_channel_id = 1;
  inline bool has_playing_channel_id() const;
  inline void clear_playing_channel_id();
  static const int kPlayingChannelIdFieldNumber = 1;
  inline const ::std::string& playing_channel_id() const;
  inline void set_playing_channel_id(const ::std::string& value);
  inline void set_playing_channel_id(const char* value);
  inline void set_playing_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_playing_channel_id();
  inline ::std::string* release_playing_channel_id();
  inline void set_allocated_playing_channel_id(::std::string* playing_channel_id);

  // required .p2message.peer_info peer_info = 2;
  inline bool has_peer_info() const;
  inline void clear_peer_info();
  static const int kPeerInfoFieldNumber = 2;
  inline const ::p2message::peer_info& peer_info() const;
  inline ::p2message::peer_info* mutable_peer_info();
  inline ::p2message::peer_info* release_peer_info();
  inline void set_allocated_peer_info(::p2message::peer_info* peer_info);

  // optional .p2message.buffermap_info buffermap = 3;
  inline bool has_buffermap() const;
  inline void clear_buffermap();
  static const int kBuffermapFieldNumber = 3;
  inline const ::p2message::buffermap_info& buffermap() const;
  inline ::p2message::buffermap_info* mutable_buffermap();
  inline ::p2message::buffermap_info* release_buffermap();
  inline void set_allocated_buffermap(::p2message::buffermap_info* buffermap);

  // optional bytes compressed_buffermap = 4;
  inline bool has_compressed_buffermap() const;
  inline void clear_compressed_buffermap();
  static const int kCompressedBuffermapFieldNumber = 4;
  inline const ::std::string& compressed_buffermap() const;
  inline void set_compressed_buffermap(const ::std::string& value);
  inline void set_compressed_buffermap(const char* value);
  inline void set_compressed_buffermap(const void* value, size_t size);
  inline ::std::string* mutable_compressed_buffermap();
  inline ::std::string* release_compressed_buffermap();
  inline void set_allocated_compressed_buffermap(::std::string* compressed_buffermap);

  // optional bytes chunkmap = 5;
  inline bool has_chunkmap() const;
  inline void clear_chunkmap();
  static const int kChunkmapFieldNumber = 5;
  inline const ::std::string& chunkmap() const;
  inline void set_chunkmap(const ::std::string& value);
  inline void set_chunkmap(const char* value);
  inline void set_chunkmap(const void* value, size_t size);
  inline ::std::string* mutable_chunkmap();
  inline ::std::string* release_chunkmap();
  inline void set_allocated_chunkmap(::std::string* chunkmap);

  // @@protoc_insertion_point(class_scope:p2message.p2p_handshake_msg)
 private:
  inline void set_has_playing_channel_id();
  inline void clear_has_playing_channel_id();
  inline void set_has_peer_info();
  inline void clear_has_peer_info();
  inline void set_has_buffermap();
  inline void clear_has_buffermap();
  inline void set_has_compressed_buffermap();
  inline void clear_has_compressed_buffermap();
  inline void set_has_chunkmap();
  inline void clear_has_chunkmap();

  ::std::string* playing_channel_id_;
  ::p2message::peer_info* peer_info_;
  ::p2message::buffermap_info* buffermap_;
  ::std::string* compressed_buffermap_;
  ::std::string* chunkmap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2p_handshake_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2p_buffermap_request_msg : public ::google::protobuf::MessageLite {
 public:
  p2p_buffermap_request_msg();
  virtual ~p2p_buffermap_request_msg();

  p2p_buffermap_request_msg(const p2p_buffermap_request_msg& from);

  inline p2p_buffermap_request_msg& operator=(const p2p_buffermap_request_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2p_buffermap_request_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2p_buffermap_request_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2p_buffermap_request_msg* other);

  // implements Message ----------------------------------------------

  p2p_buffermap_request_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2p_buffermap_request_msg& from);
  void MergeFrom(const p2p_buffermap_request_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 min_seqno = 1;
  inline bool has_min_seqno() const;
  inline void clear_min_seqno();
  static const int kMinSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 min_seqno() const;
  inline void set_min_seqno(::google::protobuf::uint32 value);

  // required fixed32 max_seqno = 2;
  inline bool has_max_seqno() const;
  inline void clear_max_seqno();
  static const int kMaxSeqnoFieldNumber = 2;
  inline ::google::protobuf::uint32 max_seqno() const;
  inline void set_max_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.p2p_buffermap_request_msg)
 private:
  inline void set_has_min_seqno();
  inline void clear_has_min_seqno();
  inline void set_has_max_seqno();
  inline void clear_has_max_seqno();

  ::google::protobuf::uint32 min_seqno_;
  ::google::protobuf::uint32 max_seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2p_buffermap_request_msg* default_instance_;
};
// -------------------------------------------------------------------

class p2p_neighbor_table_exchange : public ::google::protobuf::MessageLite {
 public:
  p2p_neighbor_table_exchange();
  virtual ~p2p_neighbor_table_exchange();

  p2p_neighbor_table_exchange(const p2p_neighbor_table_exchange& from);

  inline p2p_neighbor_table_exchange& operator=(const p2p_neighbor_table_exchange& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2p_neighbor_table_exchange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2p_neighbor_table_exchange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2p_neighbor_table_exchange* other);

  // implements Message ----------------------------------------------

  p2p_neighbor_table_exchange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2p_neighbor_table_exchange& from);
  void MergeFrom(const p2p_neighbor_table_exchange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .p2message.peer_info same_channel_peer_info_list = 1;
  inline int same_channel_peer_info_list_size() const;
  inline void clear_same_channel_peer_info_list();
  static const int kSameChannelPeerInfoListFieldNumber = 1;
  inline const ::p2message::peer_info& same_channel_peer_info_list(int index) const;
  inline ::p2message::peer_info* mutable_same_channel_peer_info_list(int index);
  inline ::p2message::peer_info* add_same_channel_peer_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
      same_channel_peer_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
      mutable_same_channel_peer_info_list();

  // repeated .p2message.peer_info cache_peer_info_list = 2;
  inline int cache_peer_info_list_size() const;
  inline void clear_cache_peer_info_list();
  static const int kCachePeerInfoListFieldNumber = 2;
  inline const ::p2message::peer_info& cache_peer_info_list(int index) const;
  inline ::p2message::peer_info* mutable_cache_peer_info_list(int index);
  inline ::p2message::peer_info* add_cache_peer_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
      cache_peer_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
      mutable_cache_peer_info_list();

  // repeated bytes known_neighbor_list = 3;
  inline int known_neighbor_list_size() const;
  inline void clear_known_neighbor_list();
  static const int kKnownNeighborListFieldNumber = 3;
  inline const ::std::string& known_neighbor_list(int index) const;
  inline ::std::string* mutable_known_neighbor_list(int index);
  inline void set_known_neighbor_list(int index, const ::std::string& value);
  inline void set_known_neighbor_list(int index, const char* value);
  inline void set_known_neighbor_list(int index, const void* value, size_t size);
  inline ::std::string* add_known_neighbor_list();
  inline void add_known_neighbor_list(const ::std::string& value);
  inline void add_known_neighbor_list(const char* value);
  inline void add_known_neighbor_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& known_neighbor_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_known_neighbor_list();

  // @@protoc_insertion_point(class_scope:p2message.p2p_neighbor_table_exchange)
 private:

  ::google::protobuf::RepeatedPtrField< ::p2message::peer_info > same_channel_peer_info_list_;
  ::google::protobuf::RepeatedPtrField< ::p2message::peer_info > cache_peer_info_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> known_neighbor_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2p_neighbor_table_exchange* default_instance_;
};
// -------------------------------------------------------------------

class p2p_supervise_request_msg : public ::google::protobuf::MessageLite {
 public:
  p2p_supervise_request_msg();
  virtual ~p2p_supervise_request_msg();

  p2p_supervise_request_msg(const p2p_supervise_request_msg& from);

  inline p2p_supervise_request_msg& operator=(const p2p_supervise_request_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const p2p_supervise_request_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const p2p_supervise_request_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(p2p_supervise_request_msg* other);

  // implements Message ----------------------------------------------

  p2p_supervise_request_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const p2p_supervise_request_msg& from);
  void MergeFrom(const p2p_supervise_request_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .p2message.buffermap_info buffermap = 1;
  inline bool has_buffermap() const;
  inline void clear_buffermap();
  static const int kBuffermapFieldNumber = 1;
  inline const ::p2message::buffermap_info& buffermap() const;
  inline ::p2message::buffermap_info* mutable_buffermap();
  inline ::p2message::buffermap_info* release_buffermap();
  inline void set_allocated_buffermap(::p2message::buffermap_info* buffermap);

  // required uint32 peer_key = 2;
  inline bool has_peer_key() const;
  inline void clear_peer_key();
  static const int kPeerKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 peer_key() const;
  inline void set_peer_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:p2message.p2p_supervise_request_msg)
 private:
  inline void set_has_buffermap();
  inline void clear_has_buffermap();
  inline void set_has_peer_key();
  inline void clear_has_peer_key();

  ::p2message::buffermap_info* buffermap_;
  ::google::protobuf::uint32 peer_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static p2p_supervise_request_msg* default_instance_;
};
// -------------------------------------------------------------------

class relay_msg : public ::google::protobuf::MessageLite {
 public:
  relay_msg();
  virtual ~relay_msg();

  relay_msg(const relay_msg& from);

  inline relay_msg& operator=(const relay_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const relay_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const relay_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(relay_msg* other);

  // implements Message ----------------------------------------------

  relay_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const relay_msg& from);
  void MergeFrom(const relay_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required uint64 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // required bytes src_peer_id = 3;
  inline bool has_src_peer_id() const;
  inline void clear_src_peer_id();
  static const int kSrcPeerIdFieldNumber = 3;
  inline const ::std::string& src_peer_id() const;
  inline void set_src_peer_id(const ::std::string& value);
  inline void set_src_peer_id(const char* value);
  inline void set_src_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_src_peer_id();
  inline ::std::string* release_src_peer_id();
  inline void set_allocated_src_peer_id(::std::string* src_peer_id);

  // required bytes dst_peer_id = 4;
  inline bool has_dst_peer_id() const;
  inline void clear_dst_peer_id();
  static const int kDstPeerIdFieldNumber = 4;
  inline const ::std::string& dst_peer_id() const;
  inline void set_dst_peer_id(const ::std::string& value);
  inline void set_dst_peer_id(const char* value);
  inline void set_dst_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_dst_peer_id();
  inline ::std::string* release_dst_peer_id();
  inline void set_allocated_dst_peer_id(::std::string* dst_peer_id);

  // required uint32 ttl = 5 [default = 4];
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 5;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // required bytes msg_data = 6;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 6;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // optional bytes channel_uuid = 7;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 7;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // @@protoc_insertion_point(class_scope:p2message.relay_msg)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_src_peer_id();
  inline void clear_has_src_peer_id();
  inline void set_has_dst_peer_id();
  inline void clear_has_dst_peer_id();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();

  ::google::protobuf::uint64 msg_id_;
  ::std::string* src_peer_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::uint32 ttl_;
  ::std::string* dst_peer_id_;
  ::std::string* msg_data_;
  ::std::string* channel_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static relay_msg* default_instance_;
};
// -------------------------------------------------------------------

class broadcast_msg : public ::google::protobuf::MessageLite {
 public:
  broadcast_msg();
  virtual ~broadcast_msg();

  broadcast_msg(const broadcast_msg& from);

  inline broadcast_msg& operator=(const broadcast_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const broadcast_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const broadcast_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(broadcast_msg* other);

  // implements Message ----------------------------------------------

  broadcast_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const broadcast_msg& from);
  void MergeFrom(const broadcast_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required uint64 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // required bytes src_peer_id = 3;
  inline bool has_src_peer_id() const;
  inline void clear_src_peer_id();
  static const int kSrcPeerIdFieldNumber = 3;
  inline const ::std::string& src_peer_id() const;
  inline void set_src_peer_id(const ::std::string& value);
  inline void set_src_peer_id(const char* value);
  inline void set_src_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_src_peer_id();
  inline ::std::string* release_src_peer_id();
  inline void set_allocated_src_peer_id(::std::string* src_peer_id);

  // required uint32 ttl = 4 [default = 4];
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 4;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // optional bytes bloomfilter = 5;
  inline bool has_bloomfilter() const;
  inline void clear_bloomfilter();
  static const int kBloomfilterFieldNumber = 5;
  inline const ::std::string& bloomfilter() const;
  inline void set_bloomfilter(const ::std::string& value);
  inline void set_bloomfilter(const char* value);
  inline void set_bloomfilter(const void* value, size_t size);
  inline ::std::string* mutable_bloomfilter();
  inline ::std::string* release_bloomfilter();
  inline void set_allocated_bloomfilter(::std::string* bloomfilter);

  // required bytes msg_data = 6;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 6;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:p2message.broadcast_msg)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_src_peer_id();
  inline void clear_has_src_peer_id();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_bloomfilter();
  inline void clear_has_bloomfilter();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::google::protobuf::uint64 msg_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::uint32 ttl_;
  ::std::string* src_peer_id_;
  ::std::string* bloomfilter_;
  ::std::string* msg_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static broadcast_msg* default_instance_;
};
// -------------------------------------------------------------------

class buffermap_exchange_msg : public ::google::protobuf::MessageLite {
 public:
  buffermap_exchange_msg();
  virtual ~buffermap_exchange_msg();

  buffermap_exchange_msg(const buffermap_exchange_msg& from);

  inline buffermap_exchange_msg& operator=(const buffermap_exchange_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const buffermap_exchange_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const buffermap_exchange_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(buffermap_exchange_msg* other);

  // implements Message ----------------------------------------------

  buffermap_exchange_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const buffermap_exchange_msg& from);
  void MergeFrom(const buffermap_exchange_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .p2message.buffermap_info buffermap = 1;
  inline bool has_buffermap() const;
  inline void clear_buffermap();
  static const int kBuffermapFieldNumber = 1;
  inline const ::p2message::buffermap_info& buffermap() const;
  inline ::p2message::buffermap_info* mutable_buffermap();
  inline ::p2message::buffermap_info* release_buffermap();
  inline void set_allocated_buffermap(::p2message::buffermap_info* buffermap);

  // optional sfixed32 current_playing_timestamp = 2;
  inline bool has_current_playing_timestamp() const;
  inline void clear_current_playing_timestamp();
  static const int kCurrentPlayingTimestampFieldNumber = 2;
  inline ::google::protobuf::int32 current_playing_timestamp() const;
  inline void set_current_playing_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:p2message.buffermap_exchange_msg)
 private:
  inline void set_has_buffermap();
  inline void clear_has_buffermap();
  inline void set_has_current_playing_timestamp();
  inline void clear_has_current_playing_timestamp();

  ::p2message::buffermap_info* buffermap_;
  ::google::protobuf::int32 current_playing_timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static buffermap_exchange_msg* default_instance_;
};
// -------------------------------------------------------------------

class join_channel_msg : public ::google::protobuf::MessageLite {
 public:
  join_channel_msg();
  virtual ~join_channel_msg();

  join_channel_msg(const join_channel_msg& from);

  inline join_channel_msg& operator=(const join_channel_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const join_channel_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const join_channel_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(join_channel_msg* other);

  // implements Message ----------------------------------------------

  join_channel_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const join_channel_msg& from);
  void MergeFrom(const join_channel_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:p2message.join_channel_msg)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::std::string* channel_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static join_channel_msg* default_instance_;
};
// -------------------------------------------------------------------

class media_request_msg : public ::google::protobuf::MessageLite {
 public:
  media_request_msg();
  virtual ~media_request_msg();

  media_request_msg(const media_request_msg& from);

  inline media_request_msg& operator=(const media_request_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const media_request_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const media_request_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(media_request_msg* other);

  // implements Message ----------------------------------------------

  media_request_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const media_request_msg& from);
  void MergeFrom(const media_request_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool direct_request = 1;
  inline bool has_direct_request() const;
  inline void clear_direct_request();
  static const int kDirectRequestFieldNumber = 1;
  inline bool direct_request() const;
  inline void set_direct_request(bool value);

  // required bytes peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // repeated fixed32 seqno = 3;
  inline int seqno_size() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 3;
  inline ::google::protobuf::uint32 seqno(int index) const;
  inline void set_seqno(int index, ::google::protobuf::uint32 value);
  inline void add_seqno(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      seqno() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_seqno();

  // optional sfixed32 current_playing_timestamp = 4;
  inline bool has_current_playing_timestamp() const;
  inline void clear_current_playing_timestamp();
  static const int kCurrentPlayingTimestampFieldNumber = 4;
  inline ::google::protobuf::int32 current_playing_timestamp() const;
  inline void set_current_playing_timestamp(::google::protobuf::int32 value);

  // optional bytes channel_id = 5;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 5;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // optional .p2message.buffermap_info buffermap = 6;
  inline bool has_buffermap() const;
  inline void clear_buffermap();
  static const int kBuffermapFieldNumber = 6;
  inline const ::p2message::buffermap_info& buffermap() const;
  inline ::p2message::buffermap_info* mutable_buffermap();
  inline ::p2message::buffermap_info* release_buffermap();
  inline void set_allocated_buffermap(::p2message::buffermap_info* buffermap);

  // @@protoc_insertion_point(class_scope:p2message.media_request_msg)
 private:
  inline void set_has_direct_request();
  inline void clear_has_direct_request();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_current_playing_timestamp();
  inline void clear_has_current_playing_timestamp();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_buffermap();
  inline void clear_has_buffermap();

  ::std::string* peer_id_;
  bool direct_request_;
  ::google::protobuf::int32 current_playing_timestamp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > seqno_;
  ::std::string* channel_id_;
  ::p2message::buffermap_info* buffermap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static media_request_msg* default_instance_;
};
// -------------------------------------------------------------------

class media_subscription_msg : public ::google::protobuf::MessageLite {
 public:
  media_subscription_msg();
  virtual ~media_subscription_msg();

  media_subscription_msg(const media_subscription_msg& from);

  inline media_subscription_msg& operator=(const media_subscription_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const media_subscription_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const media_subscription_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(media_subscription_msg* other);

  // implements Message ----------------------------------------------

  media_subscription_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const media_subscription_msg& from);
  void MergeFrom(const media_subscription_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 substream_id = 1;
  inline int substream_id_size() const;
  inline void clear_substream_id();
  static const int kSubstreamIdFieldNumber = 1;
  inline ::google::protobuf::uint32 substream_id(int index) const;
  inline void set_substream_id(int index, ::google::protobuf::uint32 value);
  inline void add_substream_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      substream_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_substream_id();

  // required .p2message.buffermap_info buffermap = 2;
  inline bool has_buffermap() const;
  inline void clear_buffermap();
  static const int kBuffermapFieldNumber = 2;
  inline const ::p2message::buffermap_info& buffermap() const;
  inline ::p2message::buffermap_info* mutable_buffermap();
  inline ::p2message::buffermap_info* release_buffermap();
  inline void set_allocated_buffermap(::p2message::buffermap_info* buffermap);

  // repeated fixed32 ignore_seqno_list = 3;
  inline int ignore_seqno_list_size() const;
  inline void clear_ignore_seqno_list();
  static const int kIgnoreSeqnoListFieldNumber = 3;
  inline ::google::protobuf::uint32 ignore_seqno_list(int index) const;
  inline void set_ignore_seqno_list(int index, ::google::protobuf::uint32 value);
  inline void add_ignore_seqno_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ignore_seqno_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ignore_seqno_list();

  // optional sfixed32 current_playing_timestamp = 4;
  inline bool has_current_playing_timestamp() const;
  inline void clear_current_playing_timestamp();
  static const int kCurrentPlayingTimestampFieldNumber = 4;
  inline ::google::protobuf::int32 current_playing_timestamp() const;
  inline void set_current_playing_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:p2message.media_subscription_msg)
 private:
  inline void set_has_buffermap();
  inline void clear_has_buffermap();
  inline void set_has_current_playing_timestamp();
  inline void clear_has_current_playing_timestamp();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > substream_id_;
  ::p2message::buffermap_info* buffermap_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ignore_seqno_list_;
  ::google::protobuf::int32 current_playing_timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static media_subscription_msg* default_instance_;
};
// -------------------------------------------------------------------

class punch_request_msg : public ::google::protobuf::MessageLite {
 public:
  punch_request_msg();
  virtual ~punch_request_msg();

  punch_request_msg(const punch_request_msg& from);

  inline punch_request_msg& operator=(const punch_request_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const punch_request_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const punch_request_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(punch_request_msg* other);

  // implements Message ----------------------------------------------

  punch_request_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const punch_request_msg& from);
  void MergeFrom(const punch_request_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required bytes msg_data = 3;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 3;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:p2message.punch_request_msg)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* msg_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static punch_request_msg* default_instance_;
};
// -------------------------------------------------------------------

class media_sent_confirm_msg : public ::google::protobuf::MessageLite {
 public:
  media_sent_confirm_msg();
  virtual ~media_sent_confirm_msg();

  media_sent_confirm_msg(const media_sent_confirm_msg& from);

  inline media_sent_confirm_msg& operator=(const media_sent_confirm_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const media_sent_confirm_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const media_sent_confirm_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(media_sent_confirm_msg* other);

  // implements Message ----------------------------------------------

  media_sent_confirm_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const media_sent_confirm_msg& from);
  void MergeFrom(const media_sent_confirm_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 seqno = 1;
  inline int seqno_size() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno(int index) const;
  inline void set_seqno(int index, ::google::protobuf::uint32 value);
  inline void add_seqno(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      seqno() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_seqno();

  // @@protoc_insertion_point(class_scope:p2message.media_sent_confirm_msg)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static media_sent_confirm_msg* default_instance_;
};
// -------------------------------------------------------------------

class no_piece_msg : public ::google::protobuf::MessageLite {
 public:
  no_piece_msg();
  virtual ~no_piece_msg();

  no_piece_msg(const no_piece_msg& from);

  inline no_piece_msg& operator=(const no_piece_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const no_piece_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const no_piece_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(no_piece_msg* other);

  // implements Message ----------------------------------------------

  no_piece_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const no_piece_msg& from);
  void MergeFrom(const no_piece_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional fixed32 min_seqno = 2;
  inline bool has_min_seqno() const;
  inline void clear_min_seqno();
  static const int kMinSeqnoFieldNumber = 2;
  inline ::google::protobuf::uint32 min_seqno() const;
  inline void set_min_seqno(::google::protobuf::uint32 value);

  // optional fixed32 max_seqno = 3;
  inline bool has_max_seqno() const;
  inline void clear_max_seqno();
  static const int kMaxSeqnoFieldNumber = 3;
  inline ::google::protobuf::uint32 max_seqno() const;
  inline void set_max_seqno(::google::protobuf::uint32 value);

  // optional int32 wait_time = 4;
  inline bool has_wait_time() const;
  inline void clear_wait_time();
  static const int kWaitTimeFieldNumber = 4;
  inline ::google::protobuf::int32 wait_time() const;
  inline void set_wait_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:p2message.no_piece_msg)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_min_seqno();
  inline void clear_has_min_seqno();
  inline void set_has_max_seqno();
  inline void clear_has_max_seqno();
  inline void set_has_wait_time();
  inline void clear_has_wait_time();

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 min_seqno_;
  ::google::protobuf::uint32 max_seqno_;
  ::google::protobuf::int32 wait_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static no_piece_msg* default_instance_;
};
// -------------------------------------------------------------------

class time_server_2_tracker : public ::google::protobuf::MessageLite {
 public:
  time_server_2_tracker();
  virtual ~time_server_2_tracker();

  time_server_2_tracker(const time_server_2_tracker& from);

  inline time_server_2_tracker& operator=(const time_server_2_tracker& from) {
    CopyFrom(from);
    return *this;
  }

  static const time_server_2_tracker& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const time_server_2_tracker* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(time_server_2_tracker* other);

  // implements Message ----------------------------------------------

  time_server_2_tracker* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const time_server_2_tracker& from);
  void MergeFrom(const time_server_2_tracker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 curr_time = 1;
  inline bool has_curr_time() const;
  inline void clear_curr_time();
  static const int kCurrTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 curr_time() const;
  inline void set_curr_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:p2message.time_server_2_tracker)
 private:
  inline void set_has_curr_time();
  inline void clear_has_curr_time();

  ::google::protobuf::uint64 curr_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static time_server_2_tracker* default_instance_;
};
// -------------------------------------------------------------------

class ctrl2m_create_channel_msg : public ::google::protobuf::MessageLite {
 public:
  ctrl2m_create_channel_msg();
  virtual ~ctrl2m_create_channel_msg();

  ctrl2m_create_channel_msg(const ctrl2m_create_channel_msg& from);

  inline ctrl2m_create_channel_msg& operator=(const ctrl2m_create_channel_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ctrl2m_create_channel_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ctrl2m_create_channel_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ctrl2m_create_channel_msg* other);

  // implements Message ----------------------------------------------

  ctrl2m_create_channel_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ctrl2m_create_channel_msg& from);
  void MergeFrom(const ctrl2m_create_channel_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes channel_link = 3;
  inline bool has_channel_link() const;
  inline void clear_channel_link();
  static const int kChannelLinkFieldNumber = 3;
  inline const ::std::string& channel_link() const;
  inline void set_channel_link(const ::std::string& value);
  inline void set_channel_link(const char* value);
  inline void set_channel_link(const void* value, size_t size);
  inline ::std::string* mutable_channel_link();
  inline ::std::string* release_channel_link();
  inline void set_allocated_channel_link(::std::string* channel_link);

  // required bytes channel_uuid = 4;
  inline bool has_channel_uuid() const;
  inline void clear_channel_uuid();
  static const int kChannelUuidFieldNumber = 4;
  inline const ::std::string& channel_uuid() const;
  inline void set_channel_uuid(const ::std::string& value);
  inline void set_channel_uuid(const char* value);
  inline void set_channel_uuid(const void* value, size_t size);
  inline ::std::string* mutable_channel_uuid();
  inline ::std::string* release_channel_uuid();
  inline void set_allocated_channel_uuid(::std::string* channel_uuid);

  // required bytes internal_address = 5;
  inline bool has_internal_address() const;
  inline void clear_internal_address();
  static const int kInternalAddressFieldNumber = 5;
  inline const ::std::string& internal_address() const;
  inline void set_internal_address(const ::std::string& value);
  inline void set_internal_address(const char* value);
  inline void set_internal_address(const void* value, size_t size);
  inline ::std::string* mutable_internal_address();
  inline ::std::string* release_internal_address();
  inline void set_allocated_internal_address(::std::string* internal_address);

  // required bytes external_address = 6;
  inline bool has_external_address() const;
  inline void clear_external_address();
  static const int kExternalAddressFieldNumber = 6;
  inline const ::std::string& external_address() const;
  inline void set_external_address(const ::std::string& value);
  inline void set_external_address(const char* value);
  inline void set_external_address(const void* value, size_t size);
  inline ::std::string* mutable_external_address();
  inline ::std::string* release_external_address();
  inline void set_allocated_external_address(::std::string* external_address);

  // repeated bytes tracker_address = 7;
  inline int tracker_address_size() const;
  inline void clear_tracker_address();
  static const int kTrackerAddressFieldNumber = 7;
  inline const ::std::string& tracker_address(int index) const;
  inline ::std::string* mutable_tracker_address(int index);
  inline void set_tracker_address(int index, const ::std::string& value);
  inline void set_tracker_address(int index, const char* value);
  inline void set_tracker_address(int index, const void* value, size_t size);
  inline ::std::string* add_tracker_address();
  inline void add_tracker_address(const ::std::string& value);
  inline void add_tracker_address(const char* value);
  inline void add_tracker_address(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tracker_address() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tracker_address();

  // optional bool enable_live_cache = 8;
  inline bool has_enable_live_cache() const;
  inline void clear_enable_live_cache();
  static const int kEnableLiveCacheFieldNumber = 8;
  inline bool enable_live_cache() const;
  inline void set_enable_live_cache(bool value);

  // optional bytes stream_recv_url = 9;
  inline bool has_stream_recv_url() const;
  inline void clear_stream_recv_url();
  static const int kStreamRecvUrlFieldNumber = 9;
  inline const ::std::string& stream_recv_url() const;
  inline void set_stream_recv_url(const ::std::string& value);
  inline void set_stream_recv_url(const char* value);
  inline void set_stream_recv_url(const void* value, size_t size);
  inline ::std::string* mutable_stream_recv_url();
  inline ::std::string* release_stream_recv_url();
  inline void set_allocated_stream_recv_url(::std::string* stream_recv_url);

  // optional bytes live_cache_dir = 10;
  inline bool has_live_cache_dir() const;
  inline void clear_live_cache_dir();
  static const int kLiveCacheDirFieldNumber = 10;
  inline const ::std::string& live_cache_dir() const;
  inline void set_live_cache_dir(const ::std::string& value);
  inline void set_live_cache_dir(const char* value);
  inline void set_live_cache_dir(const void* value, size_t size);
  inline ::std::string* mutable_live_cache_dir();
  inline ::std::string* release_live_cache_dir();
  inline void set_allocated_live_cache_dir(::std::string* live_cache_dir);

  // optional uint64 max_duration = 11;
  inline bool has_max_duration() const;
  inline void clear_max_duration();
  static const int kMaxDurationFieldNumber = 11;
  inline ::google::protobuf::uint64 max_duration() const;
  inline void set_max_duration(::google::protobuf::uint64 value);

  // optional uint64 max_length_per_file = 12;
  inline bool has_max_length_per_file() const;
  inline void clear_max_length_per_file();
  static const int kMaxLengthPerFileFieldNumber = 12;
  inline ::google::protobuf::uint64 max_length_per_file() const;
  inline void set_max_length_per_file(::google::protobuf::uint64 value);

  // optional bytes media_directory = 13;
  inline bool has_media_directory() const;
  inline void clear_media_directory();
  static const int kMediaDirectoryFieldNumber = 13;
  inline const ::std::string& media_directory() const;
  inline void set_media_directory(const ::std::string& value);
  inline void set_media_directory(const char* value);
  inline void set_media_directory(const void* value, size_t size);
  inline ::std::string* mutable_media_directory();
  inline ::std::string* release_media_directory();
  inline void set_allocated_media_directory(::std::string* media_directory);

  // optional uint64 duration = 14;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 14;
  inline ::google::protobuf::uint64 duration() const;
  inline void set_duration(::google::protobuf::uint64 value);

  // optional uint64 length = 15;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 15;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);

  // optional bytes channel_key = 16;
  inline bool has_channel_key() const;
  inline void clear_channel_key();
  static const int kChannelKeyFieldNumber = 16;
  inline const ::std::string& channel_key() const;
  inline void set_channel_key(const ::std::string& value);
  inline void set_channel_key(const char* value);
  inline void set_channel_key(const void* value, size_t size);
  inline ::std::string* mutable_channel_key();
  inline ::std::string* release_channel_key();
  inline void set_allocated_channel_key(::std::string* channel_key);

  // @@protoc_insertion_point(class_scope:p2message.ctrl2m_create_channel_msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_channel_link();
  inline void clear_has_channel_link();
  inline void set_has_channel_uuid();
  inline void clear_has_channel_uuid();
  inline void set_has_internal_address();
  inline void clear_has_internal_address();
  inline void set_has_external_address();
  inline void clear_has_external_address();
  inline void set_has_enable_live_cache();
  inline void clear_has_enable_live_cache();
  inline void set_has_stream_recv_url();
  inline void clear_has_stream_recv_url();
  inline void set_has_live_cache_dir();
  inline void clear_has_live_cache_dir();
  inline void set_has_max_duration();
  inline void clear_has_max_duration();
  inline void set_has_max_length_per_file();
  inline void clear_has_max_length_per_file();
  inline void set_has_media_directory();
  inline void clear_has_media_directory();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_channel_key();
  inline void clear_has_channel_key();

  ::std::string* name_;
  ::std::string* channel_link_;
  ::std::string* channel_uuid_;
  ::google::protobuf::int32 type_;
  bool enable_live_cache_;
  ::std::string* internal_address_;
  ::std::string* external_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tracker_address_;
  ::std::string* stream_recv_url_;
  ::std::string* live_cache_dir_;
  ::google::protobuf::uint64 max_duration_;
  ::google::protobuf::uint64 max_length_per_file_;
  ::std::string* media_directory_;
  ::google::protobuf::uint64 duration_;
  ::google::protobuf::uint64 length_;
  ::std::string* channel_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ctrl2m_create_channel_msg* default_instance_;
};
// -------------------------------------------------------------------

class ctrl2s_create_channel_msg : public ::google::protobuf::MessageLite {
 public:
  ctrl2s_create_channel_msg();
  virtual ~ctrl2s_create_channel_msg();

  ctrl2s_create_channel_msg(const ctrl2s_create_channel_msg& from);

  inline ctrl2s_create_channel_msg& operator=(const ctrl2s_create_channel_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ctrl2s_create_channel_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ctrl2s_create_channel_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ctrl2s_create_channel_msg* other);

  // implements Message ----------------------------------------------

  ctrl2s_create_channel_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ctrl2s_create_channel_msg& from);
  void MergeFrom(const ctrl2s_create_channel_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required bytes receive_url = 2;
  inline bool has_receive_url() const;
  inline void clear_receive_url();
  static const int kReceiveUrlFieldNumber = 2;
  inline const ::std::string& receive_url() const;
  inline void set_receive_url(const ::std::string& value);
  inline void set_receive_url(const char* value);
  inline void set_receive_url(const void* value, size_t size);
  inline ::std::string* mutable_receive_url();
  inline ::std::string* release_receive_url();
  inline void set_allocated_receive_url(::std::string* receive_url);

  // repeated bytes send_urls = 3;
  inline int send_urls_size() const;
  inline void clear_send_urls();
  static const int kSendUrlsFieldNumber = 3;
  inline const ::std::string& send_urls(int index) const;
  inline ::std::string* mutable_send_urls(int index);
  inline void set_send_urls(int index, const ::std::string& value);
  inline void set_send_urls(int index, const char* value);
  inline void set_send_urls(int index, const void* value, size_t size);
  inline ::std::string* add_send_urls();
  inline void add_send_urls(const ::std::string& value);
  inline void add_send_urls(const char* value);
  inline void add_send_urls(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& send_urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_send_urls();

  // @@protoc_insertion_point(class_scope:p2message.ctrl2s_create_channel_msg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_receive_url();
  inline void clear_has_receive_url();

  ::std::string* id_;
  ::std::string* receive_url_;
  ::google::protobuf::RepeatedPtrField< ::std::string> send_urls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ctrl2s_create_channel_msg* default_instance_;
};
// -------------------------------------------------------------------

class mds_cmd_msg : public ::google::protobuf::MessageLite {
 public:
  mds_cmd_msg();
  virtual ~mds_cmd_msg();

  mds_cmd_msg(const mds_cmd_msg& from);

  inline mds_cmd_msg& operator=(const mds_cmd_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const mds_cmd_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const mds_cmd_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(mds_cmd_msg* other);

  // implements Message ----------------------------------------------

  mds_cmd_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const mds_cmd_msg& from);
  void MergeFrom(const mds_cmd_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required bytes cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const void* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // repeated bytes channel_ids = 3;
  inline int channel_ids_size() const;
  inline void clear_channel_ids();
  static const int kChannelIdsFieldNumber = 3;
  inline const ::std::string& channel_ids(int index) const;
  inline ::std::string* mutable_channel_ids(int index);
  inline void set_channel_ids(int index, const ::std::string& value);
  inline void set_channel_ids(int index, const char* value);
  inline void set_channel_ids(int index, const void* value, size_t size);
  inline ::std::string* add_channel_ids();
  inline void add_channel_ids(const ::std::string& value);
  inline void add_channel_ids(const char* value);
  inline void add_channel_ids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& channel_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_channel_ids();

  // repeated .p2message.ctrl2m_create_channel_msg channel_info = 4;
  inline int channel_info_size() const;
  inline void clear_channel_info();
  static const int kChannelInfoFieldNumber = 4;
  inline const ::p2message::ctrl2m_create_channel_msg& channel_info(int index) const;
  inline ::p2message::ctrl2m_create_channel_msg* mutable_channel_info(int index);
  inline ::p2message::ctrl2m_create_channel_msg* add_channel_info();
  inline const ::google::protobuf::RepeatedPtrField< ::p2message::ctrl2m_create_channel_msg >&
      channel_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::p2message::ctrl2m_create_channel_msg >*
      mutable_channel_info();

  // optional .p2message.ctrl2s_create_channel_msg shunt_info = 5;
  inline bool has_shunt_info() const;
  inline void clear_shunt_info();
  static const int kShuntInfoFieldNumber = 5;
  inline const ::p2message::ctrl2s_create_channel_msg& shunt_info() const;
  inline ::p2message::ctrl2s_create_channel_msg* mutable_shunt_info();
  inline ::p2message::ctrl2s_create_channel_msg* release_shunt_info();
  inline void set_allocated_shunt_info(::p2message::ctrl2s_create_channel_msg* shunt_info);

  // optional bytes config_val = 6;
  inline bool has_config_val() const;
  inline void clear_config_val();
  static const int kConfigValFieldNumber = 6;
  inline const ::std::string& config_val() const;
  inline void set_config_val(const ::std::string& value);
  inline void set_config_val(const char* value);
  inline void set_config_val(const void* value, size_t size);
  inline ::std::string* mutable_config_val();
  inline ::std::string* release_config_val();
  inline void set_allocated_config_val(::std::string* config_val);

  // optional bool is_login_reply = 7;
  inline bool has_is_login_reply() const;
  inline void clear_is_login_reply();
  static const int kIsLoginReplyFieldNumber = 7;
  inline bool is_login_reply() const;
  inline void set_is_login_reply(bool value);

  // @@protoc_insertion_point(class_scope:p2message.mds_cmd_msg)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_shunt_info();
  inline void clear_has_shunt_info();
  inline void set_has_config_val();
  inline void clear_has_config_val();
  inline void set_has_is_login_reply();
  inline void clear_has_is_login_reply();

  ::std::string* session_id_;
  ::std::string* cmd_;
  ::google::protobuf::RepeatedPtrField< ::std::string> channel_ids_;
  ::google::protobuf::RepeatedPtrField< ::p2message::ctrl2m_create_channel_msg > channel_info_;
  ::p2message::ctrl2s_create_channel_msg* shunt_info_;
  ::std::string* config_val_;
  bool is_login_reply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static mds_cmd_msg* default_instance_;
};
// -------------------------------------------------------------------

class c2s_cmd_reply_msg : public ::google::protobuf::MessageLite {
 public:
  c2s_cmd_reply_msg();
  virtual ~c2s_cmd_reply_msg();

  c2s_cmd_reply_msg(const c2s_cmd_reply_msg& from);

  inline c2s_cmd_reply_msg& operator=(const c2s_cmd_reply_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const c2s_cmd_reply_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const c2s_cmd_reply_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(c2s_cmd_reply_msg* other);

  // implements Message ----------------------------------------------

  c2s_cmd_reply_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const c2s_cmd_reply_msg& from);
  void MergeFrom(const c2s_cmd_reply_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // required bytes id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes msg = 5;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 5;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:p2message.c2s_cmd_reply_msg)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string* session_id_;
  ::std::string* id_;
  ::google::protobuf::uint32 code_;
  ::google::protobuf::int32 type_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static c2s_cmd_reply_msg* default_instance_;
};
// -------------------------------------------------------------------

class c2s_auth_msg : public ::google::protobuf::MessageLite {
 public:
  c2s_auth_msg();
  virtual ~c2s_auth_msg();

  c2s_auth_msg(const c2s_auth_msg& from);

  inline c2s_auth_msg& operator=(const c2s_auth_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const c2s_auth_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const c2s_auth_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(c2s_auth_msg* other);

  // implements Message ----------------------------------------------

  c2s_auth_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const c2s_auth_msg& from);
  void MergeFrom(const c2s_auth_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:p2message.c2s_auth_msg)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static c2s_auth_msg* default_instance_;
};
// -------------------------------------------------------------------

class alive_alarm_report_msg : public ::google::protobuf::MessageLite {
 public:
  alive_alarm_report_msg();
  virtual ~alive_alarm_report_msg();

  alive_alarm_report_msg(const alive_alarm_report_msg& from);

  inline alive_alarm_report_msg& operator=(const alive_alarm_report_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const alive_alarm_report_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const alive_alarm_report_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(alive_alarm_report_msg* other);

  // implements Message ----------------------------------------------

  alive_alarm_report_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const alive_alarm_report_msg& from);
  void MergeFrom(const alive_alarm_report_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:p2message.alive_alarm_report_msg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::std::string* id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static alive_alarm_report_msg* default_instance_;
};
// ===================================================================


// ===================================================================

// peer_info

// required bytes peer_id = 1;
inline bool peer_info::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void peer_info::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void peer_info::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void peer_info::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& peer_info::peer_id() const {
  return *peer_id_;
}
inline void peer_info::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void peer_info::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void peer_info::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* peer_info::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* peer_info::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void peer_info::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .p2message.peer_nat_type nat_type = 2 [default = NAT_UNKNOWN];
inline bool peer_info::has_nat_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void peer_info::set_has_nat_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void peer_info::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void peer_info::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::p2message::peer_nat_type peer_info::nat_type() const {
  return static_cast< ::p2message::peer_nat_type >(nat_type_);
}
inline void peer_info::set_nat_type(::p2message::peer_nat_type value) {
  assert(::p2message::peer_nat_type_IsValid(value));
  set_has_nat_type();
  nat_type_ = value;
}

// required uint32 upload_capacity = 3 [default = 64000];
inline bool peer_info::has_upload_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void peer_info::set_has_upload_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void peer_info::clear_has_upload_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void peer_info::clear_upload_capacity() {
  upload_capacity_ = 64000u;
  clear_has_upload_capacity();
}
inline ::google::protobuf::uint32 peer_info::upload_capacity() const {
  return upload_capacity_;
}
inline void peer_info::set_upload_capacity(::google::protobuf::uint32 value) {
  set_has_upload_capacity();
  upload_capacity_ = value;
}

// required .p2message.peer_type peer_type = 4 [default = NORMAL_PEER];
inline bool peer_info::has_peer_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void peer_info::set_has_peer_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void peer_info::clear_has_peer_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void peer_info::clear_peer_type() {
  peer_type_ = 3;
  clear_has_peer_type();
}
inline ::p2message::peer_type peer_info::peer_type() const {
  return static_cast< ::p2message::peer_type >(peer_type_);
}
inline void peer_info::set_peer_type(::p2message::peer_type value) {
  assert(::p2message::peer_type_IsValid(value));
  set_has_peer_type();
  peer_type_ = value;
}

// required uint64 join_time = 5 [default = 0];
inline bool peer_info::has_join_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void peer_info::set_has_join_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void peer_info::clear_has_join_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void peer_info::clear_join_time() {
  join_time_ = GOOGLE_ULONGLONG(0);
  clear_has_join_time();
}
inline ::google::protobuf::uint64 peer_info::join_time() const {
  return join_time_;
}
inline void peer_info::set_join_time(::google::protobuf::uint64 value) {
  set_has_join_time();
  join_time_ = value;
}

// required uint32 info_version = 6 [default = 0];
inline bool peer_info::has_info_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void peer_info::set_has_info_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void peer_info::clear_has_info_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void peer_info::clear_info_version() {
  info_version_ = 0u;
  clear_has_info_version();
}
inline ::google::protobuf::uint32 peer_info::info_version() const {
  return info_version_;
}
inline void peer_info::set_info_version(::google::protobuf::uint32 value) {
  set_has_info_version();
  info_version_ = value;
}

// required uint32 external_ip = 7 [default = 0];
inline bool peer_info::has_external_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void peer_info::set_has_external_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void peer_info::clear_has_external_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void peer_info::clear_external_ip() {
  external_ip_ = 0u;
  clear_has_external_ip();
}
inline ::google::protobuf::uint32 peer_info::external_ip() const {
  return external_ip_;
}
inline void peer_info::set_external_ip(::google::protobuf::uint32 value) {
  set_has_external_ip();
  external_ip_ = value;
}

// required uint32 external_udp_port = 8 [default = 0];
inline bool peer_info::has_external_udp_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void peer_info::set_has_external_udp_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void peer_info::clear_has_external_udp_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void peer_info::clear_external_udp_port() {
  external_udp_port_ = 0u;
  clear_has_external_udp_port();
}
inline ::google::protobuf::uint32 peer_info::external_udp_port() const {
  return external_udp_port_;
}
inline void peer_info::set_external_udp_port(::google::protobuf::uint32 value) {
  set_has_external_udp_port();
  external_udp_port_ = value;
}

// required uint32 external_tcp_port = 9 [default = 0];
inline bool peer_info::has_external_tcp_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void peer_info::set_has_external_tcp_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void peer_info::clear_has_external_tcp_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void peer_info::clear_external_tcp_port() {
  external_tcp_port_ = 0u;
  clear_has_external_tcp_port();
}
inline ::google::protobuf::uint32 peer_info::external_tcp_port() const {
  return external_tcp_port_;
}
inline void peer_info::set_external_tcp_port(::google::protobuf::uint32 value) {
  set_has_external_tcp_port();
  external_tcp_port_ = value;
}

// required uint32 internal_ip = 10 [default = 0];
inline bool peer_info::has_internal_ip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void peer_info::set_has_internal_ip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void peer_info::clear_has_internal_ip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void peer_info::clear_internal_ip() {
  internal_ip_ = 0u;
  clear_has_internal_ip();
}
inline ::google::protobuf::uint32 peer_info::internal_ip() const {
  return internal_ip_;
}
inline void peer_info::set_internal_ip(::google::protobuf::uint32 value) {
  set_has_internal_ip();
  internal_ip_ = value;
}

// required uint32 internal_udp_port = 11 [default = 0];
inline bool peer_info::has_internal_udp_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void peer_info::set_has_internal_udp_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void peer_info::clear_has_internal_udp_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void peer_info::clear_internal_udp_port() {
  internal_udp_port_ = 0u;
  clear_has_internal_udp_port();
}
inline ::google::protobuf::uint32 peer_info::internal_udp_port() const {
  return internal_udp_port_;
}
inline void peer_info::set_internal_udp_port(::google::protobuf::uint32 value) {
  set_has_internal_udp_port();
  internal_udp_port_ = value;
}

// required uint32 internal_tcp_port = 12 [default = 0];
inline bool peer_info::has_internal_tcp_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void peer_info::set_has_internal_tcp_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void peer_info::clear_has_internal_tcp_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void peer_info::clear_internal_tcp_port() {
  internal_tcp_port_ = 0u;
  clear_has_internal_tcp_port();
}
inline ::google::protobuf::uint32 peer_info::internal_tcp_port() const {
  return internal_tcp_port_;
}
inline void peer_info::set_internal_tcp_port(::google::protobuf::uint32 value) {
  set_has_internal_tcp_port();
  internal_tcp_port_ = value;
}

// repeated uint32 other_internal_ip = 13;
inline int peer_info::other_internal_ip_size() const {
  return other_internal_ip_.size();
}
inline void peer_info::clear_other_internal_ip() {
  other_internal_ip_.Clear();
}
inline ::google::protobuf::uint32 peer_info::other_internal_ip(int index) const {
  return other_internal_ip_.Get(index);
}
inline void peer_info::set_other_internal_ip(int index, ::google::protobuf::uint32 value) {
  other_internal_ip_.Set(index, value);
}
inline void peer_info::add_other_internal_ip(::google::protobuf::uint32 value) {
  other_internal_ip_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
peer_info::other_internal_ip() const {
  return other_internal_ip_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
peer_info::mutable_other_internal_ip() {
  return &other_internal_ip_;
}

// required int32 relative_playing_point = 14 [default = -1];
inline bool peer_info::has_relative_playing_point() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void peer_info::set_has_relative_playing_point() {
  _has_bits_[0] |= 0x00002000u;
}
inline void peer_info::clear_has_relative_playing_point() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void peer_info::clear_relative_playing_point() {
  relative_playing_point_ = -1;
  clear_has_relative_playing_point();
}
inline ::google::protobuf::int32 peer_info::relative_playing_point() const {
  return relative_playing_point_;
}
inline void peer_info::set_relative_playing_point(::google::protobuf::int32 value) {
  set_has_relative_playing_point();
  relative_playing_point_ = value;
}

// optional float playing_quality = 15;
inline bool peer_info::has_playing_quality() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void peer_info::set_has_playing_quality() {
  _has_bits_[0] |= 0x00004000u;
}
inline void peer_info::clear_has_playing_quality() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void peer_info::clear_playing_quality() {
  playing_quality_ = 0;
  clear_has_playing_quality();
}
inline float peer_info::playing_quality() const {
  return playing_quality_;
}
inline void peer_info::set_playing_quality(float value) {
  set_has_playing_quality();
  playing_quality_ = value;
}

// optional float global_remote_to_local_lost_rate = 16;
inline bool peer_info::has_global_remote_to_local_lost_rate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void peer_info::set_has_global_remote_to_local_lost_rate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void peer_info::clear_has_global_remote_to_local_lost_rate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void peer_info::clear_global_remote_to_local_lost_rate() {
  global_remote_to_local_lost_rate_ = 0;
  clear_has_global_remote_to_local_lost_rate();
}
inline float peer_info::global_remote_to_local_lost_rate() const {
  return global_remote_to_local_lost_rate_;
}
inline void peer_info::set_global_remote_to_local_lost_rate(float value) {
  set_has_global_remote_to_local_lost_rate();
  global_remote_to_local_lost_rate_ = value;
}

// optional bytes user_info = 17;
inline bool peer_info::has_user_info() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void peer_info::set_has_user_info() {
  _has_bits_[0] |= 0x00010000u;
}
inline void peer_info::clear_has_user_info() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void peer_info::clear_user_info() {
  if (user_info_ != &::google::protobuf::internal::kEmptyString) {
    user_info_->clear();
  }
  clear_has_user_info();
}
inline const ::std::string& peer_info::user_info() const {
  return *user_info_;
}
inline void peer_info::set_user_info(const ::std::string& value) {
  set_has_user_info();
  if (user_info_ == &::google::protobuf::internal::kEmptyString) {
    user_info_ = new ::std::string;
  }
  user_info_->assign(value);
}
inline void peer_info::set_user_info(const char* value) {
  set_has_user_info();
  if (user_info_ == &::google::protobuf::internal::kEmptyString) {
    user_info_ = new ::std::string;
  }
  user_info_->assign(value);
}
inline void peer_info::set_user_info(const void* value, size_t size) {
  set_has_user_info();
  if (user_info_ == &::google::protobuf::internal::kEmptyString) {
    user_info_ = new ::std::string;
  }
  user_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* peer_info::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == &::google::protobuf::internal::kEmptyString) {
    user_info_ = new ::std::string;
  }
  return user_info_;
}
inline ::std::string* peer_info::release_user_info() {
  clear_has_user_info();
  if (user_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_info_;
    user_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void peer_info::set_allocated_user_info(::std::string* user_info) {
  if (user_info_ != &::google::protobuf::internal::kEmptyString) {
    delete user_info_;
  }
  if (user_info) {
    set_has_user_info();
    user_info_ = user_info;
  } else {
    clear_has_user_info();
    user_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float version = 18 [default = 1];
inline bool peer_info::has_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void peer_info::set_has_version() {
  _has_bits_[0] |= 0x00020000u;
}
inline void peer_info::clear_has_version() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void peer_info::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline float peer_info::version() const {
  return version_;
}
inline void peer_info::set_version(float value) {
  set_has_version();
  version_ = value;
}

// repeated bytes cache_server_ipport = 19;
inline int peer_info::cache_server_ipport_size() const {
  return cache_server_ipport_.size();
}
inline void peer_info::clear_cache_server_ipport() {
  cache_server_ipport_.Clear();
}
inline const ::std::string& peer_info::cache_server_ipport(int index) const {
  return cache_server_ipport_.Get(index);
}
inline ::std::string* peer_info::mutable_cache_server_ipport(int index) {
  return cache_server_ipport_.Mutable(index);
}
inline void peer_info::set_cache_server_ipport(int index, const ::std::string& value) {
  cache_server_ipport_.Mutable(index)->assign(value);
}
inline void peer_info::set_cache_server_ipport(int index, const char* value) {
  cache_server_ipport_.Mutable(index)->assign(value);
}
inline void peer_info::set_cache_server_ipport(int index, const void* value, size_t size) {
  cache_server_ipport_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* peer_info::add_cache_server_ipport() {
  return cache_server_ipport_.Add();
}
inline void peer_info::add_cache_server_ipport(const ::std::string& value) {
  cache_server_ipport_.Add()->assign(value);
}
inline void peer_info::add_cache_server_ipport(const char* value) {
  cache_server_ipport_.Add()->assign(value);
}
inline void peer_info::add_cache_server_ipport(const void* value, size_t size) {
  cache_server_ipport_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
peer_info::cache_server_ipport() const {
  return cache_server_ipport_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
peer_info::mutable_cache_server_ipport() {
  return &cache_server_ipport_;
}

// -------------------------------------------------------------------

// buffermap_info

// repeated fixed32 recent_seqno = 1;
inline int buffermap_info::recent_seqno_size() const {
  return recent_seqno_.size();
}
inline void buffermap_info::clear_recent_seqno() {
  recent_seqno_.Clear();
}
inline ::google::protobuf::uint32 buffermap_info::recent_seqno(int index) const {
  return recent_seqno_.Get(index);
}
inline void buffermap_info::set_recent_seqno(int index, ::google::protobuf::uint32 value) {
  recent_seqno_.Set(index, value);
}
inline void buffermap_info::add_recent_seqno(::google::protobuf::uint32 value) {
  recent_seqno_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
buffermap_info::recent_seqno() const {
  return recent_seqno_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
buffermap_info::mutable_recent_seqno() {
  return &recent_seqno_;
}

// optional fixed32 bigest_seqno_i_know = 2;
inline bool buffermap_info::has_bigest_seqno_i_know() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffermap_info::set_has_bigest_seqno_i_know() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffermap_info::clear_has_bigest_seqno_i_know() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffermap_info::clear_bigest_seqno_i_know() {
  bigest_seqno_i_know_ = 0u;
  clear_has_bigest_seqno_i_know();
}
inline ::google::protobuf::uint32 buffermap_info::bigest_seqno_i_know() const {
  return bigest_seqno_i_know_;
}
inline void buffermap_info::set_bigest_seqno_i_know(::google::protobuf::uint32 value) {
  set_has_bigest_seqno_i_know();
  bigest_seqno_i_know_ = value;
}

// optional fixed32 smallest_seqno_i_have = 3;
inline bool buffermap_info::has_smallest_seqno_i_have() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void buffermap_info::set_has_smallest_seqno_i_have() {
  _has_bits_[0] |= 0x00000004u;
}
inline void buffermap_info::clear_has_smallest_seqno_i_have() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void buffermap_info::clear_smallest_seqno_i_have() {
  smallest_seqno_i_have_ = 0u;
  clear_has_smallest_seqno_i_have();
}
inline ::google::protobuf::uint32 buffermap_info::smallest_seqno_i_have() const {
  return smallest_seqno_i_have_;
}
inline void buffermap_info::set_smallest_seqno_i_have(::google::protobuf::uint32 value) {
  set_has_smallest_seqno_i_have();
  smallest_seqno_i_have_ = value;
}

// optional fixed32 first_seqno_in_bitset = 4;
inline bool buffermap_info::has_first_seqno_in_bitset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void buffermap_info::set_has_first_seqno_in_bitset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void buffermap_info::clear_has_first_seqno_in_bitset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void buffermap_info::clear_first_seqno_in_bitset() {
  first_seqno_in_bitset_ = 0u;
  clear_has_first_seqno_in_bitset();
}
inline ::google::protobuf::uint32 buffermap_info::first_seqno_in_bitset() const {
  return first_seqno_in_bitset_;
}
inline void buffermap_info::set_first_seqno_in_bitset(::google::protobuf::uint32 value) {
  set_has_first_seqno_in_bitset();
  first_seqno_in_bitset_ = value;
}

// optional fixed32 erased_seq_begin = 5;
inline bool buffermap_info::has_erased_seq_begin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void buffermap_info::set_has_erased_seq_begin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void buffermap_info::clear_has_erased_seq_begin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void buffermap_info::clear_erased_seq_begin() {
  erased_seq_begin_ = 0u;
  clear_has_erased_seq_begin();
}
inline ::google::protobuf::uint32 buffermap_info::erased_seq_begin() const {
  return erased_seq_begin_;
}
inline void buffermap_info::set_erased_seq_begin(::google::protobuf::uint32 value) {
  set_has_erased_seq_begin();
  erased_seq_begin_ = value;
}

// optional fixed32 erased_seq_end = 6;
inline bool buffermap_info::has_erased_seq_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void buffermap_info::set_has_erased_seq_end() {
  _has_bits_[0] |= 0x00000020u;
}
inline void buffermap_info::clear_has_erased_seq_end() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void buffermap_info::clear_erased_seq_end() {
  erased_seq_end_ = 0u;
  clear_has_erased_seq_end();
}
inline ::google::protobuf::uint32 buffermap_info::erased_seq_end() const {
  return erased_seq_end_;
}
inline void buffermap_info::set_erased_seq_end(::google::protobuf::uint32 value) {
  set_has_erased_seq_end();
  erased_seq_end_ = value;
}

// optional bytes bitset = 7;
inline bool buffermap_info::has_bitset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void buffermap_info::set_has_bitset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void buffermap_info::clear_has_bitset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void buffermap_info::clear_bitset() {
  if (bitset_ != &::google::protobuf::internal::kEmptyString) {
    bitset_->clear();
  }
  clear_has_bitset();
}
inline const ::std::string& buffermap_info::bitset() const {
  return *bitset_;
}
inline void buffermap_info::set_bitset(const ::std::string& value) {
  set_has_bitset();
  if (bitset_ == &::google::protobuf::internal::kEmptyString) {
    bitset_ = new ::std::string;
  }
  bitset_->assign(value);
}
inline void buffermap_info::set_bitset(const char* value) {
  set_has_bitset();
  if (bitset_ == &::google::protobuf::internal::kEmptyString) {
    bitset_ = new ::std::string;
  }
  bitset_->assign(value);
}
inline void buffermap_info::set_bitset(const void* value, size_t size) {
  set_has_bitset();
  if (bitset_ == &::google::protobuf::internal::kEmptyString) {
    bitset_ = new ::std::string;
  }
  bitset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* buffermap_info::mutable_bitset() {
  set_has_bitset();
  if (bitset_ == &::google::protobuf::internal::kEmptyString) {
    bitset_ = new ::std::string;
  }
  return bitset_;
}
inline ::std::string* buffermap_info::release_bitset() {
  clear_has_bitset();
  if (bitset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bitset_;
    bitset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void buffermap_info::set_allocated_bitset(::std::string* bitset) {
  if (bitset_ != &::google::protobuf::internal::kEmptyString) {
    delete bitset_;
  }
  if (bitset) {
    set_has_bitset();
    bitset_ = bitset;
  } else {
    clear_has_bitset();
    bitset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated fixed32 iframe_seqno = 8;
inline int buffermap_info::iframe_seqno_size() const {
  return iframe_seqno_.size();
}
inline void buffermap_info::clear_iframe_seqno() {
  iframe_seqno_.Clear();
}
inline ::google::protobuf::uint32 buffermap_info::iframe_seqno(int index) const {
  return iframe_seqno_.Get(index);
}
inline void buffermap_info::set_iframe_seqno(int index, ::google::protobuf::uint32 value) {
  iframe_seqno_.Set(index, value);
}
inline void buffermap_info::add_iframe_seqno(::google::protobuf::uint32 value) {
  iframe_seqno_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
buffermap_info::iframe_seqno() const {
  return iframe_seqno_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
buffermap_info::mutable_iframe_seqno() {
  return &iframe_seqno_;
}

// -------------------------------------------------------------------

// piece_info

// required fixed32 timestamp = 1;
inline bool piece_info::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void piece_info::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void piece_info::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void piece_info::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 piece_info::timestamp() const {
  return timestamp_;
}
inline void piece_info::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required fixed32 seqno = 2;
inline bool piece_info::has_seqno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void piece_info::set_has_seqno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void piece_info::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void piece_info::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 piece_info::seqno() const {
  return seqno_;
}
inline void piece_info::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// live_channel_info

// required bytes channel_uuid = 1;
inline bool live_channel_info::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void live_channel_info::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void live_channel_info::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void live_channel_info::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& live_channel_info::channel_uuid() const {
  return *channel_uuid_;
}
inline void live_channel_info::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void live_channel_info::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void live_channel_info::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* live_channel_info::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* live_channel_info::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void live_channel_info::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required sfixed32 server_time = 2;
inline bool live_channel_info::has_server_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void live_channel_info::set_has_server_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void live_channel_info::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void live_channel_info::clear_server_time() {
  server_time_ = 0;
  clear_has_server_time();
}
inline ::google::protobuf::int32 live_channel_info::server_time() const {
  return server_time_;
}
inline void live_channel_info::set_server_time(::google::protobuf::int32 value) {
  set_has_server_time();
  server_time_ = value;
}

// required fixed32 server_seqno = 3;
inline bool live_channel_info::has_server_seqno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void live_channel_info::set_has_server_seqno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void live_channel_info::clear_has_server_seqno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void live_channel_info::clear_server_seqno() {
  server_seqno_ = 0u;
  clear_has_server_seqno();
}
inline ::google::protobuf::uint32 live_channel_info::server_seqno() const {
  return server_seqno_;
}
inline void live_channel_info::set_server_seqno(::google::protobuf::uint32 value) {
  set_has_server_seqno();
  server_seqno_ = value;
}

// required uint32 server_packet_rate = 4;
inline bool live_channel_info::has_server_packet_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void live_channel_info::set_has_server_packet_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void live_channel_info::clear_has_server_packet_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void live_channel_info::clear_server_packet_rate() {
  server_packet_rate_ = 0u;
  clear_has_server_packet_rate();
}
inline ::google::protobuf::uint32 live_channel_info::server_packet_rate() const {
  return server_packet_rate_;
}
inline void live_channel_info::set_server_packet_rate(::google::protobuf::uint32 value) {
  set_has_server_packet_rate();
  server_packet_rate_ = value;
}

// -------------------------------------------------------------------

// vod_channel_info

// required bytes channel_link = 1;
inline bool vod_channel_info::has_channel_link() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vod_channel_info::set_has_channel_link() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vod_channel_info::clear_has_channel_link() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vod_channel_info::clear_channel_link() {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    channel_link_->clear();
  }
  clear_has_channel_link();
}
inline const ::std::string& vod_channel_info::channel_link() const {
  return *channel_link_;
}
inline void vod_channel_info::set_channel_link(const ::std::string& value) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(value);
}
inline void vod_channel_info::set_channel_link(const char* value) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(value);
}
inline void vod_channel_info::set_channel_link(const void* value, size_t size) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* vod_channel_info::mutable_channel_link() {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  return channel_link_;
}
inline ::std::string* vod_channel_info::release_channel_link() {
  clear_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_link_;
    channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void vod_channel_info::set_allocated_channel_link(::std::string* channel_link) {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_link_;
  }
  if (channel_link) {
    set_has_channel_link();
    channel_link_ = channel_link;
  } else {
    clear_has_channel_link();
    channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes channel_uuid = 2;
inline bool vod_channel_info::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vod_channel_info::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vod_channel_info::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vod_channel_info::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& vod_channel_info::channel_uuid() const {
  return *channel_uuid_;
}
inline void vod_channel_info::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void vod_channel_info::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void vod_channel_info::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* vod_channel_info::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* vod_channel_info::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void vod_channel_info::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 film_duration = 3;
inline bool vod_channel_info::has_film_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vod_channel_info::set_has_film_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void vod_channel_info::clear_has_film_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void vod_channel_info::clear_film_duration() {
  film_duration_ = 0;
  clear_has_film_duration();
}
inline ::google::protobuf::int32 vod_channel_info::film_duration() const {
  return film_duration_;
}
inline void vod_channel_info::set_film_duration(::google::protobuf::int32 value) {
  set_has_film_duration();
  film_duration_ = value;
}

// required int32 film_length = 4;
inline bool vod_channel_info::has_film_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void vod_channel_info::set_has_film_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void vod_channel_info::clear_has_film_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void vod_channel_info::clear_film_length() {
  film_length_ = 0;
  clear_has_film_length();
}
inline ::google::protobuf::int32 vod_channel_info::film_length() const {
  return film_length_;
}
inline void vod_channel_info::set_film_length(::google::protobuf::int32 value) {
  set_has_film_length();
  film_length_ = value;
}

// -------------------------------------------------------------------

// s2ts_channel_report_msg

// required .p2message.live_channel_info channel_info = 1;
inline bool s2ts_channel_report_msg::has_channel_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s2ts_channel_report_msg::set_has_channel_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s2ts_channel_report_msg::clear_has_channel_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s2ts_channel_report_msg::clear_channel_info() {
  if (channel_info_ != NULL) channel_info_->::p2message::live_channel_info::Clear();
  clear_has_channel_info();
}
inline const ::p2message::live_channel_info& s2ts_channel_report_msg::channel_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return channel_info_ != NULL ? *channel_info_ : *default_instance().channel_info_;
#else
  return channel_info_ != NULL ? *channel_info_ : *default_instance_->channel_info_;
#endif
}
inline ::p2message::live_channel_info* s2ts_channel_report_msg::mutable_channel_info() {
  set_has_channel_info();
  if (channel_info_ == NULL) channel_info_ = new ::p2message::live_channel_info;
  return channel_info_;
}
inline ::p2message::live_channel_info* s2ts_channel_report_msg::release_channel_info() {
  clear_has_channel_info();
  ::p2message::live_channel_info* temp = channel_info_;
  channel_info_ = NULL;
  return temp;
}
inline void s2ts_channel_report_msg::set_allocated_channel_info(::p2message::live_channel_info* channel_info) {
  delete channel_info_;
  channel_info_ = channel_info;
  if (channel_info) {
    set_has_channel_info();
  } else {
    clear_has_channel_info();
  }
}

// repeated fixed32 iframe_seqno = 2;
inline int s2ts_channel_report_msg::iframe_seqno_size() const {
  return iframe_seqno_.size();
}
inline void s2ts_channel_report_msg::clear_iframe_seqno() {
  iframe_seqno_.Clear();
}
inline ::google::protobuf::uint32 s2ts_channel_report_msg::iframe_seqno(int index) const {
  return iframe_seqno_.Get(index);
}
inline void s2ts_channel_report_msg::set_iframe_seqno(int index, ::google::protobuf::uint32 value) {
  iframe_seqno_.Set(index, value);
}
inline void s2ts_channel_report_msg::add_iframe_seqno(::google::protobuf::uint32 value) {
  iframe_seqno_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
s2ts_channel_report_msg::iframe_seqno() const {
  return iframe_seqno_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
s2ts_channel_report_msg::mutable_iframe_seqno() {
  return &iframe_seqno_;
}

// -------------------------------------------------------------------

// s2ts_create_channel_msg

// required .p2message.peer_info server_info = 1;
inline bool s2ts_create_channel_msg::has_server_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s2ts_create_channel_msg::set_has_server_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s2ts_create_channel_msg::clear_has_server_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s2ts_create_channel_msg::clear_server_info() {
  if (server_info_ != NULL) server_info_->::p2message::peer_info::Clear();
  clear_has_server_info();
}
inline const ::p2message::peer_info& s2ts_create_channel_msg::server_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return server_info_ != NULL ? *server_info_ : *default_instance().server_info_;
#else
  return server_info_ != NULL ? *server_info_ : *default_instance_->server_info_;
#endif
}
inline ::p2message::peer_info* s2ts_create_channel_msg::mutable_server_info() {
  set_has_server_info();
  if (server_info_ == NULL) server_info_ = new ::p2message::peer_info;
  return server_info_;
}
inline ::p2message::peer_info* s2ts_create_channel_msg::release_server_info() {
  clear_has_server_info();
  ::p2message::peer_info* temp = server_info_;
  server_info_ = NULL;
  return temp;
}
inline void s2ts_create_channel_msg::set_allocated_server_info(::p2message::peer_info* server_info) {
  delete server_info_;
  server_info_ = server_info;
  if (server_info) {
    set_has_server_info();
  } else {
    clear_has_server_info();
  }
}

// optional .p2message.live_channel_info live_channel_info = 2;
inline bool s2ts_create_channel_msg::has_live_channel_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s2ts_create_channel_msg::set_has_live_channel_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s2ts_create_channel_msg::clear_has_live_channel_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s2ts_create_channel_msg::clear_live_channel_info() {
  if (live_channel_info_ != NULL) live_channel_info_->::p2message::live_channel_info::Clear();
  clear_has_live_channel_info();
}
inline const ::p2message::live_channel_info& s2ts_create_channel_msg::live_channel_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return live_channel_info_ != NULL ? *live_channel_info_ : *default_instance().live_channel_info_;
#else
  return live_channel_info_ != NULL ? *live_channel_info_ : *default_instance_->live_channel_info_;
#endif
}
inline ::p2message::live_channel_info* s2ts_create_channel_msg::mutable_live_channel_info() {
  set_has_live_channel_info();
  if (live_channel_info_ == NULL) live_channel_info_ = new ::p2message::live_channel_info;
  return live_channel_info_;
}
inline ::p2message::live_channel_info* s2ts_create_channel_msg::release_live_channel_info() {
  clear_has_live_channel_info();
  ::p2message::live_channel_info* temp = live_channel_info_;
  live_channel_info_ = NULL;
  return temp;
}
inline void s2ts_create_channel_msg::set_allocated_live_channel_info(::p2message::live_channel_info* live_channel_info) {
  delete live_channel_info_;
  live_channel_info_ = live_channel_info;
  if (live_channel_info) {
    set_has_live_channel_info();
  } else {
    clear_has_live_channel_info();
  }
}

// optional .p2message.vod_channel_info vod_channel_info = 3;
inline bool s2ts_create_channel_msg::has_vod_channel_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s2ts_create_channel_msg::set_has_vod_channel_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s2ts_create_channel_msg::clear_has_vod_channel_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s2ts_create_channel_msg::clear_vod_channel_info() {
  if (vod_channel_info_ != NULL) vod_channel_info_->::p2message::vod_channel_info::Clear();
  clear_has_vod_channel_info();
}
inline const ::p2message::vod_channel_info& s2ts_create_channel_msg::vod_channel_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vod_channel_info_ != NULL ? *vod_channel_info_ : *default_instance().vod_channel_info_;
#else
  return vod_channel_info_ != NULL ? *vod_channel_info_ : *default_instance_->vod_channel_info_;
#endif
}
inline ::p2message::vod_channel_info* s2ts_create_channel_msg::mutable_vod_channel_info() {
  set_has_vod_channel_info();
  if (vod_channel_info_ == NULL) vod_channel_info_ = new ::p2message::vod_channel_info;
  return vod_channel_info_;
}
inline ::p2message::vod_channel_info* s2ts_create_channel_msg::release_vod_channel_info() {
  clear_has_vod_channel_info();
  ::p2message::vod_channel_info* temp = vod_channel_info_;
  vod_channel_info_ = NULL;
  return temp;
}
inline void s2ts_create_channel_msg::set_allocated_vod_channel_info(::p2message::vod_channel_info* vod_channel_info) {
  delete vod_channel_info_;
  vod_channel_info_ = vod_channel_info;
  if (vod_channel_info) {
    set_has_vod_channel_info();
  } else {
    clear_has_vod_channel_info();
  }
}

// required uint32 distribute_type = 4;
inline bool s2ts_create_channel_msg::has_distribute_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s2ts_create_channel_msg::set_has_distribute_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s2ts_create_channel_msg::clear_has_distribute_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s2ts_create_channel_msg::clear_distribute_type() {
  distribute_type_ = 0u;
  clear_has_distribute_type();
}
inline ::google::protobuf::uint32 s2ts_create_channel_msg::distribute_type() const {
  return distribute_type_;
}
inline void s2ts_create_channel_msg::set_distribute_type(::google::protobuf::uint32 value) {
  set_has_distribute_type();
  distribute_type_ = value;
}

// -------------------------------------------------------------------

// s2ts_channel_status_req

// required bytes channel_id = 1;
inline bool s2ts_channel_status_req::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s2ts_channel_status_req::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s2ts_channel_status_req::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s2ts_channel_status_req::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& s2ts_channel_status_req::channel_id() const {
  return *channel_id_;
}
inline void s2ts_channel_status_req::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void s2ts_channel_status_req::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void s2ts_channel_status_req::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s2ts_channel_status_req::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* s2ts_channel_status_req::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void s2ts_channel_status_req::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ts2s_channel_status

// required uint32 live_cnt = 1;
inline bool ts2s_channel_status::has_live_cnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ts2s_channel_status::set_has_live_cnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ts2s_channel_status::clear_has_live_cnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ts2s_channel_status::clear_live_cnt() {
  live_cnt_ = 0u;
  clear_has_live_cnt();
}
inline ::google::protobuf::uint32 ts2s_channel_status::live_cnt() const {
  return live_cnt_;
}
inline void ts2s_channel_status::set_live_cnt(::google::protobuf::uint32 value) {
  set_has_live_cnt();
  live_cnt_ = value;
}

// required float playing_quality = 2;
inline bool ts2s_channel_status::has_playing_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ts2s_channel_status::set_has_playing_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ts2s_channel_status::clear_has_playing_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ts2s_channel_status::clear_playing_quality() {
  playing_quality_ = 0;
  clear_has_playing_quality();
}
inline float ts2s_channel_status::playing_quality() const {
  return playing_quality_;
}
inline void ts2s_channel_status::set_playing_quality(float value) {
  set_has_playing_quality();
  playing_quality_ = value;
}

// required float rtol_lost_rate = 3;
inline bool ts2s_channel_status::has_rtol_lost_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ts2s_channel_status::set_has_rtol_lost_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ts2s_channel_status::clear_has_rtol_lost_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ts2s_channel_status::clear_rtol_lost_rate() {
  rtol_lost_rate_ = 0;
  clear_has_rtol_lost_rate();
}
inline float ts2s_channel_status::rtol_lost_rate() const {
  return rtol_lost_rate_;
}
inline void ts2s_channel_status::set_rtol_lost_rate(float value) {
  set_has_rtol_lost_rate();
  rtol_lost_rate_ = value;
}

// optional .p2message.p2ts_quality_report_msg quality_info = 4;
inline bool ts2s_channel_status::has_quality_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ts2s_channel_status::set_has_quality_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ts2s_channel_status::clear_has_quality_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ts2s_channel_status::clear_quality_info() {
  if (quality_info_ != NULL) quality_info_->::p2message::p2ts_quality_report_msg::Clear();
  clear_has_quality_info();
}
inline const ::p2message::p2ts_quality_report_msg& ts2s_channel_status::quality_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return quality_info_ != NULL ? *quality_info_ : *default_instance().quality_info_;
#else
  return quality_info_ != NULL ? *quality_info_ : *default_instance_->quality_info_;
#endif
}
inline ::p2message::p2ts_quality_report_msg* ts2s_channel_status::mutable_quality_info() {
  set_has_quality_info();
  if (quality_info_ == NULL) quality_info_ = new ::p2message::p2ts_quality_report_msg;
  return quality_info_;
}
inline ::p2message::p2ts_quality_report_msg* ts2s_channel_status::release_quality_info() {
  clear_has_quality_info();
  ::p2message::p2ts_quality_report_msg* temp = quality_info_;
  quality_info_ = NULL;
  return temp;
}
inline void ts2s_channel_status::set_allocated_quality_info(::p2message::p2ts_quality_report_msg* quality_info) {
  delete quality_info_;
  quality_info_ = quality_info;
  if (quality_info) {
    set_has_quality_info();
  } else {
    clear_has_quality_info();
  }
}

// -------------------------------------------------------------------

// ts2p_challenge_msg

// required bytes challenge = 1;
inline bool ts2p_challenge_msg::has_challenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ts2p_challenge_msg::set_has_challenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ts2p_challenge_msg::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ts2p_challenge_msg::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& ts2p_challenge_msg::challenge() const {
  return *challenge_;
}
inline void ts2p_challenge_msg::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void ts2p_challenge_msg::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void ts2p_challenge_msg::set_challenge(const void* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ts2p_challenge_msg::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  return challenge_;
}
inline ::std::string* ts2p_challenge_msg::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ts2p_challenge_msg::set_allocated_challenge(::std::string* challenge) {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  if (challenge) {
    set_has_challenge();
    challenge_ = challenge;
  } else {
    clear_has_challenge();
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2ts_login_msg

// required uint32 session_id = 1;
inline bool p2ts_login_msg::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_login_msg::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_login_msg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_login_msg::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 p2ts_login_msg::session_id() const {
  return session_id_;
}
inline void p2ts_login_msg::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required bytes channel_id = 2;
inline bool p2ts_login_msg::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_login_msg::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_login_msg::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_login_msg::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& p2ts_login_msg::channel_id() const {
  return *channel_id_;
}
inline void p2ts_login_msg::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void p2ts_login_msg::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void p2ts_login_msg::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_login_msg::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* p2ts_login_msg::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_login_msg::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .p2message.peer_info peer_info = 3;
inline bool p2ts_login_msg::has_peer_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2ts_login_msg::set_has_peer_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2ts_login_msg::clear_has_peer_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2ts_login_msg::clear_peer_info() {
  if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
  clear_has_peer_info();
}
inline const ::p2message::peer_info& p2ts_login_msg::peer_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return peer_info_ != NULL ? *peer_info_ : *default_instance().peer_info_;
#else
  return peer_info_ != NULL ? *peer_info_ : *default_instance_->peer_info_;
#endif
}
inline ::p2message::peer_info* p2ts_login_msg::mutable_peer_info() {
  set_has_peer_info();
  if (peer_info_ == NULL) peer_info_ = new ::p2message::peer_info;
  return peer_info_;
}
inline ::p2message::peer_info* p2ts_login_msg::release_peer_info() {
  clear_has_peer_info();
  ::p2message::peer_info* temp = peer_info_;
  peer_info_ = NULL;
  return temp;
}
inline void p2ts_login_msg::set_allocated_peer_info(::p2message::peer_info* peer_info) {
  delete peer_info_;
  peer_info_ = peer_info;
  if (peer_info) {
    set_has_peer_info();
  } else {
    clear_has_peer_info();
  }
}

// required bytes public_key = 4;
inline bool p2ts_login_msg::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void p2ts_login_msg::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void p2ts_login_msg::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void p2ts_login_msg::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& p2ts_login_msg::public_key() const {
  return *public_key_;
}
inline void p2ts_login_msg::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void p2ts_login_msg::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void p2ts_login_msg::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_login_msg::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* p2ts_login_msg::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_login_msg::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes shared_key_signature = 5;
inline bool p2ts_login_msg::has_shared_key_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void p2ts_login_msg::set_has_shared_key_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void p2ts_login_msg::clear_has_shared_key_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void p2ts_login_msg::clear_shared_key_signature() {
  if (shared_key_signature_ != &::google::protobuf::internal::kEmptyString) {
    shared_key_signature_->clear();
  }
  clear_has_shared_key_signature();
}
inline const ::std::string& p2ts_login_msg::shared_key_signature() const {
  return *shared_key_signature_;
}
inline void p2ts_login_msg::set_shared_key_signature(const ::std::string& value) {
  set_has_shared_key_signature();
  if (shared_key_signature_ == &::google::protobuf::internal::kEmptyString) {
    shared_key_signature_ = new ::std::string;
  }
  shared_key_signature_->assign(value);
}
inline void p2ts_login_msg::set_shared_key_signature(const char* value) {
  set_has_shared_key_signature();
  if (shared_key_signature_ == &::google::protobuf::internal::kEmptyString) {
    shared_key_signature_ = new ::std::string;
  }
  shared_key_signature_->assign(value);
}
inline void p2ts_login_msg::set_shared_key_signature(const void* value, size_t size) {
  set_has_shared_key_signature();
  if (shared_key_signature_ == &::google::protobuf::internal::kEmptyString) {
    shared_key_signature_ = new ::std::string;
  }
  shared_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_login_msg::mutable_shared_key_signature() {
  set_has_shared_key_signature();
  if (shared_key_signature_ == &::google::protobuf::internal::kEmptyString) {
    shared_key_signature_ = new ::std::string;
  }
  return shared_key_signature_;
}
inline ::std::string* p2ts_login_msg::release_shared_key_signature() {
  clear_has_shared_key_signature();
  if (shared_key_signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shared_key_signature_;
    shared_key_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_login_msg::set_allocated_shared_key_signature(::std::string* shared_key_signature) {
  if (shared_key_signature_ != &::google::protobuf::internal::kEmptyString) {
    delete shared_key_signature_;
  }
  if (shared_key_signature) {
    set_has_shared_key_signature();
    shared_key_signature_ = shared_key_signature;
  } else {
    clear_has_shared_key_signature();
    shared_key_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes certificate = 6;
inline bool p2ts_login_msg::has_certificate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void p2ts_login_msg::set_has_certificate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void p2ts_login_msg::clear_has_certificate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void p2ts_login_msg::clear_certificate() {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    certificate_->clear();
  }
  clear_has_certificate();
}
inline const ::std::string& p2ts_login_msg::certificate() const {
  return *certificate_;
}
inline void p2ts_login_msg::set_certificate(const ::std::string& value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void p2ts_login_msg::set_certificate(const char* value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void p2ts_login_msg::set_certificate(const void* value, size_t size) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_login_msg::mutable_certificate() {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  return certificate_;
}
inline ::std::string* p2ts_login_msg::release_certificate() {
  clear_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_;
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_login_msg::set_allocated_certificate(::std::string* certificate) {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete certificate_;
  }
  if (certificate) {
    set_has_certificate();
    certificate_ = certificate;
  } else {
    clear_has_certificate();
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ts2p_login_reply_msg

// repeated .p2message.peer_info peer_info_list = 1;
inline int ts2p_login_reply_msg::peer_info_list_size() const {
  return peer_info_list_.size();
}
inline void ts2p_login_reply_msg::clear_peer_info_list() {
  peer_info_list_.Clear();
}
inline const ::p2message::peer_info& ts2p_login_reply_msg::peer_info_list(int index) const {
  return peer_info_list_.Get(index);
}
inline ::p2message::peer_info* ts2p_login_reply_msg::mutable_peer_info_list(int index) {
  return peer_info_list_.Mutable(index);
}
inline ::p2message::peer_info* ts2p_login_reply_msg::add_peer_info_list() {
  return peer_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
ts2p_login_reply_msg::peer_info_list() const {
  return peer_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
ts2p_login_reply_msg::mutable_peer_info_list() {
  return &peer_info_list_;
}

// required uint32 error_code = 2;
inline bool ts2p_login_reply_msg::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ts2p_login_reply_msg::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ts2p_login_reply_msg::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ts2p_login_reply_msg::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 ts2p_login_reply_msg::error_code() const {
  return error_code_;
}
inline void ts2p_login_reply_msg::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// required uint32 session_id = 3;
inline bool ts2p_login_reply_msg::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ts2p_login_reply_msg::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ts2p_login_reply_msg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ts2p_login_reply_msg::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ts2p_login_reply_msg::session_id() const {
  return session_id_;
}
inline void ts2p_login_reply_msg::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required uint32 external_ip = 4;
inline bool ts2p_login_reply_msg::has_external_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ts2p_login_reply_msg::set_has_external_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ts2p_login_reply_msg::clear_has_external_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ts2p_login_reply_msg::clear_external_ip() {
  external_ip_ = 0u;
  clear_has_external_ip();
}
inline ::google::protobuf::uint32 ts2p_login_reply_msg::external_ip() const {
  return external_ip_;
}
inline void ts2p_login_reply_msg::set_external_ip(::google::protobuf::uint32 value) {
  set_has_external_ip();
  external_ip_ = value;
}

// required uint32 external_port = 5;
inline bool ts2p_login_reply_msg::has_external_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ts2p_login_reply_msg::set_has_external_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ts2p_login_reply_msg::clear_has_external_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ts2p_login_reply_msg::clear_external_port() {
  external_port_ = 0u;
  clear_has_external_port();
}
inline ::google::protobuf::uint32 ts2p_login_reply_msg::external_port() const {
  return external_port_;
}
inline void ts2p_login_reply_msg::set_external_port(::google::protobuf::uint32 value) {
  set_has_external_port();
  external_port_ = value;
}

// required uint32 online_peer_cnt = 6;
inline bool ts2p_login_reply_msg::has_online_peer_cnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ts2p_login_reply_msg::set_has_online_peer_cnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ts2p_login_reply_msg::clear_has_online_peer_cnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ts2p_login_reply_msg::clear_online_peer_cnt() {
  online_peer_cnt_ = 0u;
  clear_has_online_peer_cnt();
}
inline ::google::protobuf::uint32 ts2p_login_reply_msg::online_peer_cnt() const {
  return online_peer_cnt_;
}
inline void ts2p_login_reply_msg::set_online_peer_cnt(::google::protobuf::uint32 value) {
  set_has_online_peer_cnt();
  online_peer_cnt_ = value;
}

// required uint64 join_time = 7;
inline bool ts2p_login_reply_msg::has_join_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ts2p_login_reply_msg::set_has_join_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ts2p_login_reply_msg::clear_has_join_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ts2p_login_reply_msg::clear_join_time() {
  join_time_ = GOOGLE_ULONGLONG(0);
  clear_has_join_time();
}
inline ::google::protobuf::uint64 ts2p_login_reply_msg::join_time() const {
  return join_time_;
}
inline void ts2p_login_reply_msg::set_join_time(::google::protobuf::uint64 value) {
  set_has_join_time();
  join_time_ = value;
}

// required bytes channel_id = 8;
inline bool ts2p_login_reply_msg::has_channel_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ts2p_login_reply_msg::set_has_channel_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ts2p_login_reply_msg::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ts2p_login_reply_msg::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& ts2p_login_reply_msg::channel_id() const {
  return *channel_id_;
}
inline void ts2p_login_reply_msg::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void ts2p_login_reply_msg::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void ts2p_login_reply_msg::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ts2p_login_reply_msg::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* ts2p_login_reply_msg::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ts2p_login_reply_msg::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .p2message.live_channel_info live_channel_info = 9;
inline bool ts2p_login_reply_msg::has_live_channel_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ts2p_login_reply_msg::set_has_live_channel_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ts2p_login_reply_msg::clear_has_live_channel_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ts2p_login_reply_msg::clear_live_channel_info() {
  if (live_channel_info_ != NULL) live_channel_info_->::p2message::live_channel_info::Clear();
  clear_has_live_channel_info();
}
inline const ::p2message::live_channel_info& ts2p_login_reply_msg::live_channel_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return live_channel_info_ != NULL ? *live_channel_info_ : *default_instance().live_channel_info_;
#else
  return live_channel_info_ != NULL ? *live_channel_info_ : *default_instance_->live_channel_info_;
#endif
}
inline ::p2message::live_channel_info* ts2p_login_reply_msg::mutable_live_channel_info() {
  set_has_live_channel_info();
  if (live_channel_info_ == NULL) live_channel_info_ = new ::p2message::live_channel_info;
  return live_channel_info_;
}
inline ::p2message::live_channel_info* ts2p_login_reply_msg::release_live_channel_info() {
  clear_has_live_channel_info();
  ::p2message::live_channel_info* temp = live_channel_info_;
  live_channel_info_ = NULL;
  return temp;
}
inline void ts2p_login_reply_msg::set_allocated_live_channel_info(::p2message::live_channel_info* live_channel_info) {
  delete live_channel_info_;
  live_channel_info_ = live_channel_info;
  if (live_channel_info) {
    set_has_live_channel_info();
  } else {
    clear_has_live_channel_info();
  }
}

// optional .p2message.vod_channel_info vod_channel_info = 10;
inline bool ts2p_login_reply_msg::has_vod_channel_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ts2p_login_reply_msg::set_has_vod_channel_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ts2p_login_reply_msg::clear_has_vod_channel_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ts2p_login_reply_msg::clear_vod_channel_info() {
  if (vod_channel_info_ != NULL) vod_channel_info_->::p2message::vod_channel_info::Clear();
  clear_has_vod_channel_info();
}
inline const ::p2message::vod_channel_info& ts2p_login_reply_msg::vod_channel_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vod_channel_info_ != NULL ? *vod_channel_info_ : *default_instance().vod_channel_info_;
#else
  return vod_channel_info_ != NULL ? *vod_channel_info_ : *default_instance_->vod_channel_info_;
#endif
}
inline ::p2message::vod_channel_info* ts2p_login_reply_msg::mutable_vod_channel_info() {
  set_has_vod_channel_info();
  if (vod_channel_info_ == NULL) vod_channel_info_ = new ::p2message::vod_channel_info;
  return vod_channel_info_;
}
inline ::p2message::vod_channel_info* ts2p_login_reply_msg::release_vod_channel_info() {
  clear_has_vod_channel_info();
  ::p2message::vod_channel_info* temp = vod_channel_info_;
  vod_channel_info_ = NULL;
  return temp;
}
inline void ts2p_login_reply_msg::set_allocated_vod_channel_info(::p2message::vod_channel_info* vod_channel_info) {
  delete vod_channel_info_;
  vod_channel_info_ = vod_channel_info;
  if (vod_channel_info) {
    set_has_vod_channel_info();
  } else {
    clear_has_vod_channel_info();
  }
}

// optional bytes cache_tracker_addr = 11;
inline bool ts2p_login_reply_msg::has_cache_tracker_addr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ts2p_login_reply_msg::set_has_cache_tracker_addr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ts2p_login_reply_msg::clear_has_cache_tracker_addr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ts2p_login_reply_msg::clear_cache_tracker_addr() {
  if (cache_tracker_addr_ != &::google::protobuf::internal::kEmptyString) {
    cache_tracker_addr_->clear();
  }
  clear_has_cache_tracker_addr();
}
inline const ::std::string& ts2p_login_reply_msg::cache_tracker_addr() const {
  return *cache_tracker_addr_;
}
inline void ts2p_login_reply_msg::set_cache_tracker_addr(const ::std::string& value) {
  set_has_cache_tracker_addr();
  if (cache_tracker_addr_ == &::google::protobuf::internal::kEmptyString) {
    cache_tracker_addr_ = new ::std::string;
  }
  cache_tracker_addr_->assign(value);
}
inline void ts2p_login_reply_msg::set_cache_tracker_addr(const char* value) {
  set_has_cache_tracker_addr();
  if (cache_tracker_addr_ == &::google::protobuf::internal::kEmptyString) {
    cache_tracker_addr_ = new ::std::string;
  }
  cache_tracker_addr_->assign(value);
}
inline void ts2p_login_reply_msg::set_cache_tracker_addr(const void* value, size_t size) {
  set_has_cache_tracker_addr();
  if (cache_tracker_addr_ == &::google::protobuf::internal::kEmptyString) {
    cache_tracker_addr_ = new ::std::string;
  }
  cache_tracker_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ts2p_login_reply_msg::mutable_cache_tracker_addr() {
  set_has_cache_tracker_addr();
  if (cache_tracker_addr_ == &::google::protobuf::internal::kEmptyString) {
    cache_tracker_addr_ = new ::std::string;
  }
  return cache_tracker_addr_;
}
inline ::std::string* ts2p_login_reply_msg::release_cache_tracker_addr() {
  clear_has_cache_tracker_addr();
  if (cache_tracker_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cache_tracker_addr_;
    cache_tracker_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ts2p_login_reply_msg::set_allocated_cache_tracker_addr(::std::string* cache_tracker_addr) {
  if (cache_tracker_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete cache_tracker_addr_;
  }
  if (cache_tracker_addr) {
    set_has_cache_tracker_addr();
    cache_tracker_addr_ = cache_tracker_addr;
  } else {
    clear_has_cache_tracker_addr();
    cache_tracker_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated fixed32 iframe_seqno = 12;
inline int ts2p_login_reply_msg::iframe_seqno_size() const {
  return iframe_seqno_.size();
}
inline void ts2p_login_reply_msg::clear_iframe_seqno() {
  iframe_seqno_.Clear();
}
inline ::google::protobuf::uint32 ts2p_login_reply_msg::iframe_seqno(int index) const {
  return iframe_seqno_.Get(index);
}
inline void ts2p_login_reply_msg::set_iframe_seqno(int index, ::google::protobuf::uint32 value) {
  iframe_seqno_.Set(index, value);
}
inline void ts2p_login_reply_msg::add_iframe_seqno(::google::protobuf::uint32 value) {
  iframe_seqno_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ts2p_login_reply_msg::iframe_seqno() const {
  return iframe_seqno_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ts2p_login_reply_msg::mutable_iframe_seqno() {
  return &iframe_seqno_;
}

// -------------------------------------------------------------------

// p2ts_peer_request_msg

// required uint32 session_id = 1;
inline bool p2ts_peer_request_msg::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_peer_request_msg::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_peer_request_msg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_peer_request_msg::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 p2ts_peer_request_msg::session_id() const {
  return session_id_;
}
inline void p2ts_peer_request_msg::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required .p2message.peer_info peer_info = 2;
inline bool p2ts_peer_request_msg::has_peer_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_peer_request_msg::set_has_peer_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_peer_request_msg::clear_has_peer_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_peer_request_msg::clear_peer_info() {
  if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
  clear_has_peer_info();
}
inline const ::p2message::peer_info& p2ts_peer_request_msg::peer_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return peer_info_ != NULL ? *peer_info_ : *default_instance().peer_info_;
#else
  return peer_info_ != NULL ? *peer_info_ : *default_instance_->peer_info_;
#endif
}
inline ::p2message::peer_info* p2ts_peer_request_msg::mutable_peer_info() {
  set_has_peer_info();
  if (peer_info_ == NULL) peer_info_ = new ::p2message::peer_info;
  return peer_info_;
}
inline ::p2message::peer_info* p2ts_peer_request_msg::release_peer_info() {
  clear_has_peer_info();
  ::p2message::peer_info* temp = peer_info_;
  peer_info_ = NULL;
  return temp;
}
inline void p2ts_peer_request_msg::set_allocated_peer_info(::p2message::peer_info* peer_info) {
  delete peer_info_;
  peer_info_ = peer_info;
  if (peer_info) {
    set_has_peer_info();
  } else {
    clear_has_peer_info();
  }
}

// optional bytes channel_uuid = 3;
inline bool p2ts_peer_request_msg::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2ts_peer_request_msg::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2ts_peer_request_msg::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2ts_peer_request_msg::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& p2ts_peer_request_msg::channel_uuid() const {
  return *channel_uuid_;
}
inline void p2ts_peer_request_msg::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void p2ts_peer_request_msg::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void p2ts_peer_request_msg::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_peer_request_msg::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* p2ts_peer_request_msg::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_peer_request_msg::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ts2p_peer_reply_msg

// required uint32 error_code = 1;
inline bool ts2p_peer_reply_msg::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ts2p_peer_reply_msg::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ts2p_peer_reply_msg::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ts2p_peer_reply_msg::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 ts2p_peer_reply_msg::error_code() const {
  return error_code_;
}
inline void ts2p_peer_reply_msg::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// required uint32 session_id = 2;
inline bool ts2p_peer_reply_msg::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ts2p_peer_reply_msg::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ts2p_peer_reply_msg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ts2p_peer_reply_msg::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ts2p_peer_reply_msg::session_id() const {
  return session_id_;
}
inline void ts2p_peer_reply_msg::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required bytes channel_id = 3;
inline bool ts2p_peer_reply_msg::has_channel_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ts2p_peer_reply_msg::set_has_channel_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ts2p_peer_reply_msg::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ts2p_peer_reply_msg::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& ts2p_peer_reply_msg::channel_id() const {
  return *channel_id_;
}
inline void ts2p_peer_reply_msg::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void ts2p_peer_reply_msg::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void ts2p_peer_reply_msg::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ts2p_peer_reply_msg::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* ts2p_peer_reply_msg::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ts2p_peer_reply_msg::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .p2message.peer_info peer_info_list = 4;
inline int ts2p_peer_reply_msg::peer_info_list_size() const {
  return peer_info_list_.size();
}
inline void ts2p_peer_reply_msg::clear_peer_info_list() {
  peer_info_list_.Clear();
}
inline const ::p2message::peer_info& ts2p_peer_reply_msg::peer_info_list(int index) const {
  return peer_info_list_.Get(index);
}
inline ::p2message::peer_info* ts2p_peer_reply_msg::mutable_peer_info_list(int index) {
  return peer_info_list_.Mutable(index);
}
inline ::p2message::peer_info* ts2p_peer_reply_msg::add_peer_info_list() {
  return peer_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
ts2p_peer_reply_msg::peer_info_list() const {
  return peer_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
ts2p_peer_reply_msg::mutable_peer_info_list() {
  return &peer_info_list_;
}

// optional uint32 cache_peer_cnt = 5;
inline bool ts2p_peer_reply_msg::has_cache_peer_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ts2p_peer_reply_msg::set_has_cache_peer_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ts2p_peer_reply_msg::clear_has_cache_peer_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ts2p_peer_reply_msg::clear_cache_peer_cnt() {
  cache_peer_cnt_ = 0u;
  clear_has_cache_peer_cnt();
}
inline ::google::protobuf::uint32 ts2p_peer_reply_msg::cache_peer_cnt() const {
  return cache_peer_cnt_;
}
inline void ts2p_peer_reply_msg::set_cache_peer_cnt(::google::protobuf::uint32 value) {
  set_has_cache_peer_cnt();
  cache_peer_cnt_ = value;
}

// -------------------------------------------------------------------

// p2ts_logout_msg

// required bytes peer_id = 1;
inline bool p2ts_logout_msg::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_logout_msg::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_logout_msg::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_logout_msg::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& p2ts_logout_msg::peer_id() const {
  return *peer_id_;
}
inline void p2ts_logout_msg::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void p2ts_logout_msg::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void p2ts_logout_msg::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_logout_msg::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* p2ts_logout_msg::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_logout_msg::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 peer_key = 2;
inline bool p2ts_logout_msg::has_peer_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_logout_msg::set_has_peer_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_logout_msg::clear_has_peer_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_logout_msg::clear_peer_key() {
  peer_key_ = 0u;
  clear_has_peer_key();
}
inline ::google::protobuf::uint32 p2ts_logout_msg::peer_key() const {
  return peer_key_;
}
inline void p2ts_logout_msg::set_peer_key(::google::protobuf::uint32 value) {
  set_has_peer_key();
  peer_key_ = value;
}

// optional bytes channel_uuid = 3;
inline bool p2ts_logout_msg::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2ts_logout_msg::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2ts_logout_msg::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2ts_logout_msg::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& p2ts_logout_msg::channel_uuid() const {
  return *channel_uuid_;
}
inline void p2ts_logout_msg::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void p2ts_logout_msg::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void p2ts_logout_msg::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_logout_msg::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* p2ts_logout_msg::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_logout_msg::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2ts_failure_report_msg

// required bytes peer_id = 1;
inline bool p2ts_failure_report_msg::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_failure_report_msg::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_failure_report_msg::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_failure_report_msg::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& p2ts_failure_report_msg::peer_id() const {
  return *peer_id_;
}
inline void p2ts_failure_report_msg::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void p2ts_failure_report_msg::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void p2ts_failure_report_msg::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_failure_report_msg::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* p2ts_failure_report_msg::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_failure_report_msg::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes channel_uuid = 2;
inline bool p2ts_failure_report_msg::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_failure_report_msg::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_failure_report_msg::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_failure_report_msg::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& p2ts_failure_report_msg::channel_uuid() const {
  return *channel_uuid_;
}
inline void p2ts_failure_report_msg::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void p2ts_failure_report_msg::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void p2ts_failure_report_msg::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_failure_report_msg::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* p2ts_failure_report_msg::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_failure_report_msg::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2ts_local_info_report_msg

// required .p2message.peer_info peer_info = 2;
inline bool p2ts_local_info_report_msg::has_peer_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_local_info_report_msg::set_has_peer_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_local_info_report_msg::clear_has_peer_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_local_info_report_msg::clear_peer_info() {
  if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
  clear_has_peer_info();
}
inline const ::p2message::peer_info& p2ts_local_info_report_msg::peer_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return peer_info_ != NULL ? *peer_info_ : *default_instance().peer_info_;
#else
  return peer_info_ != NULL ? *peer_info_ : *default_instance_->peer_info_;
#endif
}
inline ::p2message::peer_info* p2ts_local_info_report_msg::mutable_peer_info() {
  set_has_peer_info();
  if (peer_info_ == NULL) peer_info_ = new ::p2message::peer_info;
  return peer_info_;
}
inline ::p2message::peer_info* p2ts_local_info_report_msg::release_peer_info() {
  clear_has_peer_info();
  ::p2message::peer_info* temp = peer_info_;
  peer_info_ = NULL;
  return temp;
}
inline void p2ts_local_info_report_msg::set_allocated_peer_info(::p2message::peer_info* peer_info) {
  delete peer_info_;
  peer_info_ = peer_info;
  if (peer_info) {
    set_has_peer_info();
  } else {
    clear_has_peer_info();
  }
}

// -------------------------------------------------------------------

// ts2p_kickout_msg

// required uint32 error_code = 1;
inline bool ts2p_kickout_msg::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ts2p_kickout_msg::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ts2p_kickout_msg::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ts2p_kickout_msg::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 ts2p_kickout_msg::error_code() const {
  return error_code_;
}
inline void ts2p_kickout_msg::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional bytes reasion = 2;
inline bool ts2p_kickout_msg::has_reasion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ts2p_kickout_msg::set_has_reasion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ts2p_kickout_msg::clear_has_reasion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ts2p_kickout_msg::clear_reasion() {
  if (reasion_ != &::google::protobuf::internal::kEmptyString) {
    reasion_->clear();
  }
  clear_has_reasion();
}
inline const ::std::string& ts2p_kickout_msg::reasion() const {
  return *reasion_;
}
inline void ts2p_kickout_msg::set_reasion(const ::std::string& value) {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  reasion_->assign(value);
}
inline void ts2p_kickout_msg::set_reasion(const char* value) {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  reasion_->assign(value);
}
inline void ts2p_kickout_msg::set_reasion(const void* value, size_t size) {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  reasion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ts2p_kickout_msg::mutable_reasion() {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  return reasion_;
}
inline ::std::string* ts2p_kickout_msg::release_reasion() {
  clear_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reasion_;
    reasion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ts2p_kickout_msg::set_allocated_reasion(::std::string* reasion) {
  if (reasion_ != &::google::protobuf::internal::kEmptyString) {
    delete reasion_;
  }
  if (reasion) {
    set_has_reasion();
    reasion_ = reasion;
  } else {
    clear_has_reasion();
    reasion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2ts_kickout_msg

// required uint32 error_code = 1;
inline bool p2ts_kickout_msg::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_kickout_msg::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_kickout_msg::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_kickout_msg::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 p2ts_kickout_msg::error_code() const {
  return error_code_;
}
inline void p2ts_kickout_msg::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional bytes reasion = 2;
inline bool p2ts_kickout_msg::has_reasion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_kickout_msg::set_has_reasion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_kickout_msg::clear_has_reasion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_kickout_msg::clear_reasion() {
  if (reasion_ != &::google::protobuf::internal::kEmptyString) {
    reasion_->clear();
  }
  clear_has_reasion();
}
inline const ::std::string& p2ts_kickout_msg::reasion() const {
  return *reasion_;
}
inline void p2ts_kickout_msg::set_reasion(const ::std::string& value) {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  reasion_->assign(value);
}
inline void p2ts_kickout_msg::set_reasion(const char* value) {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  reasion_->assign(value);
}
inline void p2ts_kickout_msg::set_reasion(const void* value, size_t size) {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  reasion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_kickout_msg::mutable_reasion() {
  set_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    reasion_ = new ::std::string;
  }
  return reasion_;
}
inline ::std::string* p2ts_kickout_msg::release_reasion() {
  clear_has_reasion();
  if (reasion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reasion_;
    reasion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_kickout_msg::set_allocated_reasion(::std::string* reasion) {
  if (reasion_ != &::google::protobuf::internal::kEmptyString) {
    delete reasion_;
  }
  if (reasion) {
    set_has_reasion();
    reasion_ = reasion;
  } else {
    clear_has_reasion();
    reasion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ts2p_room_info_msg

// required uint32 online_peer_cnt = 1;
inline bool ts2p_room_info_msg::has_online_peer_cnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ts2p_room_info_msg::set_has_online_peer_cnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ts2p_room_info_msg::clear_has_online_peer_cnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ts2p_room_info_msg::clear_online_peer_cnt() {
  online_peer_cnt_ = 0u;
  clear_has_online_peer_cnt();
}
inline ::google::protobuf::uint32 ts2p_room_info_msg::online_peer_cnt() const {
  return online_peer_cnt_;
}
inline void ts2p_room_info_msg::set_online_peer_cnt(::google::protobuf::uint32 value) {
  set_has_online_peer_cnt();
  online_peer_cnt_ = value;
}

// repeated bytes offline_peer_list = 2;
inline int ts2p_room_info_msg::offline_peer_list_size() const {
  return offline_peer_list_.size();
}
inline void ts2p_room_info_msg::clear_offline_peer_list() {
  offline_peer_list_.Clear();
}
inline const ::std::string& ts2p_room_info_msg::offline_peer_list(int index) const {
  return offline_peer_list_.Get(index);
}
inline ::std::string* ts2p_room_info_msg::mutable_offline_peer_list(int index) {
  return offline_peer_list_.Mutable(index);
}
inline void ts2p_room_info_msg::set_offline_peer_list(int index, const ::std::string& value) {
  offline_peer_list_.Mutable(index)->assign(value);
}
inline void ts2p_room_info_msg::set_offline_peer_list(int index, const char* value) {
  offline_peer_list_.Mutable(index)->assign(value);
}
inline void ts2p_room_info_msg::set_offline_peer_list(int index, const void* value, size_t size) {
  offline_peer_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ts2p_room_info_msg::add_offline_peer_list() {
  return offline_peer_list_.Add();
}
inline void ts2p_room_info_msg::add_offline_peer_list(const ::std::string& value) {
  offline_peer_list_.Add()->assign(value);
}
inline void ts2p_room_info_msg::add_offline_peer_list(const char* value) {
  offline_peer_list_.Add()->assign(value);
}
inline void ts2p_room_info_msg::add_offline_peer_list(const void* value, size_t size) {
  offline_peer_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ts2p_room_info_msg::offline_peer_list() const {
  return offline_peer_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ts2p_room_info_msg::mutable_offline_peer_list() {
  return &offline_peer_list_;
}

// repeated .p2message.peer_info new_login_peer_list = 3;
inline int ts2p_room_info_msg::new_login_peer_list_size() const {
  return new_login_peer_list_.size();
}
inline void ts2p_room_info_msg::clear_new_login_peer_list() {
  new_login_peer_list_.Clear();
}
inline const ::p2message::peer_info& ts2p_room_info_msg::new_login_peer_list(int index) const {
  return new_login_peer_list_.Get(index);
}
inline ::p2message::peer_info* ts2p_room_info_msg::mutable_new_login_peer_list(int index) {
  return new_login_peer_list_.Mutable(index);
}
inline ::p2message::peer_info* ts2p_room_info_msg::add_new_login_peer_list() {
  return new_login_peer_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
ts2p_room_info_msg::new_login_peer_list() const {
  return new_login_peer_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
ts2p_room_info_msg::mutable_new_login_peer_list() {
  return &new_login_peer_list_;
}

// repeated .p2message.peer_info online_peer_list = 4;
inline int ts2p_room_info_msg::online_peer_list_size() const {
  return online_peer_list_.size();
}
inline void ts2p_room_info_msg::clear_online_peer_list() {
  online_peer_list_.Clear();
}
inline const ::p2message::peer_info& ts2p_room_info_msg::online_peer_list(int index) const {
  return online_peer_list_.Get(index);
}
inline ::p2message::peer_info* ts2p_room_info_msg::mutable_online_peer_list(int index) {
  return online_peer_list_.Mutable(index);
}
inline ::p2message::peer_info* ts2p_room_info_msg::add_online_peer_list() {
  return online_peer_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
ts2p_room_info_msg::online_peer_list() const {
  return online_peer_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
ts2p_room_info_msg::mutable_online_peer_list() {
  return &online_peer_list_;
}

// -------------------------------------------------------------------

// p2ts_ban_msg

// required bool is_admin = 1;
inline bool p2ts_ban_msg::has_is_admin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_ban_msg::set_has_is_admin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_ban_msg::clear_has_is_admin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_ban_msg::clear_is_admin() {
  is_admin_ = false;
  clear_has_is_admin();
}
inline bool p2ts_ban_msg::is_admin() const {
  return is_admin_;
}
inline void p2ts_ban_msg::set_is_admin(bool value) {
  set_has_is_admin();
  is_admin_ = value;
}

// required bool is_ban = 2;
inline bool p2ts_ban_msg::has_is_ban() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_ban_msg::set_has_is_ban() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_ban_msg::clear_has_is_ban() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_ban_msg::clear_is_ban() {
  is_ban_ = false;
  clear_has_is_ban();
}
inline bool p2ts_ban_msg::is_ban() const {
  return is_ban_;
}
inline void p2ts_ban_msg::set_is_ban(bool value) {
  set_has_is_ban();
  is_ban_ = value;
}

// required bool is_txt = 3;
inline bool p2ts_ban_msg::has_is_txt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2ts_ban_msg::set_has_is_txt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2ts_ban_msg::clear_has_is_txt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2ts_ban_msg::clear_is_txt() {
  is_txt_ = false;
  clear_has_is_txt();
}
inline bool p2ts_ban_msg::is_txt() const {
  return is_txt_;
}
inline void p2ts_ban_msg::set_is_txt(bool value) {
  set_has_is_txt();
  is_txt_ = value;
}

// required bytes dst_peer_id = 4;
inline bool p2ts_ban_msg::has_dst_peer_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void p2ts_ban_msg::set_has_dst_peer_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void p2ts_ban_msg::clear_has_dst_peer_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void p2ts_ban_msg::clear_dst_peer_id() {
  if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_->clear();
  }
  clear_has_dst_peer_id();
}
inline const ::std::string& p2ts_ban_msg::dst_peer_id() const {
  return *dst_peer_id_;
}
inline void p2ts_ban_msg::set_dst_peer_id(const ::std::string& value) {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  dst_peer_id_->assign(value);
}
inline void p2ts_ban_msg::set_dst_peer_id(const char* value) {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  dst_peer_id_->assign(value);
}
inline void p2ts_ban_msg::set_dst_peer_id(const void* value, size_t size) {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  dst_peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_ban_msg::mutable_dst_peer_id() {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  return dst_peer_id_;
}
inline ::std::string* p2ts_ban_msg::release_dst_peer_id() {
  clear_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dst_peer_id_;
    dst_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_ban_msg::set_allocated_dst_peer_id(::std::string* dst_peer_id) {
  if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete dst_peer_id_;
  }
  if (dst_peer_id) {
    set_has_dst_peer_id();
    dst_peer_id_ = dst_peer_id;
  } else {
    clear_has_dst_peer_id();
    dst_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes src_peer_id = 5;
inline bool p2ts_ban_msg::has_src_peer_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void p2ts_ban_msg::set_has_src_peer_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void p2ts_ban_msg::clear_has_src_peer_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void p2ts_ban_msg::clear_src_peer_id() {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    src_peer_id_->clear();
  }
  clear_has_src_peer_id();
}
inline const ::std::string& p2ts_ban_msg::src_peer_id() const {
  return *src_peer_id_;
}
inline void p2ts_ban_msg::set_src_peer_id(const ::std::string& value) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(value);
}
inline void p2ts_ban_msg::set_src_peer_id(const char* value) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(value);
}
inline void p2ts_ban_msg::set_src_peer_id(const void* value, size_t size) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_ban_msg::mutable_src_peer_id() {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  return src_peer_id_;
}
inline ::std::string* p2ts_ban_msg::release_src_peer_id() {
  clear_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_peer_id_;
    src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2ts_ban_msg::set_allocated_src_peer_id(::std::string* src_peer_id) {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete src_peer_id_;
  }
  if (src_peer_id) {
    set_has_src_peer_id();
    src_peer_id_ = src_peer_id;
  } else {
    clear_has_src_peer_id();
    src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2ts_quality_report_msg

// required uint64 id = 1;
inline bool p2ts_quality_report_msg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2ts_quality_report_msg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2ts_quality_report_msg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2ts_quality_report_msg::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 p2ts_quality_report_msg::id() const {
  return id_;
}
inline void p2ts_quality_report_msg::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 ip = 2;
inline bool p2ts_quality_report_msg::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2ts_quality_report_msg::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2ts_quality_report_msg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2ts_quality_report_msg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 p2ts_quality_report_msg::ip() const {
  return ip_;
}
inline void p2ts_quality_report_msg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required float playing_quality = 3;
inline bool p2ts_quality_report_msg::has_playing_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2ts_quality_report_msg::set_has_playing_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2ts_quality_report_msg::clear_has_playing_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2ts_quality_report_msg::clear_playing_quality() {
  playing_quality_ = 0;
  clear_has_playing_quality();
}
inline float p2ts_quality_report_msg::playing_quality() const {
  return playing_quality_;
}
inline void p2ts_quality_report_msg::set_playing_quality(float value) {
  set_has_playing_quality();
  playing_quality_ = value;
}

// required float uplink_lostrate = 4;
inline bool p2ts_quality_report_msg::has_uplink_lostrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void p2ts_quality_report_msg::set_has_uplink_lostrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void p2ts_quality_report_msg::clear_has_uplink_lostrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void p2ts_quality_report_msg::clear_uplink_lostrate() {
  uplink_lostrate_ = 0;
  clear_has_uplink_lostrate();
}
inline float p2ts_quality_report_msg::uplink_lostrate() const {
  return uplink_lostrate_;
}
inline void p2ts_quality_report_msg::set_uplink_lostrate(float value) {
  set_has_uplink_lostrate();
  uplink_lostrate_ = value;
}

// required float downlink_lostrate = 5;
inline bool p2ts_quality_report_msg::has_downlink_lostrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void p2ts_quality_report_msg::set_has_downlink_lostrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void p2ts_quality_report_msg::clear_has_downlink_lostrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void p2ts_quality_report_msg::clear_downlink_lostrate() {
  downlink_lostrate_ = 0;
  clear_has_downlink_lostrate();
}
inline float p2ts_quality_report_msg::downlink_lostrate() const {
  return downlink_lostrate_;
}
inline void p2ts_quality_report_msg::set_downlink_lostrate(float value) {
  set_has_downlink_lostrate();
  downlink_lostrate_ = value;
}

// required float push_rate = 6;
inline bool p2ts_quality_report_msg::has_push_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void p2ts_quality_report_msg::set_has_push_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void p2ts_quality_report_msg::clear_has_push_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void p2ts_quality_report_msg::clear_push_rate() {
  push_rate_ = 0;
  clear_has_push_rate();
}
inline float p2ts_quality_report_msg::push_rate() const {
  return push_rate_;
}
inline void p2ts_quality_report_msg::set_push_rate(float value) {
  set_has_push_rate();
  push_rate_ = value;
}

// required float duplicate_rate = 7;
inline bool p2ts_quality_report_msg::has_duplicate_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void p2ts_quality_report_msg::set_has_duplicate_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void p2ts_quality_report_msg::clear_has_duplicate_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void p2ts_quality_report_msg::clear_duplicate_rate() {
  duplicate_rate_ = 0;
  clear_has_duplicate_rate();
}
inline float p2ts_quality_report_msg::duplicate_rate() const {
  return duplicate_rate_;
}
inline void p2ts_quality_report_msg::set_duplicate_rate(float value) {
  set_has_duplicate_rate();
  duplicate_rate_ = value;
}

// required float share_rate = 8;
inline bool p2ts_quality_report_msg::has_share_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void p2ts_quality_report_msg::set_has_share_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void p2ts_quality_report_msg::clear_has_share_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void p2ts_quality_report_msg::clear_share_rate() {
  share_rate_ = 0;
  clear_has_share_rate();
}
inline float p2ts_quality_report_msg::share_rate() const {
  return share_rate_;
}
inline void p2ts_quality_report_msg::set_share_rate(float value) {
  set_has_share_rate();
  share_rate_ = value;
}

// required float buffer_health = 9;
inline bool p2ts_quality_report_msg::has_buffer_health() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void p2ts_quality_report_msg::set_has_buffer_health() {
  _has_bits_[0] |= 0x00000100u;
}
inline void p2ts_quality_report_msg::clear_has_buffer_health() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void p2ts_quality_report_msg::clear_buffer_health() {
  buffer_health_ = 0;
  clear_has_buffer_health();
}
inline float p2ts_quality_report_msg::buffer_health() const {
  return buffer_health_;
}
inline void p2ts_quality_report_msg::set_buffer_health(float value) {
  set_has_buffer_health();
  buffer_health_ = value;
}

// optional int32 delay = 10;
inline bool p2ts_quality_report_msg::has_delay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void p2ts_quality_report_msg::set_has_delay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void p2ts_quality_report_msg::clear_has_delay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void p2ts_quality_report_msg::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 p2ts_quality_report_msg::delay() const {
  return delay_;
}
inline void p2ts_quality_report_msg::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
}

// optional int32 cpu = 11;
inline bool p2ts_quality_report_msg::has_cpu() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void p2ts_quality_report_msg::set_has_cpu() {
  _has_bits_[0] |= 0x00000400u;
}
inline void p2ts_quality_report_msg::clear_has_cpu() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void p2ts_quality_report_msg::clear_cpu() {
  cpu_ = 0;
  clear_has_cpu();
}
inline ::google::protobuf::int32 p2ts_quality_report_msg::cpu() const {
  return cpu_;
}
inline void p2ts_quality_report_msg::set_cpu(::google::protobuf::int32 value) {
  set_has_cpu();
  cpu_ = value;
}

// -------------------------------------------------------------------

// cached_channel_info

// required int32 healthy = 1;
inline bool cached_channel_info::has_healthy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cached_channel_info::set_has_healthy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cached_channel_info::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cached_channel_info::clear_healthy() {
  healthy_ = 0;
  clear_has_healthy();
}
inline ::google::protobuf::int32 cached_channel_info::healthy() const {
  return healthy_;
}
inline void cached_channel_info::set_healthy(::google::protobuf::int32 value) {
  set_has_healthy();
  healthy_ = value;
}

// required bytes channel_id = 2;
inline bool cached_channel_info::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cached_channel_info::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cached_channel_info::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cached_channel_info::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& cached_channel_info::channel_id() const {
  return *channel_id_;
}
inline void cached_channel_info::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void cached_channel_info::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void cached_channel_info::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cached_channel_info::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* cached_channel_info::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cached_channel_info::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2ts_cache_announce_msg

// repeated .p2message.cached_channel_info cached_channels = 1;
inline int p2ts_cache_announce_msg::cached_channels_size() const {
  return cached_channels_.size();
}
inline void p2ts_cache_announce_msg::clear_cached_channels() {
  cached_channels_.Clear();
}
inline const ::p2message::cached_channel_info& p2ts_cache_announce_msg::cached_channels(int index) const {
  return cached_channels_.Get(index);
}
inline ::p2message::cached_channel_info* p2ts_cache_announce_msg::mutable_cached_channels(int index) {
  return cached_channels_.Mutable(index);
}
inline ::p2message::cached_channel_info* p2ts_cache_announce_msg::add_cached_channels() {
  return cached_channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::cached_channel_info >&
p2ts_cache_announce_msg::cached_channels() const {
  return cached_channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::cached_channel_info >*
p2ts_cache_announce_msg::mutable_cached_channels() {
  return &cached_channels_;
}

// repeated bytes erased_channels = 2;
inline int p2ts_cache_announce_msg::erased_channels_size() const {
  return erased_channels_.size();
}
inline void p2ts_cache_announce_msg::clear_erased_channels() {
  erased_channels_.Clear();
}
inline const ::std::string& p2ts_cache_announce_msg::erased_channels(int index) const {
  return erased_channels_.Get(index);
}
inline ::std::string* p2ts_cache_announce_msg::mutable_erased_channels(int index) {
  return erased_channels_.Mutable(index);
}
inline void p2ts_cache_announce_msg::set_erased_channels(int index, const ::std::string& value) {
  erased_channels_.Mutable(index)->assign(value);
}
inline void p2ts_cache_announce_msg::set_erased_channels(int index, const char* value) {
  erased_channels_.Mutable(index)->assign(value);
}
inline void p2ts_cache_announce_msg::set_erased_channels(int index, const void* value, size_t size) {
  erased_channels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2ts_cache_announce_msg::add_erased_channels() {
  return erased_channels_.Add();
}
inline void p2ts_cache_announce_msg::add_erased_channels(const ::std::string& value) {
  erased_channels_.Add()->assign(value);
}
inline void p2ts_cache_announce_msg::add_erased_channels(const char* value) {
  erased_channels_.Add()->assign(value);
}
inline void p2ts_cache_announce_msg::add_erased_channels(const void* value, size_t size) {
  erased_channels_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
p2ts_cache_announce_msg::erased_channels() const {
  return erased_channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
p2ts_cache_announce_msg::mutable_erased_channels() {
  return &erased_channels_;
}

// required .p2message.peer_info peer_info = 3;
inline bool p2ts_cache_announce_msg::has_peer_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2ts_cache_announce_msg::set_has_peer_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2ts_cache_announce_msg::clear_has_peer_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2ts_cache_announce_msg::clear_peer_info() {
  if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
  clear_has_peer_info();
}
inline const ::p2message::peer_info& p2ts_cache_announce_msg::peer_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return peer_info_ != NULL ? *peer_info_ : *default_instance().peer_info_;
#else
  return peer_info_ != NULL ? *peer_info_ : *default_instance_->peer_info_;
#endif
}
inline ::p2message::peer_info* p2ts_cache_announce_msg::mutable_peer_info() {
  set_has_peer_info();
  if (peer_info_ == NULL) peer_info_ = new ::p2message::peer_info;
  return peer_info_;
}
inline ::p2message::peer_info* p2ts_cache_announce_msg::release_peer_info() {
  clear_has_peer_info();
  ::p2message::peer_info* temp = peer_info_;
  peer_info_ = NULL;
  return temp;
}
inline void p2ts_cache_announce_msg::set_allocated_peer_info(::p2message::peer_info* peer_info) {
  delete peer_info_;
  peer_info_ = peer_info;
  if (peer_info) {
    set_has_peer_info();
  } else {
    clear_has_peer_info();
  }
}

// -------------------------------------------------------------------

// s2p_recommend_seed_msg

// required uint32 ttl = 1 [default = 6];
inline bool s2p_recommend_seed_msg::has_ttl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s2p_recommend_seed_msg::set_has_ttl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s2p_recommend_seed_msg::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s2p_recommend_seed_msg::clear_ttl() {
  ttl_ = 6u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 s2p_recommend_seed_msg::ttl() const {
  return ttl_;
}
inline void s2p_recommend_seed_msg::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// -------------------------------------------------------------------

// s2p_piece_notify

// required .p2message.buffermap_info buffermap = 1;
inline bool s2p_piece_notify::has_buffermap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s2p_piece_notify::set_has_buffermap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s2p_piece_notify::clear_has_buffermap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s2p_piece_notify::clear_buffermap() {
  if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
  clear_has_buffermap();
}
inline const ::p2message::buffermap_info& s2p_piece_notify::buffermap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buffermap_ != NULL ? *buffermap_ : *default_instance().buffermap_;
#else
  return buffermap_ != NULL ? *buffermap_ : *default_instance_->buffermap_;
#endif
}
inline ::p2message::buffermap_info* s2p_piece_notify::mutable_buffermap() {
  set_has_buffermap();
  if (buffermap_ == NULL) buffermap_ = new ::p2message::buffermap_info;
  return buffermap_;
}
inline ::p2message::buffermap_info* s2p_piece_notify::release_buffermap() {
  clear_has_buffermap();
  ::p2message::buffermap_info* temp = buffermap_;
  buffermap_ = NULL;
  return temp;
}
inline void s2p_piece_notify::set_allocated_buffermap(::p2message::buffermap_info* buffermap) {
  delete buffermap_;
  buffermap_ = buffermap;
  if (buffermap) {
    set_has_buffermap();
  } else {
    clear_has_buffermap();
  }
}

// -------------------------------------------------------------------

// p2s_info_report_msg

// required uint32 upload_speed = 1;
inline bool p2s_info_report_msg::has_upload_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2s_info_report_msg::set_has_upload_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2s_info_report_msg::clear_has_upload_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2s_info_report_msg::clear_upload_speed() {
  upload_speed_ = 0u;
  clear_has_upload_speed();
}
inline ::google::protobuf::uint32 p2s_info_report_msg::upload_speed() const {
  return upload_speed_;
}
inline void p2s_info_report_msg::set_upload_speed(::google::protobuf::uint32 value) {
  set_has_upload_speed();
  upload_speed_ = value;
}

// required float lost_rate = 2;
inline bool p2s_info_report_msg::has_lost_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2s_info_report_msg::set_has_lost_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2s_info_report_msg::clear_has_lost_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2s_info_report_msg::clear_lost_rate() {
  lost_rate_ = 0;
  clear_has_lost_rate();
}
inline float p2s_info_report_msg::lost_rate() const {
  return lost_rate_;
}
inline void p2s_info_report_msg::set_lost_rate(float value) {
  set_has_lost_rate();
  lost_rate_ = value;
}

// -------------------------------------------------------------------

// p2p_handshake_msg

// required bytes playing_channel_id = 1;
inline bool p2p_handshake_msg::has_playing_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2p_handshake_msg::set_has_playing_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2p_handshake_msg::clear_has_playing_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2p_handshake_msg::clear_playing_channel_id() {
  if (playing_channel_id_ != &::google::protobuf::internal::kEmptyString) {
    playing_channel_id_->clear();
  }
  clear_has_playing_channel_id();
}
inline const ::std::string& p2p_handshake_msg::playing_channel_id() const {
  return *playing_channel_id_;
}
inline void p2p_handshake_msg::set_playing_channel_id(const ::std::string& value) {
  set_has_playing_channel_id();
  if (playing_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    playing_channel_id_ = new ::std::string;
  }
  playing_channel_id_->assign(value);
}
inline void p2p_handshake_msg::set_playing_channel_id(const char* value) {
  set_has_playing_channel_id();
  if (playing_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    playing_channel_id_ = new ::std::string;
  }
  playing_channel_id_->assign(value);
}
inline void p2p_handshake_msg::set_playing_channel_id(const void* value, size_t size) {
  set_has_playing_channel_id();
  if (playing_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    playing_channel_id_ = new ::std::string;
  }
  playing_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2p_handshake_msg::mutable_playing_channel_id() {
  set_has_playing_channel_id();
  if (playing_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    playing_channel_id_ = new ::std::string;
  }
  return playing_channel_id_;
}
inline ::std::string* p2p_handshake_msg::release_playing_channel_id() {
  clear_has_playing_channel_id();
  if (playing_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playing_channel_id_;
    playing_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2p_handshake_msg::set_allocated_playing_channel_id(::std::string* playing_channel_id) {
  if (playing_channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete playing_channel_id_;
  }
  if (playing_channel_id) {
    set_has_playing_channel_id();
    playing_channel_id_ = playing_channel_id;
  } else {
    clear_has_playing_channel_id();
    playing_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .p2message.peer_info peer_info = 2;
inline bool p2p_handshake_msg::has_peer_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2p_handshake_msg::set_has_peer_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2p_handshake_msg::clear_has_peer_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2p_handshake_msg::clear_peer_info() {
  if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
  clear_has_peer_info();
}
inline const ::p2message::peer_info& p2p_handshake_msg::peer_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return peer_info_ != NULL ? *peer_info_ : *default_instance().peer_info_;
#else
  return peer_info_ != NULL ? *peer_info_ : *default_instance_->peer_info_;
#endif
}
inline ::p2message::peer_info* p2p_handshake_msg::mutable_peer_info() {
  set_has_peer_info();
  if (peer_info_ == NULL) peer_info_ = new ::p2message::peer_info;
  return peer_info_;
}
inline ::p2message::peer_info* p2p_handshake_msg::release_peer_info() {
  clear_has_peer_info();
  ::p2message::peer_info* temp = peer_info_;
  peer_info_ = NULL;
  return temp;
}
inline void p2p_handshake_msg::set_allocated_peer_info(::p2message::peer_info* peer_info) {
  delete peer_info_;
  peer_info_ = peer_info;
  if (peer_info) {
    set_has_peer_info();
  } else {
    clear_has_peer_info();
  }
}

// optional .p2message.buffermap_info buffermap = 3;
inline bool p2p_handshake_msg::has_buffermap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void p2p_handshake_msg::set_has_buffermap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void p2p_handshake_msg::clear_has_buffermap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void p2p_handshake_msg::clear_buffermap() {
  if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
  clear_has_buffermap();
}
inline const ::p2message::buffermap_info& p2p_handshake_msg::buffermap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buffermap_ != NULL ? *buffermap_ : *default_instance().buffermap_;
#else
  return buffermap_ != NULL ? *buffermap_ : *default_instance_->buffermap_;
#endif
}
inline ::p2message::buffermap_info* p2p_handshake_msg::mutable_buffermap() {
  set_has_buffermap();
  if (buffermap_ == NULL) buffermap_ = new ::p2message::buffermap_info;
  return buffermap_;
}
inline ::p2message::buffermap_info* p2p_handshake_msg::release_buffermap() {
  clear_has_buffermap();
  ::p2message::buffermap_info* temp = buffermap_;
  buffermap_ = NULL;
  return temp;
}
inline void p2p_handshake_msg::set_allocated_buffermap(::p2message::buffermap_info* buffermap) {
  delete buffermap_;
  buffermap_ = buffermap;
  if (buffermap) {
    set_has_buffermap();
  } else {
    clear_has_buffermap();
  }
}

// optional bytes compressed_buffermap = 4;
inline bool p2p_handshake_msg::has_compressed_buffermap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void p2p_handshake_msg::set_has_compressed_buffermap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void p2p_handshake_msg::clear_has_compressed_buffermap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void p2p_handshake_msg::clear_compressed_buffermap() {
  if (compressed_buffermap_ != &::google::protobuf::internal::kEmptyString) {
    compressed_buffermap_->clear();
  }
  clear_has_compressed_buffermap();
}
inline const ::std::string& p2p_handshake_msg::compressed_buffermap() const {
  return *compressed_buffermap_;
}
inline void p2p_handshake_msg::set_compressed_buffermap(const ::std::string& value) {
  set_has_compressed_buffermap();
  if (compressed_buffermap_ == &::google::protobuf::internal::kEmptyString) {
    compressed_buffermap_ = new ::std::string;
  }
  compressed_buffermap_->assign(value);
}
inline void p2p_handshake_msg::set_compressed_buffermap(const char* value) {
  set_has_compressed_buffermap();
  if (compressed_buffermap_ == &::google::protobuf::internal::kEmptyString) {
    compressed_buffermap_ = new ::std::string;
  }
  compressed_buffermap_->assign(value);
}
inline void p2p_handshake_msg::set_compressed_buffermap(const void* value, size_t size) {
  set_has_compressed_buffermap();
  if (compressed_buffermap_ == &::google::protobuf::internal::kEmptyString) {
    compressed_buffermap_ = new ::std::string;
  }
  compressed_buffermap_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2p_handshake_msg::mutable_compressed_buffermap() {
  set_has_compressed_buffermap();
  if (compressed_buffermap_ == &::google::protobuf::internal::kEmptyString) {
    compressed_buffermap_ = new ::std::string;
  }
  return compressed_buffermap_;
}
inline ::std::string* p2p_handshake_msg::release_compressed_buffermap() {
  clear_has_compressed_buffermap();
  if (compressed_buffermap_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compressed_buffermap_;
    compressed_buffermap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2p_handshake_msg::set_allocated_compressed_buffermap(::std::string* compressed_buffermap) {
  if (compressed_buffermap_ != &::google::protobuf::internal::kEmptyString) {
    delete compressed_buffermap_;
  }
  if (compressed_buffermap) {
    set_has_compressed_buffermap();
    compressed_buffermap_ = compressed_buffermap;
  } else {
    clear_has_compressed_buffermap();
    compressed_buffermap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes chunkmap = 5;
inline bool p2p_handshake_msg::has_chunkmap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void p2p_handshake_msg::set_has_chunkmap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void p2p_handshake_msg::clear_has_chunkmap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void p2p_handshake_msg::clear_chunkmap() {
  if (chunkmap_ != &::google::protobuf::internal::kEmptyString) {
    chunkmap_->clear();
  }
  clear_has_chunkmap();
}
inline const ::std::string& p2p_handshake_msg::chunkmap() const {
  return *chunkmap_;
}
inline void p2p_handshake_msg::set_chunkmap(const ::std::string& value) {
  set_has_chunkmap();
  if (chunkmap_ == &::google::protobuf::internal::kEmptyString) {
    chunkmap_ = new ::std::string;
  }
  chunkmap_->assign(value);
}
inline void p2p_handshake_msg::set_chunkmap(const char* value) {
  set_has_chunkmap();
  if (chunkmap_ == &::google::protobuf::internal::kEmptyString) {
    chunkmap_ = new ::std::string;
  }
  chunkmap_->assign(value);
}
inline void p2p_handshake_msg::set_chunkmap(const void* value, size_t size) {
  set_has_chunkmap();
  if (chunkmap_ == &::google::protobuf::internal::kEmptyString) {
    chunkmap_ = new ::std::string;
  }
  chunkmap_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2p_handshake_msg::mutable_chunkmap() {
  set_has_chunkmap();
  if (chunkmap_ == &::google::protobuf::internal::kEmptyString) {
    chunkmap_ = new ::std::string;
  }
  return chunkmap_;
}
inline ::std::string* p2p_handshake_msg::release_chunkmap() {
  clear_has_chunkmap();
  if (chunkmap_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chunkmap_;
    chunkmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void p2p_handshake_msg::set_allocated_chunkmap(::std::string* chunkmap) {
  if (chunkmap_ != &::google::protobuf::internal::kEmptyString) {
    delete chunkmap_;
  }
  if (chunkmap) {
    set_has_chunkmap();
    chunkmap_ = chunkmap;
  } else {
    clear_has_chunkmap();
    chunkmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// p2p_buffermap_request_msg

// required fixed32 min_seqno = 1;
inline bool p2p_buffermap_request_msg::has_min_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2p_buffermap_request_msg::set_has_min_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2p_buffermap_request_msg::clear_has_min_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2p_buffermap_request_msg::clear_min_seqno() {
  min_seqno_ = 0u;
  clear_has_min_seqno();
}
inline ::google::protobuf::uint32 p2p_buffermap_request_msg::min_seqno() const {
  return min_seqno_;
}
inline void p2p_buffermap_request_msg::set_min_seqno(::google::protobuf::uint32 value) {
  set_has_min_seqno();
  min_seqno_ = value;
}

// required fixed32 max_seqno = 2;
inline bool p2p_buffermap_request_msg::has_max_seqno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2p_buffermap_request_msg::set_has_max_seqno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2p_buffermap_request_msg::clear_has_max_seqno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2p_buffermap_request_msg::clear_max_seqno() {
  max_seqno_ = 0u;
  clear_has_max_seqno();
}
inline ::google::protobuf::uint32 p2p_buffermap_request_msg::max_seqno() const {
  return max_seqno_;
}
inline void p2p_buffermap_request_msg::set_max_seqno(::google::protobuf::uint32 value) {
  set_has_max_seqno();
  max_seqno_ = value;
}

// -------------------------------------------------------------------

// p2p_neighbor_table_exchange

// repeated .p2message.peer_info same_channel_peer_info_list = 1;
inline int p2p_neighbor_table_exchange::same_channel_peer_info_list_size() const {
  return same_channel_peer_info_list_.size();
}
inline void p2p_neighbor_table_exchange::clear_same_channel_peer_info_list() {
  same_channel_peer_info_list_.Clear();
}
inline const ::p2message::peer_info& p2p_neighbor_table_exchange::same_channel_peer_info_list(int index) const {
  return same_channel_peer_info_list_.Get(index);
}
inline ::p2message::peer_info* p2p_neighbor_table_exchange::mutable_same_channel_peer_info_list(int index) {
  return same_channel_peer_info_list_.Mutable(index);
}
inline ::p2message::peer_info* p2p_neighbor_table_exchange::add_same_channel_peer_info_list() {
  return same_channel_peer_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
p2p_neighbor_table_exchange::same_channel_peer_info_list() const {
  return same_channel_peer_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
p2p_neighbor_table_exchange::mutable_same_channel_peer_info_list() {
  return &same_channel_peer_info_list_;
}

// repeated .p2message.peer_info cache_peer_info_list = 2;
inline int p2p_neighbor_table_exchange::cache_peer_info_list_size() const {
  return cache_peer_info_list_.size();
}
inline void p2p_neighbor_table_exchange::clear_cache_peer_info_list() {
  cache_peer_info_list_.Clear();
}
inline const ::p2message::peer_info& p2p_neighbor_table_exchange::cache_peer_info_list(int index) const {
  return cache_peer_info_list_.Get(index);
}
inline ::p2message::peer_info* p2p_neighbor_table_exchange::mutable_cache_peer_info_list(int index) {
  return cache_peer_info_list_.Mutable(index);
}
inline ::p2message::peer_info* p2p_neighbor_table_exchange::add_cache_peer_info_list() {
  return cache_peer_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >&
p2p_neighbor_table_exchange::cache_peer_info_list() const {
  return cache_peer_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::peer_info >*
p2p_neighbor_table_exchange::mutable_cache_peer_info_list() {
  return &cache_peer_info_list_;
}

// repeated bytes known_neighbor_list = 3;
inline int p2p_neighbor_table_exchange::known_neighbor_list_size() const {
  return known_neighbor_list_.size();
}
inline void p2p_neighbor_table_exchange::clear_known_neighbor_list() {
  known_neighbor_list_.Clear();
}
inline const ::std::string& p2p_neighbor_table_exchange::known_neighbor_list(int index) const {
  return known_neighbor_list_.Get(index);
}
inline ::std::string* p2p_neighbor_table_exchange::mutable_known_neighbor_list(int index) {
  return known_neighbor_list_.Mutable(index);
}
inline void p2p_neighbor_table_exchange::set_known_neighbor_list(int index, const ::std::string& value) {
  known_neighbor_list_.Mutable(index)->assign(value);
}
inline void p2p_neighbor_table_exchange::set_known_neighbor_list(int index, const char* value) {
  known_neighbor_list_.Mutable(index)->assign(value);
}
inline void p2p_neighbor_table_exchange::set_known_neighbor_list(int index, const void* value, size_t size) {
  known_neighbor_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* p2p_neighbor_table_exchange::add_known_neighbor_list() {
  return known_neighbor_list_.Add();
}
inline void p2p_neighbor_table_exchange::add_known_neighbor_list(const ::std::string& value) {
  known_neighbor_list_.Add()->assign(value);
}
inline void p2p_neighbor_table_exchange::add_known_neighbor_list(const char* value) {
  known_neighbor_list_.Add()->assign(value);
}
inline void p2p_neighbor_table_exchange::add_known_neighbor_list(const void* value, size_t size) {
  known_neighbor_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
p2p_neighbor_table_exchange::known_neighbor_list() const {
  return known_neighbor_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
p2p_neighbor_table_exchange::mutable_known_neighbor_list() {
  return &known_neighbor_list_;
}

// -------------------------------------------------------------------

// p2p_supervise_request_msg

// required .p2message.buffermap_info buffermap = 1;
inline bool p2p_supervise_request_msg::has_buffermap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void p2p_supervise_request_msg::set_has_buffermap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void p2p_supervise_request_msg::clear_has_buffermap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void p2p_supervise_request_msg::clear_buffermap() {
  if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
  clear_has_buffermap();
}
inline const ::p2message::buffermap_info& p2p_supervise_request_msg::buffermap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buffermap_ != NULL ? *buffermap_ : *default_instance().buffermap_;
#else
  return buffermap_ != NULL ? *buffermap_ : *default_instance_->buffermap_;
#endif
}
inline ::p2message::buffermap_info* p2p_supervise_request_msg::mutable_buffermap() {
  set_has_buffermap();
  if (buffermap_ == NULL) buffermap_ = new ::p2message::buffermap_info;
  return buffermap_;
}
inline ::p2message::buffermap_info* p2p_supervise_request_msg::release_buffermap() {
  clear_has_buffermap();
  ::p2message::buffermap_info* temp = buffermap_;
  buffermap_ = NULL;
  return temp;
}
inline void p2p_supervise_request_msg::set_allocated_buffermap(::p2message::buffermap_info* buffermap) {
  delete buffermap_;
  buffermap_ = buffermap;
  if (buffermap) {
    set_has_buffermap();
  } else {
    clear_has_buffermap();
  }
}

// required uint32 peer_key = 2;
inline bool p2p_supervise_request_msg::has_peer_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void p2p_supervise_request_msg::set_has_peer_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void p2p_supervise_request_msg::clear_has_peer_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void p2p_supervise_request_msg::clear_peer_key() {
  peer_key_ = 0u;
  clear_has_peer_key();
}
inline ::google::protobuf::uint32 p2p_supervise_request_msg::peer_key() const {
  return peer_key_;
}
inline void p2p_supervise_request_msg::set_peer_key(::google::protobuf::uint32 value) {
  set_has_peer_key();
  peer_key_ = value;
}

// -------------------------------------------------------------------

// relay_msg

// required int32 level = 1;
inline bool relay_msg::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void relay_msg::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void relay_msg::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void relay_msg::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 relay_msg::level() const {
  return level_;
}
inline void relay_msg::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 msg_id = 2;
inline bool relay_msg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void relay_msg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void relay_msg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void relay_msg::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 relay_msg::msg_id() const {
  return msg_id_;
}
inline void relay_msg::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// required bytes src_peer_id = 3;
inline bool relay_msg::has_src_peer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void relay_msg::set_has_src_peer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void relay_msg::clear_has_src_peer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void relay_msg::clear_src_peer_id() {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    src_peer_id_->clear();
  }
  clear_has_src_peer_id();
}
inline const ::std::string& relay_msg::src_peer_id() const {
  return *src_peer_id_;
}
inline void relay_msg::set_src_peer_id(const ::std::string& value) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(value);
}
inline void relay_msg::set_src_peer_id(const char* value) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(value);
}
inline void relay_msg::set_src_peer_id(const void* value, size_t size) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* relay_msg::mutable_src_peer_id() {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  return src_peer_id_;
}
inline ::std::string* relay_msg::release_src_peer_id() {
  clear_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_peer_id_;
    src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void relay_msg::set_allocated_src_peer_id(::std::string* src_peer_id) {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete src_peer_id_;
  }
  if (src_peer_id) {
    set_has_src_peer_id();
    src_peer_id_ = src_peer_id;
  } else {
    clear_has_src_peer_id();
    src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes dst_peer_id = 4;
inline bool relay_msg::has_dst_peer_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void relay_msg::set_has_dst_peer_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void relay_msg::clear_has_dst_peer_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void relay_msg::clear_dst_peer_id() {
  if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_->clear();
  }
  clear_has_dst_peer_id();
}
inline const ::std::string& relay_msg::dst_peer_id() const {
  return *dst_peer_id_;
}
inline void relay_msg::set_dst_peer_id(const ::std::string& value) {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  dst_peer_id_->assign(value);
}
inline void relay_msg::set_dst_peer_id(const char* value) {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  dst_peer_id_->assign(value);
}
inline void relay_msg::set_dst_peer_id(const void* value, size_t size) {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  dst_peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* relay_msg::mutable_dst_peer_id() {
  set_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    dst_peer_id_ = new ::std::string;
  }
  return dst_peer_id_;
}
inline ::std::string* relay_msg::release_dst_peer_id() {
  clear_has_dst_peer_id();
  if (dst_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dst_peer_id_;
    dst_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void relay_msg::set_allocated_dst_peer_id(::std::string* dst_peer_id) {
  if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete dst_peer_id_;
  }
  if (dst_peer_id) {
    set_has_dst_peer_id();
    dst_peer_id_ = dst_peer_id;
  } else {
    clear_has_dst_peer_id();
    dst_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ttl = 5 [default = 4];
inline bool relay_msg::has_ttl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void relay_msg::set_has_ttl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void relay_msg::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void relay_msg::clear_ttl() {
  ttl_ = 4u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 relay_msg::ttl() const {
  return ttl_;
}
inline void relay_msg::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// required bytes msg_data = 6;
inline bool relay_msg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void relay_msg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void relay_msg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void relay_msg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& relay_msg::msg_data() const {
  return *msg_data_;
}
inline void relay_msg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void relay_msg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void relay_msg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* relay_msg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* relay_msg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void relay_msg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes channel_uuid = 7;
inline bool relay_msg::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void relay_msg::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void relay_msg::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void relay_msg::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& relay_msg::channel_uuid() const {
  return *channel_uuid_;
}
inline void relay_msg::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void relay_msg::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void relay_msg::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* relay_msg::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* relay_msg::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void relay_msg::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// broadcast_msg

// required int32 level = 1;
inline bool broadcast_msg::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void broadcast_msg::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void broadcast_msg::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void broadcast_msg::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 broadcast_msg::level() const {
  return level_;
}
inline void broadcast_msg::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 msg_id = 2;
inline bool broadcast_msg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void broadcast_msg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void broadcast_msg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void broadcast_msg::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 broadcast_msg::msg_id() const {
  return msg_id_;
}
inline void broadcast_msg::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// required bytes src_peer_id = 3;
inline bool broadcast_msg::has_src_peer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void broadcast_msg::set_has_src_peer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void broadcast_msg::clear_has_src_peer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void broadcast_msg::clear_src_peer_id() {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    src_peer_id_->clear();
  }
  clear_has_src_peer_id();
}
inline const ::std::string& broadcast_msg::src_peer_id() const {
  return *src_peer_id_;
}
inline void broadcast_msg::set_src_peer_id(const ::std::string& value) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(value);
}
inline void broadcast_msg::set_src_peer_id(const char* value) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(value);
}
inline void broadcast_msg::set_src_peer_id(const void* value, size_t size) {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  src_peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* broadcast_msg::mutable_src_peer_id() {
  set_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    src_peer_id_ = new ::std::string;
  }
  return src_peer_id_;
}
inline ::std::string* broadcast_msg::release_src_peer_id() {
  clear_has_src_peer_id();
  if (src_peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_peer_id_;
    src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void broadcast_msg::set_allocated_src_peer_id(::std::string* src_peer_id) {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete src_peer_id_;
  }
  if (src_peer_id) {
    set_has_src_peer_id();
    src_peer_id_ = src_peer_id;
  } else {
    clear_has_src_peer_id();
    src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ttl = 4 [default = 4];
inline bool broadcast_msg::has_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void broadcast_msg::set_has_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void broadcast_msg::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void broadcast_msg::clear_ttl() {
  ttl_ = 4u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 broadcast_msg::ttl() const {
  return ttl_;
}
inline void broadcast_msg::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// optional bytes bloomfilter = 5;
inline bool broadcast_msg::has_bloomfilter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void broadcast_msg::set_has_bloomfilter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void broadcast_msg::clear_has_bloomfilter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void broadcast_msg::clear_bloomfilter() {
  if (bloomfilter_ != &::google::protobuf::internal::kEmptyString) {
    bloomfilter_->clear();
  }
  clear_has_bloomfilter();
}
inline const ::std::string& broadcast_msg::bloomfilter() const {
  return *bloomfilter_;
}
inline void broadcast_msg::set_bloomfilter(const ::std::string& value) {
  set_has_bloomfilter();
  if (bloomfilter_ == &::google::protobuf::internal::kEmptyString) {
    bloomfilter_ = new ::std::string;
  }
  bloomfilter_->assign(value);
}
inline void broadcast_msg::set_bloomfilter(const char* value) {
  set_has_bloomfilter();
  if (bloomfilter_ == &::google::protobuf::internal::kEmptyString) {
    bloomfilter_ = new ::std::string;
  }
  bloomfilter_->assign(value);
}
inline void broadcast_msg::set_bloomfilter(const void* value, size_t size) {
  set_has_bloomfilter();
  if (bloomfilter_ == &::google::protobuf::internal::kEmptyString) {
    bloomfilter_ = new ::std::string;
  }
  bloomfilter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* broadcast_msg::mutable_bloomfilter() {
  set_has_bloomfilter();
  if (bloomfilter_ == &::google::protobuf::internal::kEmptyString) {
    bloomfilter_ = new ::std::string;
  }
  return bloomfilter_;
}
inline ::std::string* broadcast_msg::release_bloomfilter() {
  clear_has_bloomfilter();
  if (bloomfilter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bloomfilter_;
    bloomfilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void broadcast_msg::set_allocated_bloomfilter(::std::string* bloomfilter) {
  if (bloomfilter_ != &::google::protobuf::internal::kEmptyString) {
    delete bloomfilter_;
  }
  if (bloomfilter) {
    set_has_bloomfilter();
    bloomfilter_ = bloomfilter;
  } else {
    clear_has_bloomfilter();
    bloomfilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes msg_data = 6;
inline bool broadcast_msg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void broadcast_msg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void broadcast_msg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void broadcast_msg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& broadcast_msg::msg_data() const {
  return *msg_data_;
}
inline void broadcast_msg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void broadcast_msg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void broadcast_msg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* broadcast_msg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* broadcast_msg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void broadcast_msg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// buffermap_exchange_msg

// required .p2message.buffermap_info buffermap = 1;
inline bool buffermap_exchange_msg::has_buffermap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buffermap_exchange_msg::set_has_buffermap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buffermap_exchange_msg::clear_has_buffermap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buffermap_exchange_msg::clear_buffermap() {
  if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
  clear_has_buffermap();
}
inline const ::p2message::buffermap_info& buffermap_exchange_msg::buffermap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buffermap_ != NULL ? *buffermap_ : *default_instance().buffermap_;
#else
  return buffermap_ != NULL ? *buffermap_ : *default_instance_->buffermap_;
#endif
}
inline ::p2message::buffermap_info* buffermap_exchange_msg::mutable_buffermap() {
  set_has_buffermap();
  if (buffermap_ == NULL) buffermap_ = new ::p2message::buffermap_info;
  return buffermap_;
}
inline ::p2message::buffermap_info* buffermap_exchange_msg::release_buffermap() {
  clear_has_buffermap();
  ::p2message::buffermap_info* temp = buffermap_;
  buffermap_ = NULL;
  return temp;
}
inline void buffermap_exchange_msg::set_allocated_buffermap(::p2message::buffermap_info* buffermap) {
  delete buffermap_;
  buffermap_ = buffermap;
  if (buffermap) {
    set_has_buffermap();
  } else {
    clear_has_buffermap();
  }
}

// optional sfixed32 current_playing_timestamp = 2;
inline bool buffermap_exchange_msg::has_current_playing_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buffermap_exchange_msg::set_has_current_playing_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buffermap_exchange_msg::clear_has_current_playing_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buffermap_exchange_msg::clear_current_playing_timestamp() {
  current_playing_timestamp_ = 0;
  clear_has_current_playing_timestamp();
}
inline ::google::protobuf::int32 buffermap_exchange_msg::current_playing_timestamp() const {
  return current_playing_timestamp_;
}
inline void buffermap_exchange_msg::set_current_playing_timestamp(::google::protobuf::int32 value) {
  set_has_current_playing_timestamp();
  current_playing_timestamp_ = value;
}

// -------------------------------------------------------------------

// join_channel_msg

// required bytes channel_id = 1;
inline bool join_channel_msg::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void join_channel_msg::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void join_channel_msg::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void join_channel_msg::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& join_channel_msg::channel_id() const {
  return *channel_id_;
}
inline void join_channel_msg::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void join_channel_msg::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void join_channel_msg::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* join_channel_msg::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* join_channel_msg::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void join_channel_msg::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// media_request_msg

// required bool direct_request = 1;
inline bool media_request_msg::has_direct_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void media_request_msg::set_has_direct_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void media_request_msg::clear_has_direct_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void media_request_msg::clear_direct_request() {
  direct_request_ = false;
  clear_has_direct_request();
}
inline bool media_request_msg::direct_request() const {
  return direct_request_;
}
inline void media_request_msg::set_direct_request(bool value) {
  set_has_direct_request();
  direct_request_ = value;
}

// required bytes peer_id = 2;
inline bool media_request_msg::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void media_request_msg::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void media_request_msg::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void media_request_msg::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& media_request_msg::peer_id() const {
  return *peer_id_;
}
inline void media_request_msg::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void media_request_msg::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void media_request_msg::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* media_request_msg::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* media_request_msg::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void media_request_msg::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated fixed32 seqno = 3;
inline int media_request_msg::seqno_size() const {
  return seqno_.size();
}
inline void media_request_msg::clear_seqno() {
  seqno_.Clear();
}
inline ::google::protobuf::uint32 media_request_msg::seqno(int index) const {
  return seqno_.Get(index);
}
inline void media_request_msg::set_seqno(int index, ::google::protobuf::uint32 value) {
  seqno_.Set(index, value);
}
inline void media_request_msg::add_seqno(::google::protobuf::uint32 value) {
  seqno_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
media_request_msg::seqno() const {
  return seqno_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
media_request_msg::mutable_seqno() {
  return &seqno_;
}

// optional sfixed32 current_playing_timestamp = 4;
inline bool media_request_msg::has_current_playing_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void media_request_msg::set_has_current_playing_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void media_request_msg::clear_has_current_playing_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void media_request_msg::clear_current_playing_timestamp() {
  current_playing_timestamp_ = 0;
  clear_has_current_playing_timestamp();
}
inline ::google::protobuf::int32 media_request_msg::current_playing_timestamp() const {
  return current_playing_timestamp_;
}
inline void media_request_msg::set_current_playing_timestamp(::google::protobuf::int32 value) {
  set_has_current_playing_timestamp();
  current_playing_timestamp_ = value;
}

// optional bytes channel_id = 5;
inline bool media_request_msg::has_channel_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void media_request_msg::set_has_channel_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void media_request_msg::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void media_request_msg::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& media_request_msg::channel_id() const {
  return *channel_id_;
}
inline void media_request_msg::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void media_request_msg::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void media_request_msg::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* media_request_msg::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* media_request_msg::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void media_request_msg::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .p2message.buffermap_info buffermap = 6;
inline bool media_request_msg::has_buffermap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void media_request_msg::set_has_buffermap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void media_request_msg::clear_has_buffermap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void media_request_msg::clear_buffermap() {
  if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
  clear_has_buffermap();
}
inline const ::p2message::buffermap_info& media_request_msg::buffermap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buffermap_ != NULL ? *buffermap_ : *default_instance().buffermap_;
#else
  return buffermap_ != NULL ? *buffermap_ : *default_instance_->buffermap_;
#endif
}
inline ::p2message::buffermap_info* media_request_msg::mutable_buffermap() {
  set_has_buffermap();
  if (buffermap_ == NULL) buffermap_ = new ::p2message::buffermap_info;
  return buffermap_;
}
inline ::p2message::buffermap_info* media_request_msg::release_buffermap() {
  clear_has_buffermap();
  ::p2message::buffermap_info* temp = buffermap_;
  buffermap_ = NULL;
  return temp;
}
inline void media_request_msg::set_allocated_buffermap(::p2message::buffermap_info* buffermap) {
  delete buffermap_;
  buffermap_ = buffermap;
  if (buffermap) {
    set_has_buffermap();
  } else {
    clear_has_buffermap();
  }
}

// -------------------------------------------------------------------

// media_subscription_msg

// repeated uint32 substream_id = 1;
inline int media_subscription_msg::substream_id_size() const {
  return substream_id_.size();
}
inline void media_subscription_msg::clear_substream_id() {
  substream_id_.Clear();
}
inline ::google::protobuf::uint32 media_subscription_msg::substream_id(int index) const {
  return substream_id_.Get(index);
}
inline void media_subscription_msg::set_substream_id(int index, ::google::protobuf::uint32 value) {
  substream_id_.Set(index, value);
}
inline void media_subscription_msg::add_substream_id(::google::protobuf::uint32 value) {
  substream_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
media_subscription_msg::substream_id() const {
  return substream_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
media_subscription_msg::mutable_substream_id() {
  return &substream_id_;
}

// required .p2message.buffermap_info buffermap = 2;
inline bool media_subscription_msg::has_buffermap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void media_subscription_msg::set_has_buffermap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void media_subscription_msg::clear_has_buffermap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void media_subscription_msg::clear_buffermap() {
  if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
  clear_has_buffermap();
}
inline const ::p2message::buffermap_info& media_subscription_msg::buffermap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buffermap_ != NULL ? *buffermap_ : *default_instance().buffermap_;
#else
  return buffermap_ != NULL ? *buffermap_ : *default_instance_->buffermap_;
#endif
}
inline ::p2message::buffermap_info* media_subscription_msg::mutable_buffermap() {
  set_has_buffermap();
  if (buffermap_ == NULL) buffermap_ = new ::p2message::buffermap_info;
  return buffermap_;
}
inline ::p2message::buffermap_info* media_subscription_msg::release_buffermap() {
  clear_has_buffermap();
  ::p2message::buffermap_info* temp = buffermap_;
  buffermap_ = NULL;
  return temp;
}
inline void media_subscription_msg::set_allocated_buffermap(::p2message::buffermap_info* buffermap) {
  delete buffermap_;
  buffermap_ = buffermap;
  if (buffermap) {
    set_has_buffermap();
  } else {
    clear_has_buffermap();
  }
}

// repeated fixed32 ignore_seqno_list = 3;
inline int media_subscription_msg::ignore_seqno_list_size() const {
  return ignore_seqno_list_.size();
}
inline void media_subscription_msg::clear_ignore_seqno_list() {
  ignore_seqno_list_.Clear();
}
inline ::google::protobuf::uint32 media_subscription_msg::ignore_seqno_list(int index) const {
  return ignore_seqno_list_.Get(index);
}
inline void media_subscription_msg::set_ignore_seqno_list(int index, ::google::protobuf::uint32 value) {
  ignore_seqno_list_.Set(index, value);
}
inline void media_subscription_msg::add_ignore_seqno_list(::google::protobuf::uint32 value) {
  ignore_seqno_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
media_subscription_msg::ignore_seqno_list() const {
  return ignore_seqno_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
media_subscription_msg::mutable_ignore_seqno_list() {
  return &ignore_seqno_list_;
}

// optional sfixed32 current_playing_timestamp = 4;
inline bool media_subscription_msg::has_current_playing_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void media_subscription_msg::set_has_current_playing_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void media_subscription_msg::clear_has_current_playing_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void media_subscription_msg::clear_current_playing_timestamp() {
  current_playing_timestamp_ = 0;
  clear_has_current_playing_timestamp();
}
inline ::google::protobuf::int32 media_subscription_msg::current_playing_timestamp() const {
  return current_playing_timestamp_;
}
inline void media_subscription_msg::set_current_playing_timestamp(::google::protobuf::int32 value) {
  set_has_current_playing_timestamp();
  current_playing_timestamp_ = value;
}

// -------------------------------------------------------------------

// punch_request_msg

// required uint32 ip = 1;
inline bool punch_request_msg::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void punch_request_msg::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void punch_request_msg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void punch_request_msg::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 punch_request_msg::ip() const {
  return ip_;
}
inline void punch_request_msg::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required uint32 port = 2;
inline bool punch_request_msg::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void punch_request_msg::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void punch_request_msg::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void punch_request_msg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 punch_request_msg::port() const {
  return port_;
}
inline void punch_request_msg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required bytes msg_data = 3;
inline bool punch_request_msg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void punch_request_msg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void punch_request_msg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void punch_request_msg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& punch_request_msg::msg_data() const {
  return *msg_data_;
}
inline void punch_request_msg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void punch_request_msg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void punch_request_msg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* punch_request_msg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* punch_request_msg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void punch_request_msg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// media_sent_confirm_msg

// repeated fixed32 seqno = 1;
inline int media_sent_confirm_msg::seqno_size() const {
  return seqno_.size();
}
inline void media_sent_confirm_msg::clear_seqno() {
  seqno_.Clear();
}
inline ::google::protobuf::uint32 media_sent_confirm_msg::seqno(int index) const {
  return seqno_.Get(index);
}
inline void media_sent_confirm_msg::set_seqno(int index, ::google::protobuf::uint32 value) {
  seqno_.Set(index, value);
}
inline void media_sent_confirm_msg::add_seqno(::google::protobuf::uint32 value) {
  seqno_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
media_sent_confirm_msg::seqno() const {
  return seqno_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
media_sent_confirm_msg::mutable_seqno() {
  return &seqno_;
}

// -------------------------------------------------------------------

// no_piece_msg

// required fixed32 seqno = 1;
inline bool no_piece_msg::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void no_piece_msg::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void no_piece_msg::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void no_piece_msg::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 no_piece_msg::seqno() const {
  return seqno_;
}
inline void no_piece_msg::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional fixed32 min_seqno = 2;
inline bool no_piece_msg::has_min_seqno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void no_piece_msg::set_has_min_seqno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void no_piece_msg::clear_has_min_seqno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void no_piece_msg::clear_min_seqno() {
  min_seqno_ = 0u;
  clear_has_min_seqno();
}
inline ::google::protobuf::uint32 no_piece_msg::min_seqno() const {
  return min_seqno_;
}
inline void no_piece_msg::set_min_seqno(::google::protobuf::uint32 value) {
  set_has_min_seqno();
  min_seqno_ = value;
}

// optional fixed32 max_seqno = 3;
inline bool no_piece_msg::has_max_seqno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void no_piece_msg::set_has_max_seqno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void no_piece_msg::clear_has_max_seqno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void no_piece_msg::clear_max_seqno() {
  max_seqno_ = 0u;
  clear_has_max_seqno();
}
inline ::google::protobuf::uint32 no_piece_msg::max_seqno() const {
  return max_seqno_;
}
inline void no_piece_msg::set_max_seqno(::google::protobuf::uint32 value) {
  set_has_max_seqno();
  max_seqno_ = value;
}

// optional int32 wait_time = 4;
inline bool no_piece_msg::has_wait_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void no_piece_msg::set_has_wait_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void no_piece_msg::clear_has_wait_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void no_piece_msg::clear_wait_time() {
  wait_time_ = 0;
  clear_has_wait_time();
}
inline ::google::protobuf::int32 no_piece_msg::wait_time() const {
  return wait_time_;
}
inline void no_piece_msg::set_wait_time(::google::protobuf::int32 value) {
  set_has_wait_time();
  wait_time_ = value;
}

// -------------------------------------------------------------------

// time_server_2_tracker

// required uint64 curr_time = 1;
inline bool time_server_2_tracker::has_curr_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time_server_2_tracker::set_has_curr_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time_server_2_tracker::clear_has_curr_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time_server_2_tracker::clear_curr_time() {
  curr_time_ = GOOGLE_ULONGLONG(0);
  clear_has_curr_time();
}
inline ::google::protobuf::uint64 time_server_2_tracker::curr_time() const {
  return curr_time_;
}
inline void time_server_2_tracker::set_curr_time(::google::protobuf::uint64 value) {
  set_has_curr_time();
  curr_time_ = value;
}

// -------------------------------------------------------------------

// ctrl2m_create_channel_msg

// required int32 type = 1;
inline bool ctrl2m_create_channel_msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ctrl2m_create_channel_msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ctrl2m_create_channel_msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ctrl2m_create_channel_msg::type() const {
  return type_;
}
inline void ctrl2m_create_channel_msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required bytes name = 2;
inline bool ctrl2m_create_channel_msg::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ctrl2m_create_channel_msg::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ctrl2m_create_channel_msg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ctrl2m_create_channel_msg::name() const {
  return *name_;
}
inline void ctrl2m_create_channel_msg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes channel_link = 3;
inline bool ctrl2m_create_channel_msg::has_channel_link() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_channel_link() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ctrl2m_create_channel_msg::clear_has_channel_link() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ctrl2m_create_channel_msg::clear_channel_link() {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    channel_link_->clear();
  }
  clear_has_channel_link();
}
inline const ::std::string& ctrl2m_create_channel_msg::channel_link() const {
  return *channel_link_;
}
inline void ctrl2m_create_channel_msg::set_channel_link(const ::std::string& value) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_channel_link(const char* value) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_channel_link(const void* value, size_t size) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_channel_link() {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  return channel_link_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_channel_link() {
  clear_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_link_;
    channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_channel_link(::std::string* channel_link) {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_link_;
  }
  if (channel_link) {
    set_has_channel_link();
    channel_link_ = channel_link;
  } else {
    clear_has_channel_link();
    channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes channel_uuid = 4;
inline bool ctrl2m_create_channel_msg::has_channel_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_channel_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ctrl2m_create_channel_msg::clear_has_channel_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ctrl2m_create_channel_msg::clear_channel_uuid() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    channel_uuid_->clear();
  }
  clear_has_channel_uuid();
}
inline const ::std::string& ctrl2m_create_channel_msg::channel_uuid() const {
  return *channel_uuid_;
}
inline void ctrl2m_create_channel_msg::set_channel_uuid(const ::std::string& value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_channel_uuid(const char* value) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_channel_uuid(const void* value, size_t size) {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  channel_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_channel_uuid() {
  set_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    channel_uuid_ = new ::std::string;
  }
  return channel_uuid_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_channel_uuid() {
  clear_has_channel_uuid();
  if (channel_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_uuid_;
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_channel_uuid(::std::string* channel_uuid) {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (channel_uuid) {
    set_has_channel_uuid();
    channel_uuid_ = channel_uuid;
  } else {
    clear_has_channel_uuid();
    channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes internal_address = 5;
inline bool ctrl2m_create_channel_msg::has_internal_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_internal_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ctrl2m_create_channel_msg::clear_has_internal_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ctrl2m_create_channel_msg::clear_internal_address() {
  if (internal_address_ != &::google::protobuf::internal::kEmptyString) {
    internal_address_->clear();
  }
  clear_has_internal_address();
}
inline const ::std::string& ctrl2m_create_channel_msg::internal_address() const {
  return *internal_address_;
}
inline void ctrl2m_create_channel_msg::set_internal_address(const ::std::string& value) {
  set_has_internal_address();
  if (internal_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_address_ = new ::std::string;
  }
  internal_address_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_internal_address(const char* value) {
  set_has_internal_address();
  if (internal_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_address_ = new ::std::string;
  }
  internal_address_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_internal_address(const void* value, size_t size) {
  set_has_internal_address();
  if (internal_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_address_ = new ::std::string;
  }
  internal_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_internal_address() {
  set_has_internal_address();
  if (internal_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_address_ = new ::std::string;
  }
  return internal_address_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_internal_address() {
  clear_has_internal_address();
  if (internal_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internal_address_;
    internal_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_internal_address(::std::string* internal_address) {
  if (internal_address_ != &::google::protobuf::internal::kEmptyString) {
    delete internal_address_;
  }
  if (internal_address) {
    set_has_internal_address();
    internal_address_ = internal_address;
  } else {
    clear_has_internal_address();
    internal_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes external_address = 6;
inline bool ctrl2m_create_channel_msg::has_external_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_external_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ctrl2m_create_channel_msg::clear_has_external_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ctrl2m_create_channel_msg::clear_external_address() {
  if (external_address_ != &::google::protobuf::internal::kEmptyString) {
    external_address_->clear();
  }
  clear_has_external_address();
}
inline const ::std::string& ctrl2m_create_channel_msg::external_address() const {
  return *external_address_;
}
inline void ctrl2m_create_channel_msg::set_external_address(const ::std::string& value) {
  set_has_external_address();
  if (external_address_ == &::google::protobuf::internal::kEmptyString) {
    external_address_ = new ::std::string;
  }
  external_address_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_external_address(const char* value) {
  set_has_external_address();
  if (external_address_ == &::google::protobuf::internal::kEmptyString) {
    external_address_ = new ::std::string;
  }
  external_address_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_external_address(const void* value, size_t size) {
  set_has_external_address();
  if (external_address_ == &::google::protobuf::internal::kEmptyString) {
    external_address_ = new ::std::string;
  }
  external_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_external_address() {
  set_has_external_address();
  if (external_address_ == &::google::protobuf::internal::kEmptyString) {
    external_address_ = new ::std::string;
  }
  return external_address_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_external_address() {
  clear_has_external_address();
  if (external_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = external_address_;
    external_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_external_address(::std::string* external_address) {
  if (external_address_ != &::google::protobuf::internal::kEmptyString) {
    delete external_address_;
  }
  if (external_address) {
    set_has_external_address();
    external_address_ = external_address;
  } else {
    clear_has_external_address();
    external_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes tracker_address = 7;
inline int ctrl2m_create_channel_msg::tracker_address_size() const {
  return tracker_address_.size();
}
inline void ctrl2m_create_channel_msg::clear_tracker_address() {
  tracker_address_.Clear();
}
inline const ::std::string& ctrl2m_create_channel_msg::tracker_address(int index) const {
  return tracker_address_.Get(index);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_tracker_address(int index) {
  return tracker_address_.Mutable(index);
}
inline void ctrl2m_create_channel_msg::set_tracker_address(int index, const ::std::string& value) {
  tracker_address_.Mutable(index)->assign(value);
}
inline void ctrl2m_create_channel_msg::set_tracker_address(int index, const char* value) {
  tracker_address_.Mutable(index)->assign(value);
}
inline void ctrl2m_create_channel_msg::set_tracker_address(int index, const void* value, size_t size) {
  tracker_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::add_tracker_address() {
  return tracker_address_.Add();
}
inline void ctrl2m_create_channel_msg::add_tracker_address(const ::std::string& value) {
  tracker_address_.Add()->assign(value);
}
inline void ctrl2m_create_channel_msg::add_tracker_address(const char* value) {
  tracker_address_.Add()->assign(value);
}
inline void ctrl2m_create_channel_msg::add_tracker_address(const void* value, size_t size) {
  tracker_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ctrl2m_create_channel_msg::tracker_address() const {
  return tracker_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ctrl2m_create_channel_msg::mutable_tracker_address() {
  return &tracker_address_;
}

// optional bool enable_live_cache = 8;
inline bool ctrl2m_create_channel_msg::has_enable_live_cache() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_enable_live_cache() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ctrl2m_create_channel_msg::clear_has_enable_live_cache() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ctrl2m_create_channel_msg::clear_enable_live_cache() {
  enable_live_cache_ = false;
  clear_has_enable_live_cache();
}
inline bool ctrl2m_create_channel_msg::enable_live_cache() const {
  return enable_live_cache_;
}
inline void ctrl2m_create_channel_msg::set_enable_live_cache(bool value) {
  set_has_enable_live_cache();
  enable_live_cache_ = value;
}

// optional bytes stream_recv_url = 9;
inline bool ctrl2m_create_channel_msg::has_stream_recv_url() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_stream_recv_url() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ctrl2m_create_channel_msg::clear_has_stream_recv_url() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ctrl2m_create_channel_msg::clear_stream_recv_url() {
  if (stream_recv_url_ != &::google::protobuf::internal::kEmptyString) {
    stream_recv_url_->clear();
  }
  clear_has_stream_recv_url();
}
inline const ::std::string& ctrl2m_create_channel_msg::stream_recv_url() const {
  return *stream_recv_url_;
}
inline void ctrl2m_create_channel_msg::set_stream_recv_url(const ::std::string& value) {
  set_has_stream_recv_url();
  if (stream_recv_url_ == &::google::protobuf::internal::kEmptyString) {
    stream_recv_url_ = new ::std::string;
  }
  stream_recv_url_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_stream_recv_url(const char* value) {
  set_has_stream_recv_url();
  if (stream_recv_url_ == &::google::protobuf::internal::kEmptyString) {
    stream_recv_url_ = new ::std::string;
  }
  stream_recv_url_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_stream_recv_url(const void* value, size_t size) {
  set_has_stream_recv_url();
  if (stream_recv_url_ == &::google::protobuf::internal::kEmptyString) {
    stream_recv_url_ = new ::std::string;
  }
  stream_recv_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_stream_recv_url() {
  set_has_stream_recv_url();
  if (stream_recv_url_ == &::google::protobuf::internal::kEmptyString) {
    stream_recv_url_ = new ::std::string;
  }
  return stream_recv_url_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_stream_recv_url() {
  clear_has_stream_recv_url();
  if (stream_recv_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stream_recv_url_;
    stream_recv_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_stream_recv_url(::std::string* stream_recv_url) {
  if (stream_recv_url_ != &::google::protobuf::internal::kEmptyString) {
    delete stream_recv_url_;
  }
  if (stream_recv_url) {
    set_has_stream_recv_url();
    stream_recv_url_ = stream_recv_url;
  } else {
    clear_has_stream_recv_url();
    stream_recv_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes live_cache_dir = 10;
inline bool ctrl2m_create_channel_msg::has_live_cache_dir() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_live_cache_dir() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ctrl2m_create_channel_msg::clear_has_live_cache_dir() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ctrl2m_create_channel_msg::clear_live_cache_dir() {
  if (live_cache_dir_ != &::google::protobuf::internal::kEmptyString) {
    live_cache_dir_->clear();
  }
  clear_has_live_cache_dir();
}
inline const ::std::string& ctrl2m_create_channel_msg::live_cache_dir() const {
  return *live_cache_dir_;
}
inline void ctrl2m_create_channel_msg::set_live_cache_dir(const ::std::string& value) {
  set_has_live_cache_dir();
  if (live_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    live_cache_dir_ = new ::std::string;
  }
  live_cache_dir_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_live_cache_dir(const char* value) {
  set_has_live_cache_dir();
  if (live_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    live_cache_dir_ = new ::std::string;
  }
  live_cache_dir_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_live_cache_dir(const void* value, size_t size) {
  set_has_live_cache_dir();
  if (live_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    live_cache_dir_ = new ::std::string;
  }
  live_cache_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_live_cache_dir() {
  set_has_live_cache_dir();
  if (live_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    live_cache_dir_ = new ::std::string;
  }
  return live_cache_dir_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_live_cache_dir() {
  clear_has_live_cache_dir();
  if (live_cache_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = live_cache_dir_;
    live_cache_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_live_cache_dir(::std::string* live_cache_dir) {
  if (live_cache_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete live_cache_dir_;
  }
  if (live_cache_dir) {
    set_has_live_cache_dir();
    live_cache_dir_ = live_cache_dir;
  } else {
    clear_has_live_cache_dir();
    live_cache_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 max_duration = 11;
inline bool ctrl2m_create_channel_msg::has_max_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_max_duration() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ctrl2m_create_channel_msg::clear_has_max_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ctrl2m_create_channel_msg::clear_max_duration() {
  max_duration_ = GOOGLE_ULONGLONG(0);
  clear_has_max_duration();
}
inline ::google::protobuf::uint64 ctrl2m_create_channel_msg::max_duration() const {
  return max_duration_;
}
inline void ctrl2m_create_channel_msg::set_max_duration(::google::protobuf::uint64 value) {
  set_has_max_duration();
  max_duration_ = value;
}

// optional uint64 max_length_per_file = 12;
inline bool ctrl2m_create_channel_msg::has_max_length_per_file() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_max_length_per_file() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ctrl2m_create_channel_msg::clear_has_max_length_per_file() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ctrl2m_create_channel_msg::clear_max_length_per_file() {
  max_length_per_file_ = GOOGLE_ULONGLONG(0);
  clear_has_max_length_per_file();
}
inline ::google::protobuf::uint64 ctrl2m_create_channel_msg::max_length_per_file() const {
  return max_length_per_file_;
}
inline void ctrl2m_create_channel_msg::set_max_length_per_file(::google::protobuf::uint64 value) {
  set_has_max_length_per_file();
  max_length_per_file_ = value;
}

// optional bytes media_directory = 13;
inline bool ctrl2m_create_channel_msg::has_media_directory() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_media_directory() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ctrl2m_create_channel_msg::clear_has_media_directory() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ctrl2m_create_channel_msg::clear_media_directory() {
  if (media_directory_ != &::google::protobuf::internal::kEmptyString) {
    media_directory_->clear();
  }
  clear_has_media_directory();
}
inline const ::std::string& ctrl2m_create_channel_msg::media_directory() const {
  return *media_directory_;
}
inline void ctrl2m_create_channel_msg::set_media_directory(const ::std::string& value) {
  set_has_media_directory();
  if (media_directory_ == &::google::protobuf::internal::kEmptyString) {
    media_directory_ = new ::std::string;
  }
  media_directory_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_media_directory(const char* value) {
  set_has_media_directory();
  if (media_directory_ == &::google::protobuf::internal::kEmptyString) {
    media_directory_ = new ::std::string;
  }
  media_directory_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_media_directory(const void* value, size_t size) {
  set_has_media_directory();
  if (media_directory_ == &::google::protobuf::internal::kEmptyString) {
    media_directory_ = new ::std::string;
  }
  media_directory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_media_directory() {
  set_has_media_directory();
  if (media_directory_ == &::google::protobuf::internal::kEmptyString) {
    media_directory_ = new ::std::string;
  }
  return media_directory_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_media_directory() {
  clear_has_media_directory();
  if (media_directory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = media_directory_;
    media_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_media_directory(::std::string* media_directory) {
  if (media_directory_ != &::google::protobuf::internal::kEmptyString) {
    delete media_directory_;
  }
  if (media_directory) {
    set_has_media_directory();
    media_directory_ = media_directory;
  } else {
    clear_has_media_directory();
    media_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 duration = 14;
inline bool ctrl2m_create_channel_msg::has_duration() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_duration() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ctrl2m_create_channel_msg::clear_has_duration() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ctrl2m_create_channel_msg::clear_duration() {
  duration_ = GOOGLE_ULONGLONG(0);
  clear_has_duration();
}
inline ::google::protobuf::uint64 ctrl2m_create_channel_msg::duration() const {
  return duration_;
}
inline void ctrl2m_create_channel_msg::set_duration(::google::protobuf::uint64 value) {
  set_has_duration();
  duration_ = value;
}

// optional uint64 length = 15;
inline bool ctrl2m_create_channel_msg::has_length() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_length() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ctrl2m_create_channel_msg::clear_has_length() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ctrl2m_create_channel_msg::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 ctrl2m_create_channel_msg::length() const {
  return length_;
}
inline void ctrl2m_create_channel_msg::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// optional bytes channel_key = 16;
inline bool ctrl2m_create_channel_msg::has_channel_key() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ctrl2m_create_channel_msg::set_has_channel_key() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ctrl2m_create_channel_msg::clear_has_channel_key() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ctrl2m_create_channel_msg::clear_channel_key() {
  if (channel_key_ != &::google::protobuf::internal::kEmptyString) {
    channel_key_->clear();
  }
  clear_has_channel_key();
}
inline const ::std::string& ctrl2m_create_channel_msg::channel_key() const {
  return *channel_key_;
}
inline void ctrl2m_create_channel_msg::set_channel_key(const ::std::string& value) {
  set_has_channel_key();
  if (channel_key_ == &::google::protobuf::internal::kEmptyString) {
    channel_key_ = new ::std::string;
  }
  channel_key_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_channel_key(const char* value) {
  set_has_channel_key();
  if (channel_key_ == &::google::protobuf::internal::kEmptyString) {
    channel_key_ = new ::std::string;
  }
  channel_key_->assign(value);
}
inline void ctrl2m_create_channel_msg::set_channel_key(const void* value, size_t size) {
  set_has_channel_key();
  if (channel_key_ == &::google::protobuf::internal::kEmptyString) {
    channel_key_ = new ::std::string;
  }
  channel_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2m_create_channel_msg::mutable_channel_key() {
  set_has_channel_key();
  if (channel_key_ == &::google::protobuf::internal::kEmptyString) {
    channel_key_ = new ::std::string;
  }
  return channel_key_;
}
inline ::std::string* ctrl2m_create_channel_msg::release_channel_key() {
  clear_has_channel_key();
  if (channel_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_key_;
    channel_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2m_create_channel_msg::set_allocated_channel_key(::std::string* channel_key) {
  if (channel_key_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_key_;
  }
  if (channel_key) {
    set_has_channel_key();
    channel_key_ = channel_key;
  } else {
    clear_has_channel_key();
    channel_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ctrl2s_create_channel_msg

// required bytes id = 1;
inline bool ctrl2s_create_channel_msg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ctrl2s_create_channel_msg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ctrl2s_create_channel_msg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ctrl2s_create_channel_msg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ctrl2s_create_channel_msg::id() const {
  return *id_;
}
inline void ctrl2s_create_channel_msg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ctrl2s_create_channel_msg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ctrl2s_create_channel_msg::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2s_create_channel_msg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ctrl2s_create_channel_msg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2s_create_channel_msg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes receive_url = 2;
inline bool ctrl2s_create_channel_msg::has_receive_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctrl2s_create_channel_msg::set_has_receive_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ctrl2s_create_channel_msg::clear_has_receive_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ctrl2s_create_channel_msg::clear_receive_url() {
  if (receive_url_ != &::google::protobuf::internal::kEmptyString) {
    receive_url_->clear();
  }
  clear_has_receive_url();
}
inline const ::std::string& ctrl2s_create_channel_msg::receive_url() const {
  return *receive_url_;
}
inline void ctrl2s_create_channel_msg::set_receive_url(const ::std::string& value) {
  set_has_receive_url();
  if (receive_url_ == &::google::protobuf::internal::kEmptyString) {
    receive_url_ = new ::std::string;
  }
  receive_url_->assign(value);
}
inline void ctrl2s_create_channel_msg::set_receive_url(const char* value) {
  set_has_receive_url();
  if (receive_url_ == &::google::protobuf::internal::kEmptyString) {
    receive_url_ = new ::std::string;
  }
  receive_url_->assign(value);
}
inline void ctrl2s_create_channel_msg::set_receive_url(const void* value, size_t size) {
  set_has_receive_url();
  if (receive_url_ == &::google::protobuf::internal::kEmptyString) {
    receive_url_ = new ::std::string;
  }
  receive_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2s_create_channel_msg::mutable_receive_url() {
  set_has_receive_url();
  if (receive_url_ == &::google::protobuf::internal::kEmptyString) {
    receive_url_ = new ::std::string;
  }
  return receive_url_;
}
inline ::std::string* ctrl2s_create_channel_msg::release_receive_url() {
  clear_has_receive_url();
  if (receive_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receive_url_;
    receive_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ctrl2s_create_channel_msg::set_allocated_receive_url(::std::string* receive_url) {
  if (receive_url_ != &::google::protobuf::internal::kEmptyString) {
    delete receive_url_;
  }
  if (receive_url) {
    set_has_receive_url();
    receive_url_ = receive_url;
  } else {
    clear_has_receive_url();
    receive_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes send_urls = 3;
inline int ctrl2s_create_channel_msg::send_urls_size() const {
  return send_urls_.size();
}
inline void ctrl2s_create_channel_msg::clear_send_urls() {
  send_urls_.Clear();
}
inline const ::std::string& ctrl2s_create_channel_msg::send_urls(int index) const {
  return send_urls_.Get(index);
}
inline ::std::string* ctrl2s_create_channel_msg::mutable_send_urls(int index) {
  return send_urls_.Mutable(index);
}
inline void ctrl2s_create_channel_msg::set_send_urls(int index, const ::std::string& value) {
  send_urls_.Mutable(index)->assign(value);
}
inline void ctrl2s_create_channel_msg::set_send_urls(int index, const char* value) {
  send_urls_.Mutable(index)->assign(value);
}
inline void ctrl2s_create_channel_msg::set_send_urls(int index, const void* value, size_t size) {
  send_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ctrl2s_create_channel_msg::add_send_urls() {
  return send_urls_.Add();
}
inline void ctrl2s_create_channel_msg::add_send_urls(const ::std::string& value) {
  send_urls_.Add()->assign(value);
}
inline void ctrl2s_create_channel_msg::add_send_urls(const char* value) {
  send_urls_.Add()->assign(value);
}
inline void ctrl2s_create_channel_msg::add_send_urls(const void* value, size_t size) {
  send_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ctrl2s_create_channel_msg::send_urls() const {
  return send_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ctrl2s_create_channel_msg::mutable_send_urls() {
  return &send_urls_;
}

// -------------------------------------------------------------------

// mds_cmd_msg

// required bytes session_id = 1;
inline bool mds_cmd_msg::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mds_cmd_msg::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mds_cmd_msg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mds_cmd_msg::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& mds_cmd_msg::session_id() const {
  return *session_id_;
}
inline void mds_cmd_msg::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void mds_cmd_msg::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void mds_cmd_msg::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mds_cmd_msg::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* mds_cmd_msg::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mds_cmd_msg::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes cmd = 2;
inline bool mds_cmd_msg::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mds_cmd_msg::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mds_cmd_msg::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mds_cmd_msg::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& mds_cmd_msg::cmd() const {
  return *cmd_;
}
inline void mds_cmd_msg::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void mds_cmd_msg::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void mds_cmd_msg::set_cmd(const void* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mds_cmd_msg::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* mds_cmd_msg::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mds_cmd_msg::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes channel_ids = 3;
inline int mds_cmd_msg::channel_ids_size() const {
  return channel_ids_.size();
}
inline void mds_cmd_msg::clear_channel_ids() {
  channel_ids_.Clear();
}
inline const ::std::string& mds_cmd_msg::channel_ids(int index) const {
  return channel_ids_.Get(index);
}
inline ::std::string* mds_cmd_msg::mutable_channel_ids(int index) {
  return channel_ids_.Mutable(index);
}
inline void mds_cmd_msg::set_channel_ids(int index, const ::std::string& value) {
  channel_ids_.Mutable(index)->assign(value);
}
inline void mds_cmd_msg::set_channel_ids(int index, const char* value) {
  channel_ids_.Mutable(index)->assign(value);
}
inline void mds_cmd_msg::set_channel_ids(int index, const void* value, size_t size) {
  channel_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mds_cmd_msg::add_channel_ids() {
  return channel_ids_.Add();
}
inline void mds_cmd_msg::add_channel_ids(const ::std::string& value) {
  channel_ids_.Add()->assign(value);
}
inline void mds_cmd_msg::add_channel_ids(const char* value) {
  channel_ids_.Add()->assign(value);
}
inline void mds_cmd_msg::add_channel_ids(const void* value, size_t size) {
  channel_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mds_cmd_msg::channel_ids() const {
  return channel_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mds_cmd_msg::mutable_channel_ids() {
  return &channel_ids_;
}

// repeated .p2message.ctrl2m_create_channel_msg channel_info = 4;
inline int mds_cmd_msg::channel_info_size() const {
  return channel_info_.size();
}
inline void mds_cmd_msg::clear_channel_info() {
  channel_info_.Clear();
}
inline const ::p2message::ctrl2m_create_channel_msg& mds_cmd_msg::channel_info(int index) const {
  return channel_info_.Get(index);
}
inline ::p2message::ctrl2m_create_channel_msg* mds_cmd_msg::mutable_channel_info(int index) {
  return channel_info_.Mutable(index);
}
inline ::p2message::ctrl2m_create_channel_msg* mds_cmd_msg::add_channel_info() {
  return channel_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::p2message::ctrl2m_create_channel_msg >&
mds_cmd_msg::channel_info() const {
  return channel_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::p2message::ctrl2m_create_channel_msg >*
mds_cmd_msg::mutable_channel_info() {
  return &channel_info_;
}

// optional .p2message.ctrl2s_create_channel_msg shunt_info = 5;
inline bool mds_cmd_msg::has_shunt_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mds_cmd_msg::set_has_shunt_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mds_cmd_msg::clear_has_shunt_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mds_cmd_msg::clear_shunt_info() {
  if (shunt_info_ != NULL) shunt_info_->::p2message::ctrl2s_create_channel_msg::Clear();
  clear_has_shunt_info();
}
inline const ::p2message::ctrl2s_create_channel_msg& mds_cmd_msg::shunt_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shunt_info_ != NULL ? *shunt_info_ : *default_instance().shunt_info_;
#else
  return shunt_info_ != NULL ? *shunt_info_ : *default_instance_->shunt_info_;
#endif
}
inline ::p2message::ctrl2s_create_channel_msg* mds_cmd_msg::mutable_shunt_info() {
  set_has_shunt_info();
  if (shunt_info_ == NULL) shunt_info_ = new ::p2message::ctrl2s_create_channel_msg;
  return shunt_info_;
}
inline ::p2message::ctrl2s_create_channel_msg* mds_cmd_msg::release_shunt_info() {
  clear_has_shunt_info();
  ::p2message::ctrl2s_create_channel_msg* temp = shunt_info_;
  shunt_info_ = NULL;
  return temp;
}
inline void mds_cmd_msg::set_allocated_shunt_info(::p2message::ctrl2s_create_channel_msg* shunt_info) {
  delete shunt_info_;
  shunt_info_ = shunt_info;
  if (shunt_info) {
    set_has_shunt_info();
  } else {
    clear_has_shunt_info();
  }
}

// optional bytes config_val = 6;
inline bool mds_cmd_msg::has_config_val() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mds_cmd_msg::set_has_config_val() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mds_cmd_msg::clear_has_config_val() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mds_cmd_msg::clear_config_val() {
  if (config_val_ != &::google::protobuf::internal::kEmptyString) {
    config_val_->clear();
  }
  clear_has_config_val();
}
inline const ::std::string& mds_cmd_msg::config_val() const {
  return *config_val_;
}
inline void mds_cmd_msg::set_config_val(const ::std::string& value) {
  set_has_config_val();
  if (config_val_ == &::google::protobuf::internal::kEmptyString) {
    config_val_ = new ::std::string;
  }
  config_val_->assign(value);
}
inline void mds_cmd_msg::set_config_val(const char* value) {
  set_has_config_val();
  if (config_val_ == &::google::protobuf::internal::kEmptyString) {
    config_val_ = new ::std::string;
  }
  config_val_->assign(value);
}
inline void mds_cmd_msg::set_config_val(const void* value, size_t size) {
  set_has_config_val();
  if (config_val_ == &::google::protobuf::internal::kEmptyString) {
    config_val_ = new ::std::string;
  }
  config_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mds_cmd_msg::mutable_config_val() {
  set_has_config_val();
  if (config_val_ == &::google::protobuf::internal::kEmptyString) {
    config_val_ = new ::std::string;
  }
  return config_val_;
}
inline ::std::string* mds_cmd_msg::release_config_val() {
  clear_has_config_val();
  if (config_val_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_val_;
    config_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mds_cmd_msg::set_allocated_config_val(::std::string* config_val) {
  if (config_val_ != &::google::protobuf::internal::kEmptyString) {
    delete config_val_;
  }
  if (config_val) {
    set_has_config_val();
    config_val_ = config_val;
  } else {
    clear_has_config_val();
    config_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_login_reply = 7;
inline bool mds_cmd_msg::has_is_login_reply() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mds_cmd_msg::set_has_is_login_reply() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mds_cmd_msg::clear_has_is_login_reply() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mds_cmd_msg::clear_is_login_reply() {
  is_login_reply_ = false;
  clear_has_is_login_reply();
}
inline bool mds_cmd_msg::is_login_reply() const {
  return is_login_reply_;
}
inline void mds_cmd_msg::set_is_login_reply(bool value) {
  set_has_is_login_reply();
  is_login_reply_ = value;
}

// -------------------------------------------------------------------

// c2s_cmd_reply_msg

// required bytes session_id = 1;
inline bool c2s_cmd_reply_msg::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c2s_cmd_reply_msg::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c2s_cmd_reply_msg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c2s_cmd_reply_msg::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& c2s_cmd_reply_msg::session_id() const {
  return *session_id_;
}
inline void c2s_cmd_reply_msg::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void c2s_cmd_reply_msg::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void c2s_cmd_reply_msg::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c2s_cmd_reply_msg::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* c2s_cmd_reply_msg::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c2s_cmd_reply_msg::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 code = 2;
inline bool c2s_cmd_reply_msg::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void c2s_cmd_reply_msg::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void c2s_cmd_reply_msg::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void c2s_cmd_reply_msg::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 c2s_cmd_reply_msg::code() const {
  return code_;
}
inline void c2s_cmd_reply_msg::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// required bytes id = 3;
inline bool c2s_cmd_reply_msg::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void c2s_cmd_reply_msg::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void c2s_cmd_reply_msg::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void c2s_cmd_reply_msg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& c2s_cmd_reply_msg::id() const {
  return *id_;
}
inline void c2s_cmd_reply_msg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void c2s_cmd_reply_msg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void c2s_cmd_reply_msg::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c2s_cmd_reply_msg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* c2s_cmd_reply_msg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c2s_cmd_reply_msg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 4;
inline bool c2s_cmd_reply_msg::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void c2s_cmd_reply_msg::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void c2s_cmd_reply_msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void c2s_cmd_reply_msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 c2s_cmd_reply_msg::type() const {
  return type_;
}
inline void c2s_cmd_reply_msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes msg = 5;
inline bool c2s_cmd_reply_msg::has_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void c2s_cmd_reply_msg::set_has_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void c2s_cmd_reply_msg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void c2s_cmd_reply_msg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& c2s_cmd_reply_msg::msg() const {
  return *msg_;
}
inline void c2s_cmd_reply_msg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void c2s_cmd_reply_msg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void c2s_cmd_reply_msg::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c2s_cmd_reply_msg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* c2s_cmd_reply_msg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c2s_cmd_reply_msg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// c2s_auth_msg

// required bytes message = 1;
inline bool c2s_auth_msg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void c2s_auth_msg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void c2s_auth_msg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void c2s_auth_msg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& c2s_auth_msg::message() const {
  return *message_;
}
inline void c2s_auth_msg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void c2s_auth_msg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void c2s_auth_msg::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* c2s_auth_msg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* c2s_auth_msg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void c2s_auth_msg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// alive_alarm_report_msg

// required bytes id = 1;
inline bool alive_alarm_report_msg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void alive_alarm_report_msg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void alive_alarm_report_msg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void alive_alarm_report_msg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& alive_alarm_report_msg::id() const {
  return *id_;
}
inline void alive_alarm_report_msg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void alive_alarm_report_msg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void alive_alarm_report_msg::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* alive_alarm_report_msg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* alive_alarm_report_msg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void alive_alarm_report_msg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 2;
inline bool alive_alarm_report_msg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void alive_alarm_report_msg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void alive_alarm_report_msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void alive_alarm_report_msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 alive_alarm_report_msg::type() const {
  return type_;
}
inline void alive_alarm_report_msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 pid = 3;
inline bool alive_alarm_report_msg::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void alive_alarm_report_msg::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void alive_alarm_report_msg::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void alive_alarm_report_msg::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 alive_alarm_report_msg::pid() const {
  return pid_;
}
inline void alive_alarm_report_msg::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace p2message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
