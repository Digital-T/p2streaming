// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pa_message.proto

#ifndef PROTOBUF_pa_5fmessage_2eproto__INCLUDED
#define PROTOBUF_pa_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace proanalytics {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pa_5fmessage_2eproto();
void protobuf_AssignDesc_pa_5fmessage_2eproto();
void protobuf_ShutdownFile_pa_5fmessage_2eproto();

class init_msg;
class sample;
class sample_msg;
class control_msg;

enum sample_type {
  SAMPLE_UNKNOW = 0, 
  P2S = 1, 
  P2V = 2, 
  DVB = 3
};
bool sample_type_IsValid(int value);
const sample_type sample_type_MIN = SAMPLE_UNKNOW;
const sample_type sample_type_MAX = DVB;
const int sample_type_ARRAYSIZE = sample_type_MAX + 1;

enum control_type {
  CONTROL_UNKNOW = 0, 
  CHANGE_INTERVAL = 1
};
bool control_type_IsValid(int value);
const control_type control_type_MIN = CONTROL_UNKNOW;
const control_type control_type_MAX = CHANGE_INTERVAL;
const int control_type_ARRAYSIZE = control_type_MAX + 1;

// ===================================================================

class init_msg : public ::google::protobuf::MessageLite {
 public:
  init_msg();
  virtual ~init_msg();

  init_msg(const init_msg& from);

  inline init_msg& operator=(const init_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const init_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const init_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(init_msg* other);

  // implements Message ----------------------------------------------

  init_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const init_msg& from);
  void MergeFrom(const init_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 curr_time = 1;
  inline bool has_curr_time() const;
  inline void clear_curr_time();
  static const int kCurrTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 curr_time() const;
  inline void set_curr_time(::google::protobuf::uint64 value);

  // required uint32 sample_interval = 2;
  inline bool has_sample_interval() const;
  inline void clear_sample_interval();
  static const int kSampleIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 sample_interval() const;
  inline void set_sample_interval(::google::protobuf::uint32 value);

  // required uint32 packet_sample_count = 3;
  inline bool has_packet_sample_count() const;
  inline void clear_packet_sample_count();
  static const int kPacketSampleCountFieldNumber = 3;
  inline ::google::protobuf::uint32 packet_sample_count() const;
  inline void set_packet_sample_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proanalytics.init_msg)
 private:
  inline void set_has_curr_time();
  inline void clear_has_curr_time();
  inline void set_has_sample_interval();
  inline void clear_has_sample_interval();
  inline void set_has_packet_sample_count();
  inline void clear_has_packet_sample_count();

  ::google::protobuf::uint64 curr_time_;
  ::google::protobuf::uint32 sample_interval_;
  ::google::protobuf::uint32 packet_sample_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_pa_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_pa_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static init_msg* default_instance_;
};
// -------------------------------------------------------------------

class sample : public ::google::protobuf::MessageLite {
 public:
  sample();
  virtual ~sample();

  sample(const sample& from);

  inline sample& operator=(const sample& from) {
    CopyFrom(from);
    return *this;
  }

  static const sample& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const sample* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(sample* other);

  // implements Message ----------------------------------------------

  sample* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const sample& from);
  void MergeFrom(const sample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string channel_link = 2;
  inline bool has_channel_link() const;
  inline void clear_channel_link();
  static const int kChannelLinkFieldNumber = 2;
  inline const ::std::string& channel_link() const;
  inline void set_channel_link(const ::std::string& value);
  inline void set_channel_link(const char* value);
  inline void set_channel_link(const char* value, size_t size);
  inline ::std::string* mutable_channel_link();
  inline ::std::string* release_channel_link();
  inline void set_allocated_channel_link(::std::string* channel_link);

  // optional string channel_name = 3;
  inline bool has_channel_name() const;
  inline void clear_channel_name();
  static const int kChannelNameFieldNumber = 3;
  inline const ::std::string& channel_name() const;
  inline void set_channel_name(const ::std::string& value);
  inline void set_channel_name(const char* value);
  inline void set_channel_name(const char* value, size_t size);
  inline ::std::string* mutable_channel_name();
  inline ::std::string* release_channel_name();
  inline void set_allocated_channel_name(::std::string* channel_name);

  // required uint64 time_swamp = 4;
  inline bool has_time_swamp() const;
  inline void clear_time_swamp();
  static const int kTimeSwampFieldNumber = 4;
  inline ::google::protobuf::uint64 time_swamp() const;
  inline void set_time_swamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proanalytics.sample)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channel_link();
  inline void clear_has_channel_link();
  inline void set_has_channel_name();
  inline void clear_has_channel_name();
  inline void set_has_time_swamp();
  inline void clear_has_time_swamp();

  ::std::string* type_;
  ::std::string* channel_link_;
  ::std::string* channel_name_;
  ::google::protobuf::uint64 time_swamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_pa_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_pa_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static sample* default_instance_;
};
// -------------------------------------------------------------------

class sample_msg : public ::google::protobuf::MessageLite {
 public:
  sample_msg();
  virtual ~sample_msg();

  sample_msg(const sample_msg& from);

  inline sample_msg& operator=(const sample_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const sample_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const sample_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(sample_msg* other);

  // implements Message ----------------------------------------------

  sample_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const sample_msg& from);
  void MergeFrom(const sample_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string operators = 1;
  inline bool has_operators() const;
  inline void clear_operators();
  static const int kOperatorsFieldNumber = 1;
  inline const ::std::string& operators() const;
  inline void set_operators(const ::std::string& value);
  inline void set_operators(const char* value);
  inline void set_operators(const char* value, size_t size);
  inline ::std::string* mutable_operators();
  inline ::std::string* release_operators();
  inline void set_allocated_operators(::std::string* operators);

  // required string mac = 2;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 2;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // repeated .proanalytics.sample sample_list = 3;
  inline int sample_list_size() const;
  inline void clear_sample_list();
  static const int kSampleListFieldNumber = 3;
  inline const ::proanalytics::sample& sample_list(int index) const;
  inline ::proanalytics::sample* mutable_sample_list(int index);
  inline ::proanalytics::sample* add_sample_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proanalytics::sample >&
      sample_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proanalytics::sample >*
      mutable_sample_list();

  // @@protoc_insertion_point(class_scope:proanalytics.sample_msg)
 private:
  inline void set_has_operators();
  inline void clear_has_operators();
  inline void set_has_mac();
  inline void clear_has_mac();

  ::std::string* operators_;
  ::std::string* mac_;
  ::google::protobuf::RepeatedPtrField< ::proanalytics::sample > sample_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_pa_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_pa_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static sample_msg* default_instance_;
};
// -------------------------------------------------------------------

class control_msg : public ::google::protobuf::MessageLite {
 public:
  control_msg();
  virtual ~control_msg();

  control_msg(const control_msg& from);

  inline control_msg& operator=(const control_msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const control_msg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const control_msg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(control_msg* other);

  // implements Message ----------------------------------------------

  control_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const control_msg& from);
  void MergeFrom(const control_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proanalytics.control_type type = 1 [default = CONTROL_UNKNOW];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proanalytics::control_type type() const;
  inline void set_type(::proanalytics::control_type value);

  // optional uint32 interval = 2;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proanalytics.control_msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_interval();
  inline void clear_has_interval();

  int type_;
  ::google::protobuf::uint32 interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_pa_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_pa_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_pa_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static control_msg* default_instance_;
};
// ===================================================================


// ===================================================================

// init_msg

// required uint64 curr_time = 1;
inline bool init_msg::has_curr_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void init_msg::set_has_curr_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void init_msg::clear_has_curr_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void init_msg::clear_curr_time() {
  curr_time_ = GOOGLE_ULONGLONG(0);
  clear_has_curr_time();
}
inline ::google::protobuf::uint64 init_msg::curr_time() const {
  return curr_time_;
}
inline void init_msg::set_curr_time(::google::protobuf::uint64 value) {
  set_has_curr_time();
  curr_time_ = value;
}

// required uint32 sample_interval = 2;
inline bool init_msg::has_sample_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void init_msg::set_has_sample_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void init_msg::clear_has_sample_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void init_msg::clear_sample_interval() {
  sample_interval_ = 0u;
  clear_has_sample_interval();
}
inline ::google::protobuf::uint32 init_msg::sample_interval() const {
  return sample_interval_;
}
inline void init_msg::set_sample_interval(::google::protobuf::uint32 value) {
  set_has_sample_interval();
  sample_interval_ = value;
}

// required uint32 packet_sample_count = 3;
inline bool init_msg::has_packet_sample_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void init_msg::set_has_packet_sample_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void init_msg::clear_has_packet_sample_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void init_msg::clear_packet_sample_count() {
  packet_sample_count_ = 0u;
  clear_has_packet_sample_count();
}
inline ::google::protobuf::uint32 init_msg::packet_sample_count() const {
  return packet_sample_count_;
}
inline void init_msg::set_packet_sample_count(::google::protobuf::uint32 value) {
  set_has_packet_sample_count();
  packet_sample_count_ = value;
}

// -------------------------------------------------------------------

// sample

// required string type = 1;
inline bool sample::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sample::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sample::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sample::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& sample::type() const {
  return *type_;
}
inline void sample::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void sample::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void sample::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sample::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* sample::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sample::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string channel_link = 2;
inline bool sample::has_channel_link() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sample::set_has_channel_link() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sample::clear_has_channel_link() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sample::clear_channel_link() {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    channel_link_->clear();
  }
  clear_has_channel_link();
}
inline const ::std::string& sample::channel_link() const {
  return *channel_link_;
}
inline void sample::set_channel_link(const ::std::string& value) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(value);
}
inline void sample::set_channel_link(const char* value) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(value);
}
inline void sample::set_channel_link(const char* value, size_t size) {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  channel_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sample::mutable_channel_link() {
  set_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    channel_link_ = new ::std::string;
  }
  return channel_link_;
}
inline ::std::string* sample::release_channel_link() {
  clear_has_channel_link();
  if (channel_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_link_;
    channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sample::set_allocated_channel_link(::std::string* channel_link) {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_link_;
  }
  if (channel_link) {
    set_has_channel_link();
    channel_link_ = channel_link;
  } else {
    clear_has_channel_link();
    channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel_name = 3;
inline bool sample::has_channel_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sample::set_has_channel_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sample::clear_has_channel_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sample::clear_channel_name() {
  if (channel_name_ != &::google::protobuf::internal::kEmptyString) {
    channel_name_->clear();
  }
  clear_has_channel_name();
}
inline const ::std::string& sample::channel_name() const {
  return *channel_name_;
}
inline void sample::set_channel_name(const ::std::string& value) {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::kEmptyString) {
    channel_name_ = new ::std::string;
  }
  channel_name_->assign(value);
}
inline void sample::set_channel_name(const char* value) {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::kEmptyString) {
    channel_name_ = new ::std::string;
  }
  channel_name_->assign(value);
}
inline void sample::set_channel_name(const char* value, size_t size) {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::kEmptyString) {
    channel_name_ = new ::std::string;
  }
  channel_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sample::mutable_channel_name() {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::kEmptyString) {
    channel_name_ = new ::std::string;
  }
  return channel_name_;
}
inline ::std::string* sample::release_channel_name() {
  clear_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_name_;
    channel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sample::set_allocated_channel_name(::std::string* channel_name) {
  if (channel_name_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_name_;
  }
  if (channel_name) {
    set_has_channel_name();
    channel_name_ = channel_name;
  } else {
    clear_has_channel_name();
    channel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 time_swamp = 4;
inline bool sample::has_time_swamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sample::set_has_time_swamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sample::clear_has_time_swamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sample::clear_time_swamp() {
  time_swamp_ = GOOGLE_ULONGLONG(0);
  clear_has_time_swamp();
}
inline ::google::protobuf::uint64 sample::time_swamp() const {
  return time_swamp_;
}
inline void sample::set_time_swamp(::google::protobuf::uint64 value) {
  set_has_time_swamp();
  time_swamp_ = value;
}

// -------------------------------------------------------------------

// sample_msg

// required string operators = 1;
inline bool sample_msg::has_operators() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sample_msg::set_has_operators() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sample_msg::clear_has_operators() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sample_msg::clear_operators() {
  if (operators_ != &::google::protobuf::internal::kEmptyString) {
    operators_->clear();
  }
  clear_has_operators();
}
inline const ::std::string& sample_msg::operators() const {
  return *operators_;
}
inline void sample_msg::set_operators(const ::std::string& value) {
  set_has_operators();
  if (operators_ == &::google::protobuf::internal::kEmptyString) {
    operators_ = new ::std::string;
  }
  operators_->assign(value);
}
inline void sample_msg::set_operators(const char* value) {
  set_has_operators();
  if (operators_ == &::google::protobuf::internal::kEmptyString) {
    operators_ = new ::std::string;
  }
  operators_->assign(value);
}
inline void sample_msg::set_operators(const char* value, size_t size) {
  set_has_operators();
  if (operators_ == &::google::protobuf::internal::kEmptyString) {
    operators_ = new ::std::string;
  }
  operators_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sample_msg::mutable_operators() {
  set_has_operators();
  if (operators_ == &::google::protobuf::internal::kEmptyString) {
    operators_ = new ::std::string;
  }
  return operators_;
}
inline ::std::string* sample_msg::release_operators() {
  clear_has_operators();
  if (operators_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operators_;
    operators_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sample_msg::set_allocated_operators(::std::string* operators) {
  if (operators_ != &::google::protobuf::internal::kEmptyString) {
    delete operators_;
  }
  if (operators) {
    set_has_operators();
    operators_ = operators;
  } else {
    clear_has_operators();
    operators_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string mac = 2;
inline bool sample_msg::has_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sample_msg::set_has_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sample_msg::clear_has_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sample_msg::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& sample_msg::mac() const {
  return *mac_;
}
inline void sample_msg::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void sample_msg::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void sample_msg::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sample_msg::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* sample_msg::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sample_msg::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proanalytics.sample sample_list = 3;
inline int sample_msg::sample_list_size() const {
  return sample_list_.size();
}
inline void sample_msg::clear_sample_list() {
  sample_list_.Clear();
}
inline const ::proanalytics::sample& sample_msg::sample_list(int index) const {
  return sample_list_.Get(index);
}
inline ::proanalytics::sample* sample_msg::mutable_sample_list(int index) {
  return sample_list_.Mutable(index);
}
inline ::proanalytics::sample* sample_msg::add_sample_list() {
  return sample_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proanalytics::sample >&
sample_msg::sample_list() const {
  return sample_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proanalytics::sample >*
sample_msg::mutable_sample_list() {
  return &sample_list_;
}

// -------------------------------------------------------------------

// control_msg

// required .proanalytics.control_type type = 1 [default = CONTROL_UNKNOW];
inline bool control_msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void control_msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void control_msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void control_msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proanalytics::control_type control_msg::type() const {
  return static_cast< ::proanalytics::control_type >(type_);
}
inline void control_msg::set_type(::proanalytics::control_type value) {
  assert(::proanalytics::control_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 interval = 2;
inline bool control_msg::has_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void control_msg::set_has_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void control_msg::clear_has_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void control_msg::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 control_msg::interval() const {
  return interval_;
}
inline void control_msg::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proanalytics

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pa_5fmessage_2eproto__INCLUDED
