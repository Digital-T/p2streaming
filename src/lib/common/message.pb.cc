// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace p2message {

void protobuf_ShutdownFile_message_2eproto() {
  delete peer_info::default_instance_;
  delete buffermap_info::default_instance_;
  delete piece_info::default_instance_;
  delete live_channel_info::default_instance_;
  delete vod_channel_info::default_instance_;
  delete s2ts_channel_report_msg::default_instance_;
  delete s2ts_create_channel_msg::default_instance_;
  delete s2ts_channel_status_req::default_instance_;
  delete ts2s_channel_status::default_instance_;
  delete ts2p_challenge_msg::default_instance_;
  delete p2ts_login_msg::default_instance_;
  delete ts2p_login_reply_msg::default_instance_;
  delete p2ts_peer_request_msg::default_instance_;
  delete ts2p_peer_reply_msg::default_instance_;
  delete p2ts_logout_msg::default_instance_;
  delete p2ts_failure_report_msg::default_instance_;
  delete p2ts_local_info_report_msg::default_instance_;
  delete ts2p_kickout_msg::default_instance_;
  delete p2ts_kickout_msg::default_instance_;
  delete ts2p_room_info_msg::default_instance_;
  delete p2ts_ban_msg::default_instance_;
  delete p2ts_quality_report_msg::default_instance_;
  delete cached_channel_info::default_instance_;
  delete p2ts_cache_announce_msg::default_instance_;
  delete s2p_recommend_seed_msg::default_instance_;
  delete s2p_piece_notify::default_instance_;
  delete p2s_info_report_msg::default_instance_;
  delete p2p_handshake_msg::default_instance_;
  delete p2p_buffermap_request_msg::default_instance_;
  delete p2p_neighbor_table_exchange::default_instance_;
  delete p2p_supervise_request_msg::default_instance_;
  delete relay_msg::default_instance_;
  delete broadcast_msg::default_instance_;
  delete buffermap_exchange_msg::default_instance_;
  delete join_channel_msg::default_instance_;
  delete media_request_msg::default_instance_;
  delete media_subscription_msg::default_instance_;
  delete punch_request_msg::default_instance_;
  delete media_sent_confirm_msg::default_instance_;
  delete no_piece_msg::default_instance_;
  delete time_server_2_tracker::default_instance_;
  delete ctrl2m_create_channel_msg::default_instance_;
  delete ctrl2s_create_channel_msg::default_instance_;
  delete mds_cmd_msg::default_instance_;
  delete c2s_cmd_reply_msg::default_instance_;
  delete c2s_auth_msg::default_instance_;
  delete alive_alarm_report_msg::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_message_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_message_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  peer_info::default_instance_ = new peer_info();
  buffermap_info::default_instance_ = new buffermap_info();
  piece_info::default_instance_ = new piece_info();
  live_channel_info::default_instance_ = new live_channel_info();
  vod_channel_info::default_instance_ = new vod_channel_info();
  s2ts_channel_report_msg::default_instance_ = new s2ts_channel_report_msg();
  s2ts_create_channel_msg::default_instance_ = new s2ts_create_channel_msg();
  s2ts_channel_status_req::default_instance_ = new s2ts_channel_status_req();
  ts2s_channel_status::default_instance_ = new ts2s_channel_status();
  ts2p_challenge_msg::default_instance_ = new ts2p_challenge_msg();
  p2ts_login_msg::default_instance_ = new p2ts_login_msg();
  ts2p_login_reply_msg::default_instance_ = new ts2p_login_reply_msg();
  p2ts_peer_request_msg::default_instance_ = new p2ts_peer_request_msg();
  ts2p_peer_reply_msg::default_instance_ = new ts2p_peer_reply_msg();
  p2ts_logout_msg::default_instance_ = new p2ts_logout_msg();
  p2ts_failure_report_msg::default_instance_ = new p2ts_failure_report_msg();
  p2ts_local_info_report_msg::default_instance_ = new p2ts_local_info_report_msg();
  ts2p_kickout_msg::default_instance_ = new ts2p_kickout_msg();
  p2ts_kickout_msg::default_instance_ = new p2ts_kickout_msg();
  ts2p_room_info_msg::default_instance_ = new ts2p_room_info_msg();
  p2ts_ban_msg::default_instance_ = new p2ts_ban_msg();
  p2ts_quality_report_msg::default_instance_ = new p2ts_quality_report_msg();
  cached_channel_info::default_instance_ = new cached_channel_info();
  p2ts_cache_announce_msg::default_instance_ = new p2ts_cache_announce_msg();
  s2p_recommend_seed_msg::default_instance_ = new s2p_recommend_seed_msg();
  s2p_piece_notify::default_instance_ = new s2p_piece_notify();
  p2s_info_report_msg::default_instance_ = new p2s_info_report_msg();
  p2p_handshake_msg::default_instance_ = new p2p_handshake_msg();
  p2p_buffermap_request_msg::default_instance_ = new p2p_buffermap_request_msg();
  p2p_neighbor_table_exchange::default_instance_ = new p2p_neighbor_table_exchange();
  p2p_supervise_request_msg::default_instance_ = new p2p_supervise_request_msg();
  relay_msg::default_instance_ = new relay_msg();
  broadcast_msg::default_instance_ = new broadcast_msg();
  buffermap_exchange_msg::default_instance_ = new buffermap_exchange_msg();
  join_channel_msg::default_instance_ = new join_channel_msg();
  media_request_msg::default_instance_ = new media_request_msg();
  media_subscription_msg::default_instance_ = new media_subscription_msg();
  punch_request_msg::default_instance_ = new punch_request_msg();
  media_sent_confirm_msg::default_instance_ = new media_sent_confirm_msg();
  no_piece_msg::default_instance_ = new no_piece_msg();
  time_server_2_tracker::default_instance_ = new time_server_2_tracker();
  ctrl2m_create_channel_msg::default_instance_ = new ctrl2m_create_channel_msg();
  ctrl2s_create_channel_msg::default_instance_ = new ctrl2s_create_channel_msg();
  mds_cmd_msg::default_instance_ = new mds_cmd_msg();
  c2s_cmd_reply_msg::default_instance_ = new c2s_cmd_reply_msg();
  c2s_auth_msg::default_instance_ = new c2s_auth_msg();
  alive_alarm_report_msg::default_instance_ = new alive_alarm_report_msg();
  peer_info::default_instance_->InitAsDefaultInstance();
  buffermap_info::default_instance_->InitAsDefaultInstance();
  piece_info::default_instance_->InitAsDefaultInstance();
  live_channel_info::default_instance_->InitAsDefaultInstance();
  vod_channel_info::default_instance_->InitAsDefaultInstance();
  s2ts_channel_report_msg::default_instance_->InitAsDefaultInstance();
  s2ts_create_channel_msg::default_instance_->InitAsDefaultInstance();
  s2ts_channel_status_req::default_instance_->InitAsDefaultInstance();
  ts2s_channel_status::default_instance_->InitAsDefaultInstance();
  ts2p_challenge_msg::default_instance_->InitAsDefaultInstance();
  p2ts_login_msg::default_instance_->InitAsDefaultInstance();
  ts2p_login_reply_msg::default_instance_->InitAsDefaultInstance();
  p2ts_peer_request_msg::default_instance_->InitAsDefaultInstance();
  ts2p_peer_reply_msg::default_instance_->InitAsDefaultInstance();
  p2ts_logout_msg::default_instance_->InitAsDefaultInstance();
  p2ts_failure_report_msg::default_instance_->InitAsDefaultInstance();
  p2ts_local_info_report_msg::default_instance_->InitAsDefaultInstance();
  ts2p_kickout_msg::default_instance_->InitAsDefaultInstance();
  p2ts_kickout_msg::default_instance_->InitAsDefaultInstance();
  ts2p_room_info_msg::default_instance_->InitAsDefaultInstance();
  p2ts_ban_msg::default_instance_->InitAsDefaultInstance();
  p2ts_quality_report_msg::default_instance_->InitAsDefaultInstance();
  cached_channel_info::default_instance_->InitAsDefaultInstance();
  p2ts_cache_announce_msg::default_instance_->InitAsDefaultInstance();
  s2p_recommend_seed_msg::default_instance_->InitAsDefaultInstance();
  s2p_piece_notify::default_instance_->InitAsDefaultInstance();
  p2s_info_report_msg::default_instance_->InitAsDefaultInstance();
  p2p_handshake_msg::default_instance_->InitAsDefaultInstance();
  p2p_buffermap_request_msg::default_instance_->InitAsDefaultInstance();
  p2p_neighbor_table_exchange::default_instance_->InitAsDefaultInstance();
  p2p_supervise_request_msg::default_instance_->InitAsDefaultInstance();
  relay_msg::default_instance_->InitAsDefaultInstance();
  broadcast_msg::default_instance_->InitAsDefaultInstance();
  buffermap_exchange_msg::default_instance_->InitAsDefaultInstance();
  join_channel_msg::default_instance_->InitAsDefaultInstance();
  media_request_msg::default_instance_->InitAsDefaultInstance();
  media_subscription_msg::default_instance_->InitAsDefaultInstance();
  punch_request_msg::default_instance_->InitAsDefaultInstance();
  media_sent_confirm_msg::default_instance_->InitAsDefaultInstance();
  no_piece_msg::default_instance_->InitAsDefaultInstance();
  time_server_2_tracker::default_instance_->InitAsDefaultInstance();
  ctrl2m_create_channel_msg::default_instance_->InitAsDefaultInstance();
  ctrl2s_create_channel_msg::default_instance_->InitAsDefaultInstance();
  mds_cmd_msg::default_instance_->InitAsDefaultInstance();
  c2s_cmd_reply_msg::default_instance_->InitAsDefaultInstance();
  c2s_auth_msg::default_instance_->InitAsDefaultInstance();
  alive_alarm_report_msg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_message_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_message_2eproto_once_);
void protobuf_AddDesc_message_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_message_2eproto_once_, 
                 &protobuf_AddDesc_message_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_message_2eproto {
  StaticDescriptorInitializer_message_2eproto() {
    protobuf_AddDesc_message_2eproto();
  }
} static_descriptor_initializer_message_2eproto_;
#endif
bool peer_nat_type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool peer_type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int peer_info::kPeerIdFieldNumber;
const int peer_info::kNatTypeFieldNumber;
const int peer_info::kUploadCapacityFieldNumber;
const int peer_info::kPeerTypeFieldNumber;
const int peer_info::kJoinTimeFieldNumber;
const int peer_info::kInfoVersionFieldNumber;
const int peer_info::kExternalIpFieldNumber;
const int peer_info::kExternalUdpPortFieldNumber;
const int peer_info::kExternalTcpPortFieldNumber;
const int peer_info::kInternalIpFieldNumber;
const int peer_info::kInternalUdpPortFieldNumber;
const int peer_info::kInternalTcpPortFieldNumber;
const int peer_info::kOtherInternalIpFieldNumber;
const int peer_info::kRelativePlayingPointFieldNumber;
const int peer_info::kPlayingQualityFieldNumber;
const int peer_info::kGlobalRemoteToLocalLostRateFieldNumber;
const int peer_info::kUserInfoFieldNumber;
const int peer_info::kVersionFieldNumber;
const int peer_info::kCacheServerIpportFieldNumber;
#endif  // !_MSC_VER

peer_info::peer_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void peer_info::InitAsDefaultInstance() {
}

peer_info::peer_info(const peer_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void peer_info::SharedCtor() {
  _cached_size_ = 0;
  peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nat_type_ = 0;
  upload_capacity_ = 64000u;
  peer_type_ = 3;
  join_time_ = GOOGLE_ULONGLONG(0);
  info_version_ = 0u;
  external_ip_ = 0u;
  external_udp_port_ = 0u;
  external_tcp_port_ = 0u;
  internal_ip_ = 0u;
  internal_udp_port_ = 0u;
  internal_tcp_port_ = 0u;
  relative_playing_point_ = -1;
  playing_quality_ = 0;
  global_remote_to_local_lost_rate_ = 0;
  user_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

peer_info::~peer_info() {
  SharedDtor();
}

void peer_info::SharedDtor() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (user_info_ != &::google::protobuf::internal::kEmptyString) {
    delete user_info_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void peer_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const peer_info& peer_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

peer_info* peer_info::default_instance_ = NULL;

peer_info* peer_info::New() const {
  return new peer_info;
}

void peer_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_peer_id()) {
      if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
        peer_id_->clear();
      }
    }
    nat_type_ = 0;
    upload_capacity_ = 64000u;
    peer_type_ = 3;
    join_time_ = GOOGLE_ULONGLONG(0);
    info_version_ = 0u;
    external_ip_ = 0u;
    external_udp_port_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    external_tcp_port_ = 0u;
    internal_ip_ = 0u;
    internal_udp_port_ = 0u;
    internal_tcp_port_ = 0u;
    relative_playing_point_ = -1;
    playing_quality_ = 0;
    global_remote_to_local_lost_rate_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_user_info()) {
      if (user_info_ != &::google::protobuf::internal::kEmptyString) {
        user_info_->clear();
      }
    }
    version_ = 1;
  }
  other_internal_ip_.Clear();
  cache_server_ipport_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool peer_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes peer_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nat_type;
        break;
      }

      // required .p2message.peer_nat_type nat_type = 2 [default = NAT_UNKNOWN];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nat_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2message::peer_nat_type_IsValid(value)) {
            set_nat_type(static_cast< ::p2message::peer_nat_type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_upload_capacity;
        break;
      }

      // required uint32 upload_capacity = 3 [default = 64000];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_upload_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_capacity_)));
          set_has_upload_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_peer_type;
        break;
      }

      // required .p2message.peer_type peer_type = 4 [default = NORMAL_PEER];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_peer_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2message::peer_type_IsValid(value)) {
            set_peer_type(static_cast< ::p2message::peer_type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_join_time;
        break;
      }

      // required uint64 join_time = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_join_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &join_time_)));
          set_has_join_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_info_version;
        break;
      }

      // required uint32 info_version = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_info_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &info_version_)));
          set_has_info_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_external_ip;
        break;
      }

      // required uint32 external_ip = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_external_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &external_ip_)));
          set_has_external_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_external_udp_port;
        break;
      }

      // required uint32 external_udp_port = 8 [default = 0];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_external_udp_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &external_udp_port_)));
          set_has_external_udp_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_external_tcp_port;
        break;
      }

      // required uint32 external_tcp_port = 9 [default = 0];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_external_tcp_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &external_tcp_port_)));
          set_has_external_tcp_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_internal_ip;
        break;
      }

      // required uint32 internal_ip = 10 [default = 0];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_internal_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &internal_ip_)));
          set_has_internal_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_internal_udp_port;
        break;
      }

      // required uint32 internal_udp_port = 11 [default = 0];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_internal_udp_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &internal_udp_port_)));
          set_has_internal_udp_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_internal_tcp_port;
        break;
      }

      // required uint32 internal_tcp_port = 12 [default = 0];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_internal_tcp_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &internal_tcp_port_)));
          set_has_internal_tcp_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_other_internal_ip;
        break;
      }

      // repeated uint32 other_internal_ip = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_other_internal_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 104, input, this->mutable_other_internal_ip())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_other_internal_ip())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_other_internal_ip;
        if (input->ExpectTag(112)) goto parse_relative_playing_point;
        break;
      }

      // required int32 relative_playing_point = 14 [default = -1];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_relative_playing_point:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &relative_playing_point_)));
          set_has_relative_playing_point();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_playing_quality;
        break;
      }

      // optional float playing_quality = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_playing_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &playing_quality_)));
          set_has_playing_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(133)) goto parse_global_remote_to_local_lost_rate;
        break;
      }

      // optional float global_remote_to_local_lost_rate = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_global_remote_to_local_lost_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &global_remote_to_local_lost_rate_)));
          set_has_global_remote_to_local_lost_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_user_info;
        break;
      }

      // optional bytes user_info = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(149)) goto parse_version;
        break;
      }

      // optional float version = 18 [default = 1];
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_cache_server_ipport;
        break;
      }

      // repeated bytes cache_server_ipport = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cache_server_ipport:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_cache_server_ipport()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_cache_server_ipport;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void peer_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes peer_id = 1;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->peer_id(), output);
  }

  // required .p2message.peer_nat_type nat_type = 2 [default = NAT_UNKNOWN];
  if (has_nat_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->nat_type(), output);
  }

  // required uint32 upload_capacity = 3 [default = 64000];
  if (has_upload_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->upload_capacity(), output);
  }

  // required .p2message.peer_type peer_type = 4 [default = NORMAL_PEER];
  if (has_peer_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->peer_type(), output);
  }

  // required uint64 join_time = 5 [default = 0];
  if (has_join_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->join_time(), output);
  }

  // required uint32 info_version = 6 [default = 0];
  if (has_info_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->info_version(), output);
  }

  // required uint32 external_ip = 7 [default = 0];
  if (has_external_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->external_ip(), output);
  }

  // required uint32 external_udp_port = 8 [default = 0];
  if (has_external_udp_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->external_udp_port(), output);
  }

  // required uint32 external_tcp_port = 9 [default = 0];
  if (has_external_tcp_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->external_tcp_port(), output);
  }

  // required uint32 internal_ip = 10 [default = 0];
  if (has_internal_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->internal_ip(), output);
  }

  // required uint32 internal_udp_port = 11 [default = 0];
  if (has_internal_udp_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->internal_udp_port(), output);
  }

  // required uint32 internal_tcp_port = 12 [default = 0];
  if (has_internal_tcp_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->internal_tcp_port(), output);
  }

  // repeated uint32 other_internal_ip = 13;
  for (int i = 0; i < this->other_internal_ip_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      13, this->other_internal_ip(i), output);
  }

  // required int32 relative_playing_point = 14 [default = -1];
  if (has_relative_playing_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->relative_playing_point(), output);
  }

  // optional float playing_quality = 15;
  if (has_playing_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->playing_quality(), output);
  }

  // optional float global_remote_to_local_lost_rate = 16;
  if (has_global_remote_to_local_lost_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->global_remote_to_local_lost_rate(), output);
  }

  // optional bytes user_info = 17;
  if (has_user_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      17, this->user_info(), output);
  }

  // optional float version = 18 [default = 1];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(18, this->version(), output);
  }

  // repeated bytes cache_server_ipport = 19;
  for (int i = 0; i < this->cache_server_ipport_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      19, this->cache_server_ipport(i), output);
  }

}

int peer_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes peer_id = 1;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->peer_id());
    }

    // required .p2message.peer_nat_type nat_type = 2 [default = NAT_UNKNOWN];
    if (has_nat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->nat_type());
    }

    // required uint32 upload_capacity = 3 [default = 64000];
    if (has_upload_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_capacity());
    }

    // required .p2message.peer_type peer_type = 4 [default = NORMAL_PEER];
    if (has_peer_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->peer_type());
    }

    // required uint64 join_time = 5 [default = 0];
    if (has_join_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->join_time());
    }

    // required uint32 info_version = 6 [default = 0];
    if (has_info_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->info_version());
    }

    // required uint32 external_ip = 7 [default = 0];
    if (has_external_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->external_ip());
    }

    // required uint32 external_udp_port = 8 [default = 0];
    if (has_external_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->external_udp_port());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 external_tcp_port = 9 [default = 0];
    if (has_external_tcp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->external_tcp_port());
    }

    // required uint32 internal_ip = 10 [default = 0];
    if (has_internal_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->internal_ip());
    }

    // required uint32 internal_udp_port = 11 [default = 0];
    if (has_internal_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->internal_udp_port());
    }

    // required uint32 internal_tcp_port = 12 [default = 0];
    if (has_internal_tcp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->internal_tcp_port());
    }

    // required int32 relative_playing_point = 14 [default = -1];
    if (has_relative_playing_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->relative_playing_point());
    }

    // optional float playing_quality = 15;
    if (has_playing_quality()) {
      total_size += 1 + 4;
    }

    // optional float global_remote_to_local_lost_rate = 16;
    if (has_global_remote_to_local_lost_rate()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bytes user_info = 17;
    if (has_user_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_info());
    }

    // optional float version = 18 [default = 1];
    if (has_version()) {
      total_size += 2 + 4;
    }

  }
  // repeated uint32 other_internal_ip = 13;
  {
    int data_size = 0;
    for (int i = 0; i < this->other_internal_ip_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->other_internal_ip(i));
    }
    total_size += 1 * this->other_internal_ip_size() + data_size;
  }

  // repeated bytes cache_server_ipport = 19;
  total_size += 2 * this->cache_server_ipport_size();
  for (int i = 0; i < this->cache_server_ipport_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->cache_server_ipport(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void peer_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const peer_info*>(&from));
}

void peer_info::MergeFrom(const peer_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  other_internal_ip_.MergeFrom(from.other_internal_ip_);
  cache_server_ipport_.MergeFrom(from.cache_server_ipport_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_nat_type()) {
      set_nat_type(from.nat_type());
    }
    if (from.has_upload_capacity()) {
      set_upload_capacity(from.upload_capacity());
    }
    if (from.has_peer_type()) {
      set_peer_type(from.peer_type());
    }
    if (from.has_join_time()) {
      set_join_time(from.join_time());
    }
    if (from.has_info_version()) {
      set_info_version(from.info_version());
    }
    if (from.has_external_ip()) {
      set_external_ip(from.external_ip());
    }
    if (from.has_external_udp_port()) {
      set_external_udp_port(from.external_udp_port());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_external_tcp_port()) {
      set_external_tcp_port(from.external_tcp_port());
    }
    if (from.has_internal_ip()) {
      set_internal_ip(from.internal_ip());
    }
    if (from.has_internal_udp_port()) {
      set_internal_udp_port(from.internal_udp_port());
    }
    if (from.has_internal_tcp_port()) {
      set_internal_tcp_port(from.internal_tcp_port());
    }
    if (from.has_relative_playing_point()) {
      set_relative_playing_point(from.relative_playing_point());
    }
    if (from.has_playing_quality()) {
      set_playing_quality(from.playing_quality());
    }
    if (from.has_global_remote_to_local_lost_rate()) {
      set_global_remote_to_local_lost_rate(from.global_remote_to_local_lost_rate());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_user_info()) {
      set_user_info(from.user_info());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
}

void peer_info::CopyFrom(const peer_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool peer_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00002fff) != 0x00002fff) return false;

  return true;
}

void peer_info::Swap(peer_info* other) {
  if (other != this) {
    std::swap(peer_id_, other->peer_id_);
    std::swap(nat_type_, other->nat_type_);
    std::swap(upload_capacity_, other->upload_capacity_);
    std::swap(peer_type_, other->peer_type_);
    std::swap(join_time_, other->join_time_);
    std::swap(info_version_, other->info_version_);
    std::swap(external_ip_, other->external_ip_);
    std::swap(external_udp_port_, other->external_udp_port_);
    std::swap(external_tcp_port_, other->external_tcp_port_);
    std::swap(internal_ip_, other->internal_ip_);
    std::swap(internal_udp_port_, other->internal_udp_port_);
    std::swap(internal_tcp_port_, other->internal_tcp_port_);
    other_internal_ip_.Swap(&other->other_internal_ip_);
    std::swap(relative_playing_point_, other->relative_playing_point_);
    std::swap(playing_quality_, other->playing_quality_);
    std::swap(global_remote_to_local_lost_rate_, other->global_remote_to_local_lost_rate_);
    std::swap(user_info_, other->user_info_);
    std::swap(version_, other->version_);
    cache_server_ipport_.Swap(&other->cache_server_ipport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string peer_info::GetTypeName() const {
  return "p2message.peer_info";
}


// ===================================================================

#ifndef _MSC_VER
const int buffermap_info::kRecentSeqnoFieldNumber;
const int buffermap_info::kBigestSeqnoIKnowFieldNumber;
const int buffermap_info::kSmallestSeqnoIHaveFieldNumber;
const int buffermap_info::kFirstSeqnoInBitsetFieldNumber;
const int buffermap_info::kErasedSeqBeginFieldNumber;
const int buffermap_info::kErasedSeqEndFieldNumber;
const int buffermap_info::kBitsetFieldNumber;
const int buffermap_info::kIframeSeqnoFieldNumber;
#endif  // !_MSC_VER

buffermap_info::buffermap_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void buffermap_info::InitAsDefaultInstance() {
}

buffermap_info::buffermap_info(const buffermap_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void buffermap_info::SharedCtor() {
  _cached_size_ = 0;
  bigest_seqno_i_know_ = 0u;
  smallest_seqno_i_have_ = 0u;
  first_seqno_in_bitset_ = 0u;
  erased_seq_begin_ = 0u;
  erased_seq_end_ = 0u;
  bitset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

buffermap_info::~buffermap_info() {
  SharedDtor();
}

void buffermap_info::SharedDtor() {
  if (bitset_ != &::google::protobuf::internal::kEmptyString) {
    delete bitset_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void buffermap_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const buffermap_info& buffermap_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

buffermap_info* buffermap_info::default_instance_ = NULL;

buffermap_info* buffermap_info::New() const {
  return new buffermap_info;
}

void buffermap_info::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    bigest_seqno_i_know_ = 0u;
    smallest_seqno_i_have_ = 0u;
    first_seqno_in_bitset_ = 0u;
    erased_seq_begin_ = 0u;
    erased_seq_end_ = 0u;
    if (has_bitset()) {
      if (bitset_ != &::google::protobuf::internal::kEmptyString) {
        bitset_->clear();
      }
    }
  }
  recent_seqno_.Clear();
  iframe_seqno_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool buffermap_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated fixed32 recent_seqno = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_recent_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 13, input, this->mutable_recent_seqno())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_recent_seqno())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(13)) goto parse_recent_seqno;
        if (input->ExpectTag(21)) goto parse_bigest_seqno_i_know;
        break;
      }

      // optional fixed32 bigest_seqno_i_know = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_bigest_seqno_i_know:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &bigest_seqno_i_know_)));
          set_has_bigest_seqno_i_know();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_smallest_seqno_i_have;
        break;
      }

      // optional fixed32 smallest_seqno_i_have = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_smallest_seqno_i_have:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &smallest_seqno_i_have_)));
          set_has_smallest_seqno_i_have();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_first_seqno_in_bitset;
        break;
      }

      // optional fixed32 first_seqno_in_bitset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_first_seqno_in_bitset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &first_seqno_in_bitset_)));
          set_has_first_seqno_in_bitset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_erased_seq_begin;
        break;
      }

      // optional fixed32 erased_seq_begin = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_erased_seq_begin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &erased_seq_begin_)));
          set_has_erased_seq_begin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_erased_seq_end;
        break;
      }

      // optional fixed32 erased_seq_end = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_erased_seq_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &erased_seq_end_)));
          set_has_erased_seq_end();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_bitset;
        break;
      }

      // optional bytes bitset = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bitset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bitset()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_iframe_seqno;
        break;
      }

      // repeated fixed32 iframe_seqno = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_iframe_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 69, input, this->mutable_iframe_seqno())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_iframe_seqno())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_iframe_seqno;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void buffermap_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated fixed32 recent_seqno = 1;
  for (int i = 0; i < this->recent_seqno_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      1, this->recent_seqno(i), output);
  }

  // optional fixed32 bigest_seqno_i_know = 2;
  if (has_bigest_seqno_i_know()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->bigest_seqno_i_know(), output);
  }

  // optional fixed32 smallest_seqno_i_have = 3;
  if (has_smallest_seqno_i_have()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->smallest_seqno_i_have(), output);
  }

  // optional fixed32 first_seqno_in_bitset = 4;
  if (has_first_seqno_in_bitset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->first_seqno_in_bitset(), output);
  }

  // optional fixed32 erased_seq_begin = 5;
  if (has_erased_seq_begin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(5, this->erased_seq_begin(), output);
  }

  // optional fixed32 erased_seq_end = 6;
  if (has_erased_seq_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(6, this->erased_seq_end(), output);
  }

  // optional bytes bitset = 7;
  if (has_bitset()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->bitset(), output);
  }

  // repeated fixed32 iframe_seqno = 8;
  for (int i = 0; i < this->iframe_seqno_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      8, this->iframe_seqno(i), output);
  }

}

int buffermap_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional fixed32 bigest_seqno_i_know = 2;
    if (has_bigest_seqno_i_know()) {
      total_size += 1 + 4;
    }

    // optional fixed32 smallest_seqno_i_have = 3;
    if (has_smallest_seqno_i_have()) {
      total_size += 1 + 4;
    }

    // optional fixed32 first_seqno_in_bitset = 4;
    if (has_first_seqno_in_bitset()) {
      total_size += 1 + 4;
    }

    // optional fixed32 erased_seq_begin = 5;
    if (has_erased_seq_begin()) {
      total_size += 1 + 4;
    }

    // optional fixed32 erased_seq_end = 6;
    if (has_erased_seq_end()) {
      total_size += 1 + 4;
    }

    // optional bytes bitset = 7;
    if (has_bitset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bitset());
    }

  }
  // repeated fixed32 recent_seqno = 1;
  {
    int data_size = 0;
    data_size = 4 * this->recent_seqno_size();
    total_size += 1 * this->recent_seqno_size() + data_size;
  }

  // repeated fixed32 iframe_seqno = 8;
  {
    int data_size = 0;
    data_size = 4 * this->iframe_seqno_size();
    total_size += 1 * this->iframe_seqno_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void buffermap_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const buffermap_info*>(&from));
}

void buffermap_info::MergeFrom(const buffermap_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  recent_seqno_.MergeFrom(from.recent_seqno_);
  iframe_seqno_.MergeFrom(from.iframe_seqno_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_bigest_seqno_i_know()) {
      set_bigest_seqno_i_know(from.bigest_seqno_i_know());
    }
    if (from.has_smallest_seqno_i_have()) {
      set_smallest_seqno_i_have(from.smallest_seqno_i_have());
    }
    if (from.has_first_seqno_in_bitset()) {
      set_first_seqno_in_bitset(from.first_seqno_in_bitset());
    }
    if (from.has_erased_seq_begin()) {
      set_erased_seq_begin(from.erased_seq_begin());
    }
    if (from.has_erased_seq_end()) {
      set_erased_seq_end(from.erased_seq_end());
    }
    if (from.has_bitset()) {
      set_bitset(from.bitset());
    }
  }
}

void buffermap_info::CopyFrom(const buffermap_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool buffermap_info::IsInitialized() const {

  return true;
}

void buffermap_info::Swap(buffermap_info* other) {
  if (other != this) {
    recent_seqno_.Swap(&other->recent_seqno_);
    std::swap(bigest_seqno_i_know_, other->bigest_seqno_i_know_);
    std::swap(smallest_seqno_i_have_, other->smallest_seqno_i_have_);
    std::swap(first_seqno_in_bitset_, other->first_seqno_in_bitset_);
    std::swap(erased_seq_begin_, other->erased_seq_begin_);
    std::swap(erased_seq_end_, other->erased_seq_end_);
    std::swap(bitset_, other->bitset_);
    iframe_seqno_.Swap(&other->iframe_seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string buffermap_info::GetTypeName() const {
  return "p2message.buffermap_info";
}


// ===================================================================

#ifndef _MSC_VER
const int piece_info::kTimestampFieldNumber;
const int piece_info::kSeqnoFieldNumber;
#endif  // !_MSC_VER

piece_info::piece_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void piece_info::InitAsDefaultInstance() {
}

piece_info::piece_info(const piece_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void piece_info::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0u;
  seqno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

piece_info::~piece_info() {
  SharedDtor();
}

void piece_info::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void piece_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const piece_info& piece_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

piece_info* piece_info::default_instance_ = NULL;

piece_info* piece_info::New() const {
  return new piece_info;
}

void piece_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0u;
    seqno_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool piece_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_seqno;
        break;
      }

      // required fixed32 seqno = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &seqno_)));
          set_has_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void piece_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->timestamp(), output);
  }

  // required fixed32 seqno = 2;
  if (has_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->seqno(), output);
  }

}

int piece_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 + 4;
    }

    // required fixed32 seqno = 2;
    if (has_seqno()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void piece_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const piece_info*>(&from));
}

void piece_info::MergeFrom(const piece_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_seqno()) {
      set_seqno(from.seqno());
    }
  }
}

void piece_info::CopyFrom(const piece_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool piece_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void piece_info::Swap(piece_info* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(seqno_, other->seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string piece_info::GetTypeName() const {
  return "p2message.piece_info";
}


// ===================================================================

#ifndef _MSC_VER
const int live_channel_info::kChannelUuidFieldNumber;
const int live_channel_info::kServerTimeFieldNumber;
const int live_channel_info::kServerSeqnoFieldNumber;
const int live_channel_info::kServerPacketRateFieldNumber;
#endif  // !_MSC_VER

live_channel_info::live_channel_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void live_channel_info::InitAsDefaultInstance() {
}

live_channel_info::live_channel_info(const live_channel_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void live_channel_info::SharedCtor() {
  _cached_size_ = 0;
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  server_time_ = 0;
  server_seqno_ = 0u;
  server_packet_rate_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

live_channel_info::~live_channel_info() {
  SharedDtor();
}

void live_channel_info::SharedDtor() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void live_channel_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const live_channel_info& live_channel_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

live_channel_info* live_channel_info::default_instance_ = NULL;

live_channel_info* live_channel_info::New() const {
  return new live_channel_info;
}

void live_channel_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
    server_time_ = 0;
    server_seqno_ = 0u;
    server_packet_rate_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool live_channel_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes channel_uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_server_time;
        break;
      }

      // required sfixed32 server_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_server_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &server_time_)));
          set_has_server_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_server_seqno;
        break;
      }

      // required fixed32 server_seqno = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_server_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &server_seqno_)));
          set_has_server_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_server_packet_rate;
        break;
      }

      // required uint32 server_packet_rate = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_packet_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_packet_rate_)));
          set_has_server_packet_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void live_channel_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes channel_uuid = 1;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->channel_uuid(), output);
  }

  // required sfixed32 server_time = 2;
  if (has_server_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(2, this->server_time(), output);
  }

  // required fixed32 server_seqno = 3;
  if (has_server_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->server_seqno(), output);
  }

  // required uint32 server_packet_rate = 4;
  if (has_server_packet_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->server_packet_rate(), output);
  }

}

int live_channel_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes channel_uuid = 1;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

    // required sfixed32 server_time = 2;
    if (has_server_time()) {
      total_size += 1 + 4;
    }

    // required fixed32 server_seqno = 3;
    if (has_server_seqno()) {
      total_size += 1 + 4;
    }

    // required uint32 server_packet_rate = 4;
    if (has_server_packet_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_packet_rate());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void live_channel_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const live_channel_info*>(&from));
}

void live_channel_info::MergeFrom(const live_channel_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
    if (from.has_server_time()) {
      set_server_time(from.server_time());
    }
    if (from.has_server_seqno()) {
      set_server_seqno(from.server_seqno());
    }
    if (from.has_server_packet_rate()) {
      set_server_packet_rate(from.server_packet_rate());
    }
  }
}

void live_channel_info::CopyFrom(const live_channel_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool live_channel_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void live_channel_info::Swap(live_channel_info* other) {
  if (other != this) {
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(server_time_, other->server_time_);
    std::swap(server_seqno_, other->server_seqno_);
    std::swap(server_packet_rate_, other->server_packet_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string live_channel_info::GetTypeName() const {
  return "p2message.live_channel_info";
}


// ===================================================================

#ifndef _MSC_VER
const int vod_channel_info::kChannelLinkFieldNumber;
const int vod_channel_info::kChannelUuidFieldNumber;
const int vod_channel_info::kFilmDurationFieldNumber;
const int vod_channel_info::kFilmLengthFieldNumber;
#endif  // !_MSC_VER

vod_channel_info::vod_channel_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void vod_channel_info::InitAsDefaultInstance() {
}

vod_channel_info::vod_channel_info(const vod_channel_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void vod_channel_info::SharedCtor() {
  _cached_size_ = 0;
  channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  film_duration_ = 0;
  film_length_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

vod_channel_info::~vod_channel_info() {
  SharedDtor();
}

void vod_channel_info::SharedDtor() {
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_link_;
  }
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void vod_channel_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const vod_channel_info& vod_channel_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

vod_channel_info* vod_channel_info::default_instance_ = NULL;

vod_channel_info* vod_channel_info::New() const {
  return new vod_channel_info;
}

void vod_channel_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_channel_link()) {
      if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
        channel_link_->clear();
      }
    }
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
    film_duration_ = 0;
    film_length_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool vod_channel_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes channel_link = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_link()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channel_uuid;
        break;
      }

      // required bytes channel_uuid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_film_duration;
        break;
      }

      // required int32 film_duration = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_film_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &film_duration_)));
          set_has_film_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_film_length;
        break;
      }

      // required int32 film_length = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_film_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &film_length_)));
          set_has_film_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void vod_channel_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes channel_link = 1;
  if (has_channel_link()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->channel_link(), output);
  }

  // required bytes channel_uuid = 2;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->channel_uuid(), output);
  }

  // required int32 film_duration = 3;
  if (has_film_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->film_duration(), output);
  }

  // required int32 film_length = 4;
  if (has_film_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->film_length(), output);
  }

}

int vod_channel_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes channel_link = 1;
    if (has_channel_link()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_link());
    }

    // required bytes channel_uuid = 2;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

    // required int32 film_duration = 3;
    if (has_film_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->film_duration());
    }

    // required int32 film_length = 4;
    if (has_film_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->film_length());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void vod_channel_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const vod_channel_info*>(&from));
}

void vod_channel_info::MergeFrom(const vod_channel_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel_link()) {
      set_channel_link(from.channel_link());
    }
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
    if (from.has_film_duration()) {
      set_film_duration(from.film_duration());
    }
    if (from.has_film_length()) {
      set_film_length(from.film_length());
    }
  }
}

void vod_channel_info::CopyFrom(const vod_channel_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vod_channel_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void vod_channel_info::Swap(vod_channel_info* other) {
  if (other != this) {
    std::swap(channel_link_, other->channel_link_);
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(film_duration_, other->film_duration_);
    std::swap(film_length_, other->film_length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string vod_channel_info::GetTypeName() const {
  return "p2message.vod_channel_info";
}


// ===================================================================

#ifndef _MSC_VER
const int s2ts_channel_report_msg::kChannelInfoFieldNumber;
const int s2ts_channel_report_msg::kIframeSeqnoFieldNumber;
#endif  // !_MSC_VER

s2ts_channel_report_msg::s2ts_channel_report_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void s2ts_channel_report_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  channel_info_ = const_cast< ::p2message::live_channel_info*>(
      ::p2message::live_channel_info::internal_default_instance());
#else
  channel_info_ = const_cast< ::p2message::live_channel_info*>(&::p2message::live_channel_info::default_instance());
#endif
}

s2ts_channel_report_msg::s2ts_channel_report_msg(const s2ts_channel_report_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void s2ts_channel_report_msg::SharedCtor() {
  _cached_size_ = 0;
  channel_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

s2ts_channel_report_msg::~s2ts_channel_report_msg() {
  SharedDtor();
}

void s2ts_channel_report_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete channel_info_;
  }
}

void s2ts_channel_report_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const s2ts_channel_report_msg& s2ts_channel_report_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

s2ts_channel_report_msg* s2ts_channel_report_msg::default_instance_ = NULL;

s2ts_channel_report_msg* s2ts_channel_report_msg::New() const {
  return new s2ts_channel_report_msg;
}

void s2ts_channel_report_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_channel_info()) {
      if (channel_info_ != NULL) channel_info_->::p2message::live_channel_info::Clear();
    }
  }
  iframe_seqno_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool s2ts_channel_report_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2message.live_channel_info channel_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_channel_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_iframe_seqno;
        break;
      }

      // repeated fixed32 iframe_seqno = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_iframe_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 21, input, this->mutable_iframe_seqno())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_iframe_seqno())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_iframe_seqno;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void s2ts_channel_report_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .p2message.live_channel_info channel_info = 1;
  if (has_channel_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->channel_info(), output);
  }

  // repeated fixed32 iframe_seqno = 2;
  for (int i = 0; i < this->iframe_seqno_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      2, this->iframe_seqno(i), output);
  }

}

int s2ts_channel_report_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .p2message.live_channel_info channel_info = 1;
    if (has_channel_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->channel_info());
    }

  }
  // repeated fixed32 iframe_seqno = 2;
  {
    int data_size = 0;
    data_size = 4 * this->iframe_seqno_size();
    total_size += 1 * this->iframe_seqno_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void s2ts_channel_report_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const s2ts_channel_report_msg*>(&from));
}

void s2ts_channel_report_msg::MergeFrom(const s2ts_channel_report_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  iframe_seqno_.MergeFrom(from.iframe_seqno_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel_info()) {
      mutable_channel_info()->::p2message::live_channel_info::MergeFrom(from.channel_info());
    }
  }
}

void s2ts_channel_report_msg::CopyFrom(const s2ts_channel_report_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool s2ts_channel_report_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_channel_info()) {
    if (!this->channel_info().IsInitialized()) return false;
  }
  return true;
}

void s2ts_channel_report_msg::Swap(s2ts_channel_report_msg* other) {
  if (other != this) {
    std::swap(channel_info_, other->channel_info_);
    iframe_seqno_.Swap(&other->iframe_seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string s2ts_channel_report_msg::GetTypeName() const {
  return "p2message.s2ts_channel_report_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int s2ts_create_channel_msg::kServerInfoFieldNumber;
const int s2ts_create_channel_msg::kLiveChannelInfoFieldNumber;
const int s2ts_create_channel_msg::kVodChannelInfoFieldNumber;
const int s2ts_create_channel_msg::kDistributeTypeFieldNumber;
#endif  // !_MSC_VER

s2ts_create_channel_msg::s2ts_create_channel_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void s2ts_create_channel_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  server_info_ = const_cast< ::p2message::peer_info*>(
      ::p2message::peer_info::internal_default_instance());
#else
  server_info_ = const_cast< ::p2message::peer_info*>(&::p2message::peer_info::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  live_channel_info_ = const_cast< ::p2message::live_channel_info*>(
      ::p2message::live_channel_info::internal_default_instance());
#else
  live_channel_info_ = const_cast< ::p2message::live_channel_info*>(&::p2message::live_channel_info::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  vod_channel_info_ = const_cast< ::p2message::vod_channel_info*>(
      ::p2message::vod_channel_info::internal_default_instance());
#else
  vod_channel_info_ = const_cast< ::p2message::vod_channel_info*>(&::p2message::vod_channel_info::default_instance());
#endif
}

s2ts_create_channel_msg::s2ts_create_channel_msg(const s2ts_create_channel_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void s2ts_create_channel_msg::SharedCtor() {
  _cached_size_ = 0;
  server_info_ = NULL;
  live_channel_info_ = NULL;
  vod_channel_info_ = NULL;
  distribute_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

s2ts_create_channel_msg::~s2ts_create_channel_msg() {
  SharedDtor();
}

void s2ts_create_channel_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete server_info_;
    delete live_channel_info_;
    delete vod_channel_info_;
  }
}

void s2ts_create_channel_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const s2ts_create_channel_msg& s2ts_create_channel_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

s2ts_create_channel_msg* s2ts_create_channel_msg::default_instance_ = NULL;

s2ts_create_channel_msg* s2ts_create_channel_msg::New() const {
  return new s2ts_create_channel_msg;
}

void s2ts_create_channel_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_server_info()) {
      if (server_info_ != NULL) server_info_->::p2message::peer_info::Clear();
    }
    if (has_live_channel_info()) {
      if (live_channel_info_ != NULL) live_channel_info_->::p2message::live_channel_info::Clear();
    }
    if (has_vod_channel_info()) {
      if (vod_channel_info_ != NULL) vod_channel_info_->::p2message::vod_channel_info::Clear();
    }
    distribute_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool s2ts_create_channel_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2message.peer_info server_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_server_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_live_channel_info;
        break;
      }

      // optional .p2message.live_channel_info live_channel_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_live_channel_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_live_channel_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_vod_channel_info;
        break;
      }

      // optional .p2message.vod_channel_info vod_channel_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vod_channel_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vod_channel_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_distribute_type;
        break;
      }

      // required uint32 distribute_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_distribute_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &distribute_type_)));
          set_has_distribute_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void s2ts_create_channel_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .p2message.peer_info server_info = 1;
  if (has_server_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->server_info(), output);
  }

  // optional .p2message.live_channel_info live_channel_info = 2;
  if (has_live_channel_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->live_channel_info(), output);
  }

  // optional .p2message.vod_channel_info vod_channel_info = 3;
  if (has_vod_channel_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->vod_channel_info(), output);
  }

  // required uint32 distribute_type = 4;
  if (has_distribute_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->distribute_type(), output);
  }

}

int s2ts_create_channel_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .p2message.peer_info server_info = 1;
    if (has_server_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->server_info());
    }

    // optional .p2message.live_channel_info live_channel_info = 2;
    if (has_live_channel_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->live_channel_info());
    }

    // optional .p2message.vod_channel_info vod_channel_info = 3;
    if (has_vod_channel_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vod_channel_info());
    }

    // required uint32 distribute_type = 4;
    if (has_distribute_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->distribute_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void s2ts_create_channel_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const s2ts_create_channel_msg*>(&from));
}

void s2ts_create_channel_msg::MergeFrom(const s2ts_create_channel_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_info()) {
      mutable_server_info()->::p2message::peer_info::MergeFrom(from.server_info());
    }
    if (from.has_live_channel_info()) {
      mutable_live_channel_info()->::p2message::live_channel_info::MergeFrom(from.live_channel_info());
    }
    if (from.has_vod_channel_info()) {
      mutable_vod_channel_info()->::p2message::vod_channel_info::MergeFrom(from.vod_channel_info());
    }
    if (from.has_distribute_type()) {
      set_distribute_type(from.distribute_type());
    }
  }
}

void s2ts_create_channel_msg::CopyFrom(const s2ts_create_channel_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool s2ts_create_channel_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  if (has_server_info()) {
    if (!this->server_info().IsInitialized()) return false;
  }
  if (has_live_channel_info()) {
    if (!this->live_channel_info().IsInitialized()) return false;
  }
  if (has_vod_channel_info()) {
    if (!this->vod_channel_info().IsInitialized()) return false;
  }
  return true;
}

void s2ts_create_channel_msg::Swap(s2ts_create_channel_msg* other) {
  if (other != this) {
    std::swap(server_info_, other->server_info_);
    std::swap(live_channel_info_, other->live_channel_info_);
    std::swap(vod_channel_info_, other->vod_channel_info_);
    std::swap(distribute_type_, other->distribute_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string s2ts_create_channel_msg::GetTypeName() const {
  return "p2message.s2ts_create_channel_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int s2ts_channel_status_req::kChannelIdFieldNumber;
#endif  // !_MSC_VER

s2ts_channel_status_req::s2ts_channel_status_req()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void s2ts_channel_status_req::InitAsDefaultInstance() {
}

s2ts_channel_status_req::s2ts_channel_status_req(const s2ts_channel_status_req& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void s2ts_channel_status_req::SharedCtor() {
  _cached_size_ = 0;
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

s2ts_channel_status_req::~s2ts_channel_status_req() {
  SharedDtor();
}

void s2ts_channel_status_req::SharedDtor() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void s2ts_channel_status_req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const s2ts_channel_status_req& s2ts_channel_status_req::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

s2ts_channel_status_req* s2ts_channel_status_req::default_instance_ = NULL;

s2ts_channel_status_req* s2ts_channel_status_req::New() const {
  return new s2ts_channel_status_req;
}

void s2ts_channel_status_req::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool s2ts_channel_status_req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes channel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void s2ts_channel_status_req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes channel_id = 1;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->channel_id(), output);
  }

}

int s2ts_channel_status_req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes channel_id = 1;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void s2ts_channel_status_req::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const s2ts_channel_status_req*>(&from));
}

void s2ts_channel_status_req::MergeFrom(const s2ts_channel_status_req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
  }
}

void s2ts_channel_status_req::CopyFrom(const s2ts_channel_status_req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool s2ts_channel_status_req::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void s2ts_channel_status_req::Swap(s2ts_channel_status_req* other) {
  if (other != this) {
    std::swap(channel_id_, other->channel_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string s2ts_channel_status_req::GetTypeName() const {
  return "p2message.s2ts_channel_status_req";
}


// ===================================================================

#ifndef _MSC_VER
const int ts2s_channel_status::kLiveCntFieldNumber;
const int ts2s_channel_status::kPlayingQualityFieldNumber;
const int ts2s_channel_status::kRtolLostRateFieldNumber;
const int ts2s_channel_status::kQualityInfoFieldNumber;
#endif  // !_MSC_VER

ts2s_channel_status::ts2s_channel_status()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ts2s_channel_status::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  quality_info_ = const_cast< ::p2message::p2ts_quality_report_msg*>(
      ::p2message::p2ts_quality_report_msg::internal_default_instance());
#else
  quality_info_ = const_cast< ::p2message::p2ts_quality_report_msg*>(&::p2message::p2ts_quality_report_msg::default_instance());
#endif
}

ts2s_channel_status::ts2s_channel_status(const ts2s_channel_status& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ts2s_channel_status::SharedCtor() {
  _cached_size_ = 0;
  live_cnt_ = 0u;
  playing_quality_ = 0;
  rtol_lost_rate_ = 0;
  quality_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ts2s_channel_status::~ts2s_channel_status() {
  SharedDtor();
}

void ts2s_channel_status::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete quality_info_;
  }
}

void ts2s_channel_status::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ts2s_channel_status& ts2s_channel_status::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ts2s_channel_status* ts2s_channel_status::default_instance_ = NULL;

ts2s_channel_status* ts2s_channel_status::New() const {
  return new ts2s_channel_status;
}

void ts2s_channel_status::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    live_cnt_ = 0u;
    playing_quality_ = 0;
    rtol_lost_rate_ = 0;
    if (has_quality_info()) {
      if (quality_info_ != NULL) quality_info_->::p2message::p2ts_quality_report_msg::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ts2s_channel_status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 live_cnt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_cnt_)));
          set_has_live_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_playing_quality;
        break;
      }

      // required float playing_quality = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_playing_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &playing_quality_)));
          set_has_playing_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_rtol_lost_rate;
        break;
      }

      // required float rtol_lost_rate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rtol_lost_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rtol_lost_rate_)));
          set_has_rtol_lost_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_quality_info;
        break;
      }

      // optional .p2message.p2ts_quality_report_msg quality_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_quality_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_quality_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ts2s_channel_status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 live_cnt = 1;
  if (has_live_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->live_cnt(), output);
  }

  // required float playing_quality = 2;
  if (has_playing_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->playing_quality(), output);
  }

  // required float rtol_lost_rate = 3;
  if (has_rtol_lost_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->rtol_lost_rate(), output);
  }

  // optional .p2message.p2ts_quality_report_msg quality_info = 4;
  if (has_quality_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->quality_info(), output);
  }

}

int ts2s_channel_status::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 live_cnt = 1;
    if (has_live_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_cnt());
    }

    // required float playing_quality = 2;
    if (has_playing_quality()) {
      total_size += 1 + 4;
    }

    // required float rtol_lost_rate = 3;
    if (has_rtol_lost_rate()) {
      total_size += 1 + 4;
    }

    // optional .p2message.p2ts_quality_report_msg quality_info = 4;
    if (has_quality_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->quality_info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ts2s_channel_status::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ts2s_channel_status*>(&from));
}

void ts2s_channel_status::MergeFrom(const ts2s_channel_status& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_live_cnt()) {
      set_live_cnt(from.live_cnt());
    }
    if (from.has_playing_quality()) {
      set_playing_quality(from.playing_quality());
    }
    if (from.has_rtol_lost_rate()) {
      set_rtol_lost_rate(from.rtol_lost_rate());
    }
    if (from.has_quality_info()) {
      mutable_quality_info()->::p2message::p2ts_quality_report_msg::MergeFrom(from.quality_info());
    }
  }
}

void ts2s_channel_status::CopyFrom(const ts2s_channel_status& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ts2s_channel_status::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_quality_info()) {
    if (!this->quality_info().IsInitialized()) return false;
  }
  return true;
}

void ts2s_channel_status::Swap(ts2s_channel_status* other) {
  if (other != this) {
    std::swap(live_cnt_, other->live_cnt_);
    std::swap(playing_quality_, other->playing_quality_);
    std::swap(rtol_lost_rate_, other->rtol_lost_rate_);
    std::swap(quality_info_, other->quality_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ts2s_channel_status::GetTypeName() const {
  return "p2message.ts2s_channel_status";
}


// ===================================================================

#ifndef _MSC_VER
const int ts2p_challenge_msg::kChallengeFieldNumber;
#endif  // !_MSC_VER

ts2p_challenge_msg::ts2p_challenge_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ts2p_challenge_msg::InitAsDefaultInstance() {
}

ts2p_challenge_msg::ts2p_challenge_msg(const ts2p_challenge_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ts2p_challenge_msg::SharedCtor() {
  _cached_size_ = 0;
  challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ts2p_challenge_msg::~ts2p_challenge_msg() {
  SharedDtor();
}

void ts2p_challenge_msg::SharedDtor() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ts2p_challenge_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ts2p_challenge_msg& ts2p_challenge_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ts2p_challenge_msg* ts2p_challenge_msg::default_instance_ = NULL;

ts2p_challenge_msg* ts2p_challenge_msg::New() const {
  return new ts2p_challenge_msg;
}

void ts2p_challenge_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_challenge()) {
      if (challenge_ != &::google::protobuf::internal::kEmptyString) {
        challenge_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ts2p_challenge_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes challenge = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_challenge()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ts2p_challenge_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes challenge = 1;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->challenge(), output);
  }

}

int ts2p_challenge_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes challenge = 1;
    if (has_challenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->challenge());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ts2p_challenge_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ts2p_challenge_msg*>(&from));
}

void ts2p_challenge_msg::MergeFrom(const ts2p_challenge_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_challenge()) {
      set_challenge(from.challenge());
    }
  }
}

void ts2p_challenge_msg::CopyFrom(const ts2p_challenge_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ts2p_challenge_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ts2p_challenge_msg::Swap(ts2p_challenge_msg* other) {
  if (other != this) {
    std::swap(challenge_, other->challenge_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ts2p_challenge_msg::GetTypeName() const {
  return "p2message.ts2p_challenge_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_login_msg::kSessionIdFieldNumber;
const int p2ts_login_msg::kChannelIdFieldNumber;
const int p2ts_login_msg::kPeerInfoFieldNumber;
const int p2ts_login_msg::kPublicKeyFieldNumber;
const int p2ts_login_msg::kSharedKeySignatureFieldNumber;
const int p2ts_login_msg::kCertificateFieldNumber;
#endif  // !_MSC_VER

p2ts_login_msg::p2ts_login_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_login_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  peer_info_ = const_cast< ::p2message::peer_info*>(
      ::p2message::peer_info::internal_default_instance());
#else
  peer_info_ = const_cast< ::p2message::peer_info*>(&::p2message::peer_info::default_instance());
#endif
}

p2ts_login_msg::p2ts_login_msg(const p2ts_login_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_login_msg::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = 0u;
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  peer_info_ = NULL;
  public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  shared_key_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_login_msg::~p2ts_login_msg() {
  SharedDtor();
}

void p2ts_login_msg::SharedDtor() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (shared_key_signature_ != &::google::protobuf::internal::kEmptyString) {
    delete shared_key_signature_;
  }
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    delete certificate_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete peer_info_;
  }
}

void p2ts_login_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_login_msg& p2ts_login_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_login_msg* p2ts_login_msg::default_instance_ = NULL;

p2ts_login_msg* p2ts_login_msg::New() const {
  return new p2ts_login_msg;
}

void p2ts_login_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_id_ = 0u;
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
    if (has_peer_info()) {
      if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
    }
    if (has_public_key()) {
      if (public_key_ != &::google::protobuf::internal::kEmptyString) {
        public_key_->clear();
      }
    }
    if (has_shared_key_signature()) {
      if (shared_key_signature_ != &::google::protobuf::internal::kEmptyString) {
        shared_key_signature_->clear();
      }
    }
    if (has_certificate()) {
      if (certificate_ != &::google::protobuf::internal::kEmptyString) {
        certificate_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_login_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channel_id;
        break;
      }

      // required bytes channel_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_peer_info;
        break;
      }

      // required .p2message.peer_info peer_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_peer_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_public_key;
        break;
      }

      // required bytes public_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_shared_key_signature;
        break;
      }

      // required bytes shared_key_signature = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shared_key_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_shared_key_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_certificate;
        break;
      }

      // required bytes certificate = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_certificate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_certificate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_login_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->session_id(), output);
  }

  // required bytes channel_id = 2;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->channel_id(), output);
  }

  // required .p2message.peer_info peer_info = 3;
  if (has_peer_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->peer_info(), output);
  }

  // required bytes public_key = 4;
  if (has_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->public_key(), output);
  }

  // required bytes shared_key_signature = 5;
  if (has_shared_key_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->shared_key_signature(), output);
  }

  // required bytes certificate = 6;
  if (has_certificate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->certificate(), output);
  }

}

int p2ts_login_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required bytes channel_id = 2;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

    // required .p2message.peer_info peer_info = 3;
    if (has_peer_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->peer_info());
    }

    // required bytes public_key = 4;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // required bytes shared_key_signature = 5;
    if (has_shared_key_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->shared_key_signature());
    }

    // required bytes certificate = 6;
    if (has_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->certificate());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_login_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_login_msg*>(&from));
}

void p2ts_login_msg::MergeFrom(const p2ts_login_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
    if (from.has_peer_info()) {
      mutable_peer_info()->::p2message::peer_info::MergeFrom(from.peer_info());
    }
    if (from.has_public_key()) {
      set_public_key(from.public_key());
    }
    if (from.has_shared_key_signature()) {
      set_shared_key_signature(from.shared_key_signature());
    }
    if (from.has_certificate()) {
      set_certificate(from.certificate());
    }
  }
}

void p2ts_login_msg::CopyFrom(const p2ts_login_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_login_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_peer_info()) {
    if (!this->peer_info().IsInitialized()) return false;
  }
  return true;
}

void p2ts_login_msg::Swap(p2ts_login_msg* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(channel_id_, other->channel_id_);
    std::swap(peer_info_, other->peer_info_);
    std::swap(public_key_, other->public_key_);
    std::swap(shared_key_signature_, other->shared_key_signature_);
    std::swap(certificate_, other->certificate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_login_msg::GetTypeName() const {
  return "p2message.p2ts_login_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int ts2p_login_reply_msg::kPeerInfoListFieldNumber;
const int ts2p_login_reply_msg::kErrorCodeFieldNumber;
const int ts2p_login_reply_msg::kSessionIdFieldNumber;
const int ts2p_login_reply_msg::kExternalIpFieldNumber;
const int ts2p_login_reply_msg::kExternalPortFieldNumber;
const int ts2p_login_reply_msg::kOnlinePeerCntFieldNumber;
const int ts2p_login_reply_msg::kJoinTimeFieldNumber;
const int ts2p_login_reply_msg::kChannelIdFieldNumber;
const int ts2p_login_reply_msg::kLiveChannelInfoFieldNumber;
const int ts2p_login_reply_msg::kVodChannelInfoFieldNumber;
const int ts2p_login_reply_msg::kCacheTrackerAddrFieldNumber;
const int ts2p_login_reply_msg::kIframeSeqnoFieldNumber;
#endif  // !_MSC_VER

ts2p_login_reply_msg::ts2p_login_reply_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ts2p_login_reply_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  live_channel_info_ = const_cast< ::p2message::live_channel_info*>(
      ::p2message::live_channel_info::internal_default_instance());
#else
  live_channel_info_ = const_cast< ::p2message::live_channel_info*>(&::p2message::live_channel_info::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  vod_channel_info_ = const_cast< ::p2message::vod_channel_info*>(
      ::p2message::vod_channel_info::internal_default_instance());
#else
  vod_channel_info_ = const_cast< ::p2message::vod_channel_info*>(&::p2message::vod_channel_info::default_instance());
#endif
}

ts2p_login_reply_msg::ts2p_login_reply_msg(const ts2p_login_reply_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ts2p_login_reply_msg::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  session_id_ = 0u;
  external_ip_ = 0u;
  external_port_ = 0u;
  online_peer_cnt_ = 0u;
  join_time_ = GOOGLE_ULONGLONG(0);
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  live_channel_info_ = NULL;
  vod_channel_info_ = NULL;
  cache_tracker_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ts2p_login_reply_msg::~ts2p_login_reply_msg() {
  SharedDtor();
}

void ts2p_login_reply_msg::SharedDtor() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  if (cache_tracker_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete cache_tracker_addr_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete live_channel_info_;
    delete vod_channel_info_;
  }
}

void ts2p_login_reply_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ts2p_login_reply_msg& ts2p_login_reply_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ts2p_login_reply_msg* ts2p_login_reply_msg::default_instance_ = NULL;

ts2p_login_reply_msg* ts2p_login_reply_msg::New() const {
  return new ts2p_login_reply_msg;
}

void ts2p_login_reply_msg::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    error_code_ = 0u;
    session_id_ = 0u;
    external_ip_ = 0u;
    external_port_ = 0u;
    online_peer_cnt_ = 0u;
    join_time_ = GOOGLE_ULONGLONG(0);
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_live_channel_info()) {
      if (live_channel_info_ != NULL) live_channel_info_->::p2message::live_channel_info::Clear();
    }
    if (has_vod_channel_info()) {
      if (vod_channel_info_ != NULL) vod_channel_info_->::p2message::vod_channel_info::Clear();
    }
    if (has_cache_tracker_addr()) {
      if (cache_tracker_addr_ != &::google::protobuf::internal::kEmptyString) {
        cache_tracker_addr_->clear();
      }
    }
  }
  peer_info_list_.Clear();
  iframe_seqno_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ts2p_login_reply_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .p2message.peer_info peer_info_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_peer_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_peer_info_list;
        if (input->ExpectTag(16)) goto parse_error_code;
        break;
      }

      // required uint32 error_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_session_id;
        break;
      }

      // required uint32 session_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_external_ip;
        break;
      }

      // required uint32 external_ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_external_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &external_ip_)));
          set_has_external_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_external_port;
        break;
      }

      // required uint32 external_port = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_external_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &external_port_)));
          set_has_external_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_online_peer_cnt;
        break;
      }

      // required uint32 online_peer_cnt = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_online_peer_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_peer_cnt_)));
          set_has_online_peer_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_join_time;
        break;
      }

      // required uint64 join_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_join_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &join_time_)));
          set_has_join_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_channel_id;
        break;
      }

      // required bytes channel_id = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_live_channel_info;
        break;
      }

      // optional .p2message.live_channel_info live_channel_info = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_live_channel_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_live_channel_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_vod_channel_info;
        break;
      }

      // optional .p2message.vod_channel_info vod_channel_info = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vod_channel_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vod_channel_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_cache_tracker_addr;
        break;
      }

      // optional bytes cache_tracker_addr = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cache_tracker_addr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_cache_tracker_addr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_iframe_seqno;
        break;
      }

      // repeated fixed32 iframe_seqno = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_iframe_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 101, input, this->mutable_iframe_seqno())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_iframe_seqno())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_iframe_seqno;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ts2p_login_reply_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .p2message.peer_info peer_info_list = 1;
  for (int i = 0; i < this->peer_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->peer_info_list(i), output);
  }

  // required uint32 error_code = 2;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->error_code(), output);
  }

  // required uint32 session_id = 3;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->session_id(), output);
  }

  // required uint32 external_ip = 4;
  if (has_external_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->external_ip(), output);
  }

  // required uint32 external_port = 5;
  if (has_external_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->external_port(), output);
  }

  // required uint32 online_peer_cnt = 6;
  if (has_online_peer_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->online_peer_cnt(), output);
  }

  // required uint64 join_time = 7;
  if (has_join_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->join_time(), output);
  }

  // required bytes channel_id = 8;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->channel_id(), output);
  }

  // optional .p2message.live_channel_info live_channel_info = 9;
  if (has_live_channel_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->live_channel_info(), output);
  }

  // optional .p2message.vod_channel_info vod_channel_info = 10;
  if (has_vod_channel_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->vod_channel_info(), output);
  }

  // optional bytes cache_tracker_addr = 11;
  if (has_cache_tracker_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->cache_tracker_addr(), output);
  }

  // repeated fixed32 iframe_seqno = 12;
  for (int i = 0; i < this->iframe_seqno_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      12, this->iframe_seqno(i), output);
  }

}

int ts2p_login_reply_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 error_code = 2;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // required uint32 session_id = 3;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required uint32 external_ip = 4;
    if (has_external_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->external_ip());
    }

    // required uint32 external_port = 5;
    if (has_external_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->external_port());
    }

    // required uint32 online_peer_cnt = 6;
    if (has_online_peer_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_peer_cnt());
    }

    // required uint64 join_time = 7;
    if (has_join_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->join_time());
    }

    // required bytes channel_id = 8;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .p2message.live_channel_info live_channel_info = 9;
    if (has_live_channel_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->live_channel_info());
    }

    // optional .p2message.vod_channel_info vod_channel_info = 10;
    if (has_vod_channel_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vod_channel_info());
    }

    // optional bytes cache_tracker_addr = 11;
    if (has_cache_tracker_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->cache_tracker_addr());
    }

  }
  // repeated .p2message.peer_info peer_info_list = 1;
  total_size += 1 * this->peer_info_list_size();
  for (int i = 0; i < this->peer_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->peer_info_list(i));
  }

  // repeated fixed32 iframe_seqno = 12;
  {
    int data_size = 0;
    data_size = 4 * this->iframe_seqno_size();
    total_size += 1 * this->iframe_seqno_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ts2p_login_reply_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ts2p_login_reply_msg*>(&from));
}

void ts2p_login_reply_msg::MergeFrom(const ts2p_login_reply_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  peer_info_list_.MergeFrom(from.peer_info_list_);
  iframe_seqno_.MergeFrom(from.iframe_seqno_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_external_ip()) {
      set_external_ip(from.external_ip());
    }
    if (from.has_external_port()) {
      set_external_port(from.external_port());
    }
    if (from.has_online_peer_cnt()) {
      set_online_peer_cnt(from.online_peer_cnt());
    }
    if (from.has_join_time()) {
      set_join_time(from.join_time());
    }
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_live_channel_info()) {
      mutable_live_channel_info()->::p2message::live_channel_info::MergeFrom(from.live_channel_info());
    }
    if (from.has_vod_channel_info()) {
      mutable_vod_channel_info()->::p2message::vod_channel_info::MergeFrom(from.vod_channel_info());
    }
    if (from.has_cache_tracker_addr()) {
      set_cache_tracker_addr(from.cache_tracker_addr());
    }
  }
}

void ts2p_login_reply_msg::CopyFrom(const ts2p_login_reply_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ts2p_login_reply_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000fe) != 0x000000fe) return false;

  for (int i = 0; i < peer_info_list_size(); i++) {
    if (!this->peer_info_list(i).IsInitialized()) return false;
  }
  if (has_live_channel_info()) {
    if (!this->live_channel_info().IsInitialized()) return false;
  }
  if (has_vod_channel_info()) {
    if (!this->vod_channel_info().IsInitialized()) return false;
  }
  return true;
}

void ts2p_login_reply_msg::Swap(ts2p_login_reply_msg* other) {
  if (other != this) {
    peer_info_list_.Swap(&other->peer_info_list_);
    std::swap(error_code_, other->error_code_);
    std::swap(session_id_, other->session_id_);
    std::swap(external_ip_, other->external_ip_);
    std::swap(external_port_, other->external_port_);
    std::swap(online_peer_cnt_, other->online_peer_cnt_);
    std::swap(join_time_, other->join_time_);
    std::swap(channel_id_, other->channel_id_);
    std::swap(live_channel_info_, other->live_channel_info_);
    std::swap(vod_channel_info_, other->vod_channel_info_);
    std::swap(cache_tracker_addr_, other->cache_tracker_addr_);
    iframe_seqno_.Swap(&other->iframe_seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ts2p_login_reply_msg::GetTypeName() const {
  return "p2message.ts2p_login_reply_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_peer_request_msg::kSessionIdFieldNumber;
const int p2ts_peer_request_msg::kPeerInfoFieldNumber;
const int p2ts_peer_request_msg::kChannelUuidFieldNumber;
#endif  // !_MSC_VER

p2ts_peer_request_msg::p2ts_peer_request_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_peer_request_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  peer_info_ = const_cast< ::p2message::peer_info*>(
      ::p2message::peer_info::internal_default_instance());
#else
  peer_info_ = const_cast< ::p2message::peer_info*>(&::p2message::peer_info::default_instance());
#endif
}

p2ts_peer_request_msg::p2ts_peer_request_msg(const p2ts_peer_request_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_peer_request_msg::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = 0u;
  peer_info_ = NULL;
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_peer_request_msg::~p2ts_peer_request_msg() {
  SharedDtor();
}

void p2ts_peer_request_msg::SharedDtor() {
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete peer_info_;
  }
}

void p2ts_peer_request_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_peer_request_msg& p2ts_peer_request_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_peer_request_msg* p2ts_peer_request_msg::default_instance_ = NULL;

p2ts_peer_request_msg* p2ts_peer_request_msg::New() const {
  return new p2ts_peer_request_msg;
}

void p2ts_peer_request_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_id_ = 0u;
    if (has_peer_info()) {
      if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
    }
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_peer_request_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_peer_info;
        break;
      }

      // required .p2message.peer_info peer_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_peer_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_uuid;
        break;
      }

      // optional bytes channel_uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_peer_request_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->session_id(), output);
  }

  // required .p2message.peer_info peer_info = 2;
  if (has_peer_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->peer_info(), output);
  }

  // optional bytes channel_uuid = 3;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->channel_uuid(), output);
  }

}

int p2ts_peer_request_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required .p2message.peer_info peer_info = 2;
    if (has_peer_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->peer_info());
    }

    // optional bytes channel_uuid = 3;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_peer_request_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_peer_request_msg*>(&from));
}

void p2ts_peer_request_msg::MergeFrom(const p2ts_peer_request_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_peer_info()) {
      mutable_peer_info()->::p2message::peer_info::MergeFrom(from.peer_info());
    }
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
  }
}

void p2ts_peer_request_msg::CopyFrom(const p2ts_peer_request_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_peer_request_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_peer_info()) {
    if (!this->peer_info().IsInitialized()) return false;
  }
  return true;
}

void p2ts_peer_request_msg::Swap(p2ts_peer_request_msg* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(peer_info_, other->peer_info_);
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_peer_request_msg::GetTypeName() const {
  return "p2message.p2ts_peer_request_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int ts2p_peer_reply_msg::kErrorCodeFieldNumber;
const int ts2p_peer_reply_msg::kSessionIdFieldNumber;
const int ts2p_peer_reply_msg::kChannelIdFieldNumber;
const int ts2p_peer_reply_msg::kPeerInfoListFieldNumber;
const int ts2p_peer_reply_msg::kCachePeerCntFieldNumber;
#endif  // !_MSC_VER

ts2p_peer_reply_msg::ts2p_peer_reply_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ts2p_peer_reply_msg::InitAsDefaultInstance() {
}

ts2p_peer_reply_msg::ts2p_peer_reply_msg(const ts2p_peer_reply_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ts2p_peer_reply_msg::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  session_id_ = 0u;
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cache_peer_cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ts2p_peer_reply_msg::~ts2p_peer_reply_msg() {
  SharedDtor();
}

void ts2p_peer_reply_msg::SharedDtor() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ts2p_peer_reply_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ts2p_peer_reply_msg& ts2p_peer_reply_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ts2p_peer_reply_msg* ts2p_peer_reply_msg::default_instance_ = NULL;

ts2p_peer_reply_msg* ts2p_peer_reply_msg::New() const {
  return new ts2p_peer_reply_msg;
}

void ts2p_peer_reply_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    session_id_ = 0u;
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
    cache_peer_cnt_ = 0u;
  }
  peer_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ts2p_peer_reply_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_session_id;
        break;
      }

      // required uint32 session_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_id;
        break;
      }

      // required bytes channel_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_peer_info_list;
        break;
      }

      // repeated .p2message.peer_info peer_info_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_peer_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_peer_info_list;
        if (input->ExpectTag(40)) goto parse_cache_peer_cnt;
        break;
      }

      // optional uint32 cache_peer_cnt = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cache_peer_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cache_peer_cnt_)));
          set_has_cache_peer_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ts2p_peer_reply_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // required uint32 session_id = 2;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->session_id(), output);
  }

  // required bytes channel_id = 3;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->channel_id(), output);
  }

  // repeated .p2message.peer_info peer_info_list = 4;
  for (int i = 0; i < this->peer_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->peer_info_list(i), output);
  }

  // optional uint32 cache_peer_cnt = 5;
  if (has_cache_peer_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cache_peer_cnt(), output);
  }

}

int ts2p_peer_reply_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // required uint32 session_id = 2;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required bytes channel_id = 3;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

    // optional uint32 cache_peer_cnt = 5;
    if (has_cache_peer_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cache_peer_cnt());
    }

  }
  // repeated .p2message.peer_info peer_info_list = 4;
  total_size += 1 * this->peer_info_list_size();
  for (int i = 0; i < this->peer_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->peer_info_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ts2p_peer_reply_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ts2p_peer_reply_msg*>(&from));
}

void ts2p_peer_reply_msg::MergeFrom(const ts2p_peer_reply_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  peer_info_list_.MergeFrom(from.peer_info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
    if (from.has_cache_peer_cnt()) {
      set_cache_peer_cnt(from.cache_peer_cnt());
    }
  }
}

void ts2p_peer_reply_msg::CopyFrom(const ts2p_peer_reply_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ts2p_peer_reply_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  for (int i = 0; i < peer_info_list_size(); i++) {
    if (!this->peer_info_list(i).IsInitialized()) return false;
  }
  return true;
}

void ts2p_peer_reply_msg::Swap(ts2p_peer_reply_msg* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(session_id_, other->session_id_);
    std::swap(channel_id_, other->channel_id_);
    peer_info_list_.Swap(&other->peer_info_list_);
    std::swap(cache_peer_cnt_, other->cache_peer_cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ts2p_peer_reply_msg::GetTypeName() const {
  return "p2message.ts2p_peer_reply_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_logout_msg::kPeerIdFieldNumber;
const int p2ts_logout_msg::kPeerKeyFieldNumber;
const int p2ts_logout_msg::kChannelUuidFieldNumber;
#endif  // !_MSC_VER

p2ts_logout_msg::p2ts_logout_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_logout_msg::InitAsDefaultInstance() {
}

p2ts_logout_msg::p2ts_logout_msg(const p2ts_logout_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_logout_msg::SharedCtor() {
  _cached_size_ = 0;
  peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  peer_key_ = 0u;
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_logout_msg::~p2ts_logout_msg() {
  SharedDtor();
}

void p2ts_logout_msg::SharedDtor() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2ts_logout_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_logout_msg& p2ts_logout_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_logout_msg* p2ts_logout_msg::default_instance_ = NULL;

p2ts_logout_msg* p2ts_logout_msg::New() const {
  return new p2ts_logout_msg;
}

void p2ts_logout_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_peer_id()) {
      if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
        peer_id_->clear();
      }
    }
    peer_key_ = 0u;
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_logout_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes peer_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_peer_key;
        break;
      }

      // required uint32 peer_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_peer_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_key_)));
          set_has_peer_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_uuid;
        break;
      }

      // optional bytes channel_uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_logout_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes peer_id = 1;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->peer_id(), output);
  }

  // required uint32 peer_key = 2;
  if (has_peer_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->peer_key(), output);
  }

  // optional bytes channel_uuid = 3;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->channel_uuid(), output);
  }

}

int p2ts_logout_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes peer_id = 1;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->peer_id());
    }

    // required uint32 peer_key = 2;
    if (has_peer_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_key());
    }

    // optional bytes channel_uuid = 3;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_logout_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_logout_msg*>(&from));
}

void p2ts_logout_msg::MergeFrom(const p2ts_logout_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_peer_key()) {
      set_peer_key(from.peer_key());
    }
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
  }
}

void p2ts_logout_msg::CopyFrom(const p2ts_logout_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_logout_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void p2ts_logout_msg::Swap(p2ts_logout_msg* other) {
  if (other != this) {
    std::swap(peer_id_, other->peer_id_);
    std::swap(peer_key_, other->peer_key_);
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_logout_msg::GetTypeName() const {
  return "p2message.p2ts_logout_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_failure_report_msg::kPeerIdFieldNumber;
const int p2ts_failure_report_msg::kChannelUuidFieldNumber;
#endif  // !_MSC_VER

p2ts_failure_report_msg::p2ts_failure_report_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_failure_report_msg::InitAsDefaultInstance() {
}

p2ts_failure_report_msg::p2ts_failure_report_msg(const p2ts_failure_report_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_failure_report_msg::SharedCtor() {
  _cached_size_ = 0;
  peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_failure_report_msg::~p2ts_failure_report_msg() {
  SharedDtor();
}

void p2ts_failure_report_msg::SharedDtor() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2ts_failure_report_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_failure_report_msg& p2ts_failure_report_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_failure_report_msg* p2ts_failure_report_msg::default_instance_ = NULL;

p2ts_failure_report_msg* p2ts_failure_report_msg::New() const {
  return new p2ts_failure_report_msg;
}

void p2ts_failure_report_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_peer_id()) {
      if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
        peer_id_->clear();
      }
    }
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_failure_report_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes peer_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channel_uuid;
        break;
      }

      // optional bytes channel_uuid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_failure_report_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes peer_id = 1;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->peer_id(), output);
  }

  // optional bytes channel_uuid = 2;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->channel_uuid(), output);
  }

}

int p2ts_failure_report_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes peer_id = 1;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->peer_id());
    }

    // optional bytes channel_uuid = 2;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_failure_report_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_failure_report_msg*>(&from));
}

void p2ts_failure_report_msg::MergeFrom(const p2ts_failure_report_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
  }
}

void p2ts_failure_report_msg::CopyFrom(const p2ts_failure_report_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_failure_report_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void p2ts_failure_report_msg::Swap(p2ts_failure_report_msg* other) {
  if (other != this) {
    std::swap(peer_id_, other->peer_id_);
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_failure_report_msg::GetTypeName() const {
  return "p2message.p2ts_failure_report_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_local_info_report_msg::kPeerInfoFieldNumber;
#endif  // !_MSC_VER

p2ts_local_info_report_msg::p2ts_local_info_report_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_local_info_report_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  peer_info_ = const_cast< ::p2message::peer_info*>(
      ::p2message::peer_info::internal_default_instance());
#else
  peer_info_ = const_cast< ::p2message::peer_info*>(&::p2message::peer_info::default_instance());
#endif
}

p2ts_local_info_report_msg::p2ts_local_info_report_msg(const p2ts_local_info_report_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_local_info_report_msg::SharedCtor() {
  _cached_size_ = 0;
  peer_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_local_info_report_msg::~p2ts_local_info_report_msg() {
  SharedDtor();
}

void p2ts_local_info_report_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete peer_info_;
  }
}

void p2ts_local_info_report_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_local_info_report_msg& p2ts_local_info_report_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_local_info_report_msg* p2ts_local_info_report_msg::default_instance_ = NULL;

p2ts_local_info_report_msg* p2ts_local_info_report_msg::New() const {
  return new p2ts_local_info_report_msg;
}

void p2ts_local_info_report_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_peer_info()) {
      if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_local_info_report_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2message.peer_info peer_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_peer_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_local_info_report_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .p2message.peer_info peer_info = 2;
  if (has_peer_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->peer_info(), output);
  }

}

int p2ts_local_info_report_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .p2message.peer_info peer_info = 2;
    if (has_peer_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->peer_info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_local_info_report_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_local_info_report_msg*>(&from));
}

void p2ts_local_info_report_msg::MergeFrom(const p2ts_local_info_report_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_peer_info()) {
      mutable_peer_info()->::p2message::peer_info::MergeFrom(from.peer_info());
    }
  }
}

void p2ts_local_info_report_msg::CopyFrom(const p2ts_local_info_report_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_local_info_report_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_peer_info()) {
    if (!this->peer_info().IsInitialized()) return false;
  }
  return true;
}

void p2ts_local_info_report_msg::Swap(p2ts_local_info_report_msg* other) {
  if (other != this) {
    std::swap(peer_info_, other->peer_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_local_info_report_msg::GetTypeName() const {
  return "p2message.p2ts_local_info_report_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int ts2p_kickout_msg::kErrorCodeFieldNumber;
const int ts2p_kickout_msg::kReasionFieldNumber;
#endif  // !_MSC_VER

ts2p_kickout_msg::ts2p_kickout_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ts2p_kickout_msg::InitAsDefaultInstance() {
}

ts2p_kickout_msg::ts2p_kickout_msg(const ts2p_kickout_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ts2p_kickout_msg::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  reasion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ts2p_kickout_msg::~ts2p_kickout_msg() {
  SharedDtor();
}

void ts2p_kickout_msg::SharedDtor() {
  if (reasion_ != &::google::protobuf::internal::kEmptyString) {
    delete reasion_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ts2p_kickout_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ts2p_kickout_msg& ts2p_kickout_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ts2p_kickout_msg* ts2p_kickout_msg::default_instance_ = NULL;

ts2p_kickout_msg* ts2p_kickout_msg::New() const {
  return new ts2p_kickout_msg;
}

void ts2p_kickout_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    if (has_reasion()) {
      if (reasion_ != &::google::protobuf::internal::kEmptyString) {
        reasion_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ts2p_kickout_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reasion;
        break;
      }

      // optional bytes reasion = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reasion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reasion()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ts2p_kickout_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional bytes reasion = 2;
  if (has_reasion()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->reasion(), output);
  }

}

int ts2p_kickout_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional bytes reasion = 2;
    if (has_reasion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reasion());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ts2p_kickout_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ts2p_kickout_msg*>(&from));
}

void ts2p_kickout_msg::MergeFrom(const ts2p_kickout_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_reasion()) {
      set_reasion(from.reasion());
    }
  }
}

void ts2p_kickout_msg::CopyFrom(const ts2p_kickout_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ts2p_kickout_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ts2p_kickout_msg::Swap(ts2p_kickout_msg* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(reasion_, other->reasion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ts2p_kickout_msg::GetTypeName() const {
  return "p2message.ts2p_kickout_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_kickout_msg::kErrorCodeFieldNumber;
const int p2ts_kickout_msg::kReasionFieldNumber;
#endif  // !_MSC_VER

p2ts_kickout_msg::p2ts_kickout_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_kickout_msg::InitAsDefaultInstance() {
}

p2ts_kickout_msg::p2ts_kickout_msg(const p2ts_kickout_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_kickout_msg::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  reasion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_kickout_msg::~p2ts_kickout_msg() {
  SharedDtor();
}

void p2ts_kickout_msg::SharedDtor() {
  if (reasion_ != &::google::protobuf::internal::kEmptyString) {
    delete reasion_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2ts_kickout_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_kickout_msg& p2ts_kickout_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_kickout_msg* p2ts_kickout_msg::default_instance_ = NULL;

p2ts_kickout_msg* p2ts_kickout_msg::New() const {
  return new p2ts_kickout_msg;
}

void p2ts_kickout_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    if (has_reasion()) {
      if (reasion_ != &::google::protobuf::internal::kEmptyString) {
        reasion_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_kickout_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reasion;
        break;
      }

      // optional bytes reasion = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reasion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reasion()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_kickout_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional bytes reasion = 2;
  if (has_reasion()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->reasion(), output);
  }

}

int p2ts_kickout_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional bytes reasion = 2;
    if (has_reasion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reasion());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_kickout_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_kickout_msg*>(&from));
}

void p2ts_kickout_msg::MergeFrom(const p2ts_kickout_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_reasion()) {
      set_reasion(from.reasion());
    }
  }
}

void p2ts_kickout_msg::CopyFrom(const p2ts_kickout_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_kickout_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void p2ts_kickout_msg::Swap(p2ts_kickout_msg* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(reasion_, other->reasion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_kickout_msg::GetTypeName() const {
  return "p2message.p2ts_kickout_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int ts2p_room_info_msg::kOnlinePeerCntFieldNumber;
const int ts2p_room_info_msg::kOfflinePeerListFieldNumber;
const int ts2p_room_info_msg::kNewLoginPeerListFieldNumber;
const int ts2p_room_info_msg::kOnlinePeerListFieldNumber;
#endif  // !_MSC_VER

ts2p_room_info_msg::ts2p_room_info_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ts2p_room_info_msg::InitAsDefaultInstance() {
}

ts2p_room_info_msg::ts2p_room_info_msg(const ts2p_room_info_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ts2p_room_info_msg::SharedCtor() {
  _cached_size_ = 0;
  online_peer_cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ts2p_room_info_msg::~ts2p_room_info_msg() {
  SharedDtor();
}

void ts2p_room_info_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ts2p_room_info_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ts2p_room_info_msg& ts2p_room_info_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ts2p_room_info_msg* ts2p_room_info_msg::default_instance_ = NULL;

ts2p_room_info_msg* ts2p_room_info_msg::New() const {
  return new ts2p_room_info_msg;
}

void ts2p_room_info_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    online_peer_cnt_ = 0u;
  }
  offline_peer_list_.Clear();
  new_login_peer_list_.Clear();
  online_peer_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ts2p_room_info_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_peer_cnt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_peer_cnt_)));
          set_has_online_peer_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_offline_peer_list;
        break;
      }

      // repeated bytes offline_peer_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offline_peer_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_offline_peer_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_offline_peer_list;
        if (input->ExpectTag(26)) goto parse_new_login_peer_list;
        break;
      }

      // repeated .p2message.peer_info new_login_peer_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_new_login_peer_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_new_login_peer_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_new_login_peer_list;
        if (input->ExpectTag(34)) goto parse_online_peer_list;
        break;
      }

      // repeated .p2message.peer_info online_peer_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_online_peer_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_online_peer_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_online_peer_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ts2p_room_info_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 online_peer_cnt = 1;
  if (has_online_peer_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_peer_cnt(), output);
  }

  // repeated bytes offline_peer_list = 2;
  for (int i = 0; i < this->offline_peer_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->offline_peer_list(i), output);
  }

  // repeated .p2message.peer_info new_login_peer_list = 3;
  for (int i = 0; i < this->new_login_peer_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->new_login_peer_list(i), output);
  }

  // repeated .p2message.peer_info online_peer_list = 4;
  for (int i = 0; i < this->online_peer_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->online_peer_list(i), output);
  }

}

int ts2p_room_info_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_peer_cnt = 1;
    if (has_online_peer_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_peer_cnt());
    }

  }
  // repeated bytes offline_peer_list = 2;
  total_size += 1 * this->offline_peer_list_size();
  for (int i = 0; i < this->offline_peer_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->offline_peer_list(i));
  }

  // repeated .p2message.peer_info new_login_peer_list = 3;
  total_size += 1 * this->new_login_peer_list_size();
  for (int i = 0; i < this->new_login_peer_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->new_login_peer_list(i));
  }

  // repeated .p2message.peer_info online_peer_list = 4;
  total_size += 1 * this->online_peer_list_size();
  for (int i = 0; i < this->online_peer_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->online_peer_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ts2p_room_info_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ts2p_room_info_msg*>(&from));
}

void ts2p_room_info_msg::MergeFrom(const ts2p_room_info_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  offline_peer_list_.MergeFrom(from.offline_peer_list_);
  new_login_peer_list_.MergeFrom(from.new_login_peer_list_);
  online_peer_list_.MergeFrom(from.online_peer_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_peer_cnt()) {
      set_online_peer_cnt(from.online_peer_cnt());
    }
  }
}

void ts2p_room_info_msg::CopyFrom(const ts2p_room_info_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ts2p_room_info_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < new_login_peer_list_size(); i++) {
    if (!this->new_login_peer_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < online_peer_list_size(); i++) {
    if (!this->online_peer_list(i).IsInitialized()) return false;
  }
  return true;
}

void ts2p_room_info_msg::Swap(ts2p_room_info_msg* other) {
  if (other != this) {
    std::swap(online_peer_cnt_, other->online_peer_cnt_);
    offline_peer_list_.Swap(&other->offline_peer_list_);
    new_login_peer_list_.Swap(&other->new_login_peer_list_);
    online_peer_list_.Swap(&other->online_peer_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ts2p_room_info_msg::GetTypeName() const {
  return "p2message.ts2p_room_info_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_ban_msg::kIsAdminFieldNumber;
const int p2ts_ban_msg::kIsBanFieldNumber;
const int p2ts_ban_msg::kIsTxtFieldNumber;
const int p2ts_ban_msg::kDstPeerIdFieldNumber;
const int p2ts_ban_msg::kSrcPeerIdFieldNumber;
#endif  // !_MSC_VER

p2ts_ban_msg::p2ts_ban_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_ban_msg::InitAsDefaultInstance() {
}

p2ts_ban_msg::p2ts_ban_msg(const p2ts_ban_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_ban_msg::SharedCtor() {
  _cached_size_ = 0;
  is_admin_ = false;
  is_ban_ = false;
  is_txt_ = false;
  dst_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_ban_msg::~p2ts_ban_msg() {
  SharedDtor();
}

void p2ts_ban_msg::SharedDtor() {
  if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete dst_peer_id_;
  }
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete src_peer_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2ts_ban_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_ban_msg& p2ts_ban_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_ban_msg* p2ts_ban_msg::default_instance_ = NULL;

p2ts_ban_msg* p2ts_ban_msg::New() const {
  return new p2ts_ban_msg;
}

void p2ts_ban_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_admin_ = false;
    is_ban_ = false;
    is_txt_ = false;
    if (has_dst_peer_id()) {
      if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
        dst_peer_id_->clear();
      }
    }
    if (has_src_peer_id()) {
      if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
        src_peer_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_ban_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_admin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_admin_)));
          set_has_is_admin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_ban;
        break;
      }

      // required bool is_ban = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_ban:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_ban_)));
          set_has_is_ban();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_txt;
        break;
      }

      // required bool is_txt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_txt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_txt_)));
          set_has_is_txt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_dst_peer_id;
        break;
      }

      // required bytes dst_peer_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dst_peer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dst_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_src_peer_id;
        break;
      }

      // required bytes src_peer_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_src_peer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_src_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_ban_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_admin = 1;
  if (has_is_admin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_admin(), output);
  }

  // required bool is_ban = 2;
  if (has_is_ban()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_ban(), output);
  }

  // required bool is_txt = 3;
  if (has_is_txt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_txt(), output);
  }

  // required bytes dst_peer_id = 4;
  if (has_dst_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->dst_peer_id(), output);
  }

  // required bytes src_peer_id = 5;
  if (has_src_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->src_peer_id(), output);
  }

}

int p2ts_ban_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_admin = 1;
    if (has_is_admin()) {
      total_size += 1 + 1;
    }

    // required bool is_ban = 2;
    if (has_is_ban()) {
      total_size += 1 + 1;
    }

    // required bool is_txt = 3;
    if (has_is_txt()) {
      total_size += 1 + 1;
    }

    // required bytes dst_peer_id = 4;
    if (has_dst_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dst_peer_id());
    }

    // required bytes src_peer_id = 5;
    if (has_src_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->src_peer_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_ban_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_ban_msg*>(&from));
}

void p2ts_ban_msg::MergeFrom(const p2ts_ban_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_admin()) {
      set_is_admin(from.is_admin());
    }
    if (from.has_is_ban()) {
      set_is_ban(from.is_ban());
    }
    if (from.has_is_txt()) {
      set_is_txt(from.is_txt());
    }
    if (from.has_dst_peer_id()) {
      set_dst_peer_id(from.dst_peer_id());
    }
    if (from.has_src_peer_id()) {
      set_src_peer_id(from.src_peer_id());
    }
  }
}

void p2ts_ban_msg::CopyFrom(const p2ts_ban_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_ban_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void p2ts_ban_msg::Swap(p2ts_ban_msg* other) {
  if (other != this) {
    std::swap(is_admin_, other->is_admin_);
    std::swap(is_ban_, other->is_ban_);
    std::swap(is_txt_, other->is_txt_);
    std::swap(dst_peer_id_, other->dst_peer_id_);
    std::swap(src_peer_id_, other->src_peer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_ban_msg::GetTypeName() const {
  return "p2message.p2ts_ban_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_quality_report_msg::kIdFieldNumber;
const int p2ts_quality_report_msg::kIpFieldNumber;
const int p2ts_quality_report_msg::kPlayingQualityFieldNumber;
const int p2ts_quality_report_msg::kUplinkLostrateFieldNumber;
const int p2ts_quality_report_msg::kDownlinkLostrateFieldNumber;
const int p2ts_quality_report_msg::kPushRateFieldNumber;
const int p2ts_quality_report_msg::kDuplicateRateFieldNumber;
const int p2ts_quality_report_msg::kShareRateFieldNumber;
const int p2ts_quality_report_msg::kBufferHealthFieldNumber;
const int p2ts_quality_report_msg::kDelayFieldNumber;
const int p2ts_quality_report_msg::kCpuFieldNumber;
#endif  // !_MSC_VER

p2ts_quality_report_msg::p2ts_quality_report_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_quality_report_msg::InitAsDefaultInstance() {
}

p2ts_quality_report_msg::p2ts_quality_report_msg(const p2ts_quality_report_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_quality_report_msg::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  ip_ = 0u;
  playing_quality_ = 0;
  uplink_lostrate_ = 0;
  downlink_lostrate_ = 0;
  push_rate_ = 0;
  duplicate_rate_ = 0;
  share_rate_ = 0;
  buffer_health_ = 0;
  delay_ = 0;
  cpu_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_quality_report_msg::~p2ts_quality_report_msg() {
  SharedDtor();
}

void p2ts_quality_report_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2ts_quality_report_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_quality_report_msg& p2ts_quality_report_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_quality_report_msg* p2ts_quality_report_msg::default_instance_ = NULL;

p2ts_quality_report_msg* p2ts_quality_report_msg::New() const {
  return new p2ts_quality_report_msg;
}

void p2ts_quality_report_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    ip_ = 0u;
    playing_quality_ = 0;
    uplink_lostrate_ = 0;
    downlink_lostrate_ = 0;
    push_rate_ = 0;
    duplicate_rate_ = 0;
    share_rate_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    buffer_health_ = 0;
    delay_ = 0;
    cpu_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_quality_report_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_ip;
        break;
      }

      // required fixed32 ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &ip_)));
          set_has_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_playing_quality;
        break;
      }

      // required float playing_quality = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_playing_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &playing_quality_)));
          set_has_playing_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_uplink_lostrate;
        break;
      }

      // required float uplink_lostrate = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_uplink_lostrate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &uplink_lostrate_)));
          set_has_uplink_lostrate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_downlink_lostrate;
        break;
      }

      // required float downlink_lostrate = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_downlink_lostrate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &downlink_lostrate_)));
          set_has_downlink_lostrate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_push_rate;
        break;
      }

      // required float push_rate = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_push_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &push_rate_)));
          set_has_push_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_duplicate_rate;
        break;
      }

      // required float duplicate_rate = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_duplicate_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &duplicate_rate_)));
          set_has_duplicate_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_share_rate;
        break;
      }

      // required float share_rate = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_share_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &share_rate_)));
          set_has_share_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_buffer_health;
        break;
      }

      // required float buffer_health = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_buffer_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &buffer_health_)));
          set_has_buffer_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_delay;
        break;
      }

      // optional int32 delay = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_delay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &delay_)));
          set_has_delay();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_cpu;
        break;
      }

      // optional int32 cpu = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cpu:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cpu_)));
          set_has_cpu();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_quality_report_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // required fixed32 ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->ip(), output);
  }

  // required float playing_quality = 3;
  if (has_playing_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->playing_quality(), output);
  }

  // required float uplink_lostrate = 4;
  if (has_uplink_lostrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->uplink_lostrate(), output);
  }

  // required float downlink_lostrate = 5;
  if (has_downlink_lostrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->downlink_lostrate(), output);
  }

  // required float push_rate = 6;
  if (has_push_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->push_rate(), output);
  }

  // required float duplicate_rate = 7;
  if (has_duplicate_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->duplicate_rate(), output);
  }

  // required float share_rate = 8;
  if (has_share_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->share_rate(), output);
  }

  // required float buffer_health = 9;
  if (has_buffer_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->buffer_health(), output);
  }

  // optional int32 delay = 10;
  if (has_delay()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->delay(), output);
  }

  // optional int32 cpu = 11;
  if (has_cpu()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->cpu(), output);
  }

}

int p2ts_quality_report_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // required fixed32 ip = 2;
    if (has_ip()) {
      total_size += 1 + 4;
    }

    // required float playing_quality = 3;
    if (has_playing_quality()) {
      total_size += 1 + 4;
    }

    // required float uplink_lostrate = 4;
    if (has_uplink_lostrate()) {
      total_size += 1 + 4;
    }

    // required float downlink_lostrate = 5;
    if (has_downlink_lostrate()) {
      total_size += 1 + 4;
    }

    // required float push_rate = 6;
    if (has_push_rate()) {
      total_size += 1 + 4;
    }

    // required float duplicate_rate = 7;
    if (has_duplicate_rate()) {
      total_size += 1 + 4;
    }

    // required float share_rate = 8;
    if (has_share_rate()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float buffer_health = 9;
    if (has_buffer_health()) {
      total_size += 1 + 4;
    }

    // optional int32 delay = 10;
    if (has_delay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->delay());
    }

    // optional int32 cpu = 11;
    if (has_cpu()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cpu());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_quality_report_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_quality_report_msg*>(&from));
}

void p2ts_quality_report_msg::MergeFrom(const p2ts_quality_report_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_playing_quality()) {
      set_playing_quality(from.playing_quality());
    }
    if (from.has_uplink_lostrate()) {
      set_uplink_lostrate(from.uplink_lostrate());
    }
    if (from.has_downlink_lostrate()) {
      set_downlink_lostrate(from.downlink_lostrate());
    }
    if (from.has_push_rate()) {
      set_push_rate(from.push_rate());
    }
    if (from.has_duplicate_rate()) {
      set_duplicate_rate(from.duplicate_rate());
    }
    if (from.has_share_rate()) {
      set_share_rate(from.share_rate());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_buffer_health()) {
      set_buffer_health(from.buffer_health());
    }
    if (from.has_delay()) {
      set_delay(from.delay());
    }
    if (from.has_cpu()) {
      set_cpu(from.cpu());
    }
  }
}

void p2ts_quality_report_msg::CopyFrom(const p2ts_quality_report_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_quality_report_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void p2ts_quality_report_msg::Swap(p2ts_quality_report_msg* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(ip_, other->ip_);
    std::swap(playing_quality_, other->playing_quality_);
    std::swap(uplink_lostrate_, other->uplink_lostrate_);
    std::swap(downlink_lostrate_, other->downlink_lostrate_);
    std::swap(push_rate_, other->push_rate_);
    std::swap(duplicate_rate_, other->duplicate_rate_);
    std::swap(share_rate_, other->share_rate_);
    std::swap(buffer_health_, other->buffer_health_);
    std::swap(delay_, other->delay_);
    std::swap(cpu_, other->cpu_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_quality_report_msg::GetTypeName() const {
  return "p2message.p2ts_quality_report_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int cached_channel_info::kHealthyFieldNumber;
const int cached_channel_info::kChannelIdFieldNumber;
#endif  // !_MSC_VER

cached_channel_info::cached_channel_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void cached_channel_info::InitAsDefaultInstance() {
}

cached_channel_info::cached_channel_info(const cached_channel_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void cached_channel_info::SharedCtor() {
  _cached_size_ = 0;
  healthy_ = 0;
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

cached_channel_info::~cached_channel_info() {
  SharedDtor();
}

void cached_channel_info::SharedDtor() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void cached_channel_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const cached_channel_info& cached_channel_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

cached_channel_info* cached_channel_info::default_instance_ = NULL;

cached_channel_info* cached_channel_info::New() const {
  return new cached_channel_info;
}

void cached_channel_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    healthy_ = 0;
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool cached_channel_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 healthy = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &healthy_)));
          set_has_healthy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channel_id;
        break;
      }

      // required bytes channel_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void cached_channel_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 healthy = 1;
  if (has_healthy()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->healthy(), output);
  }

  // required bytes channel_id = 2;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->channel_id(), output);
  }

}

int cached_channel_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 healthy = 1;
    if (has_healthy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->healthy());
    }

    // required bytes channel_id = 2;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void cached_channel_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const cached_channel_info*>(&from));
}

void cached_channel_info::MergeFrom(const cached_channel_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_healthy()) {
      set_healthy(from.healthy());
    }
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
  }
}

void cached_channel_info::CopyFrom(const cached_channel_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cached_channel_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void cached_channel_info::Swap(cached_channel_info* other) {
  if (other != this) {
    std::swap(healthy_, other->healthy_);
    std::swap(channel_id_, other->channel_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string cached_channel_info::GetTypeName() const {
  return "p2message.cached_channel_info";
}


// ===================================================================

#ifndef _MSC_VER
const int p2ts_cache_announce_msg::kCachedChannelsFieldNumber;
const int p2ts_cache_announce_msg::kErasedChannelsFieldNumber;
const int p2ts_cache_announce_msg::kPeerInfoFieldNumber;
#endif  // !_MSC_VER

p2ts_cache_announce_msg::p2ts_cache_announce_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2ts_cache_announce_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  peer_info_ = const_cast< ::p2message::peer_info*>(
      ::p2message::peer_info::internal_default_instance());
#else
  peer_info_ = const_cast< ::p2message::peer_info*>(&::p2message::peer_info::default_instance());
#endif
}

p2ts_cache_announce_msg::p2ts_cache_announce_msg(const p2ts_cache_announce_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2ts_cache_announce_msg::SharedCtor() {
  _cached_size_ = 0;
  peer_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2ts_cache_announce_msg::~p2ts_cache_announce_msg() {
  SharedDtor();
}

void p2ts_cache_announce_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete peer_info_;
  }
}

void p2ts_cache_announce_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2ts_cache_announce_msg& p2ts_cache_announce_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2ts_cache_announce_msg* p2ts_cache_announce_msg::default_instance_ = NULL;

p2ts_cache_announce_msg* p2ts_cache_announce_msg::New() const {
  return new p2ts_cache_announce_msg;
}

void p2ts_cache_announce_msg::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (has_peer_info()) {
      if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
    }
  }
  cached_channels_.Clear();
  erased_channels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2ts_cache_announce_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .p2message.cached_channel_info cached_channels = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cached_channels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cached_channels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_cached_channels;
        if (input->ExpectTag(18)) goto parse_erased_channels;
        break;
      }

      // repeated bytes erased_channels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_erased_channels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_erased_channels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_erased_channels;
        if (input->ExpectTag(26)) goto parse_peer_info;
        break;
      }

      // required .p2message.peer_info peer_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_peer_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2ts_cache_announce_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .p2message.cached_channel_info cached_channels = 1;
  for (int i = 0; i < this->cached_channels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->cached_channels(i), output);
  }

  // repeated bytes erased_channels = 2;
  for (int i = 0; i < this->erased_channels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->erased_channels(i), output);
  }

  // required .p2message.peer_info peer_info = 3;
  if (has_peer_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->peer_info(), output);
  }

}

int p2ts_cache_announce_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required .p2message.peer_info peer_info = 3;
    if (has_peer_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->peer_info());
    }

  }
  // repeated .p2message.cached_channel_info cached_channels = 1;
  total_size += 1 * this->cached_channels_size();
  for (int i = 0; i < this->cached_channels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cached_channels(i));
  }

  // repeated bytes erased_channels = 2;
  total_size += 1 * this->erased_channels_size();
  for (int i = 0; i < this->erased_channels_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->erased_channels(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2ts_cache_announce_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2ts_cache_announce_msg*>(&from));
}

void p2ts_cache_announce_msg::MergeFrom(const p2ts_cache_announce_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  cached_channels_.MergeFrom(from.cached_channels_);
  erased_channels_.MergeFrom(from.erased_channels_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_peer_info()) {
      mutable_peer_info()->::p2message::peer_info::MergeFrom(from.peer_info());
    }
  }
}

void p2ts_cache_announce_msg::CopyFrom(const p2ts_cache_announce_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2ts_cache_announce_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  for (int i = 0; i < cached_channels_size(); i++) {
    if (!this->cached_channels(i).IsInitialized()) return false;
  }
  if (has_peer_info()) {
    if (!this->peer_info().IsInitialized()) return false;
  }
  return true;
}

void p2ts_cache_announce_msg::Swap(p2ts_cache_announce_msg* other) {
  if (other != this) {
    cached_channels_.Swap(&other->cached_channels_);
    erased_channels_.Swap(&other->erased_channels_);
    std::swap(peer_info_, other->peer_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2ts_cache_announce_msg::GetTypeName() const {
  return "p2message.p2ts_cache_announce_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int s2p_recommend_seed_msg::kTtlFieldNumber;
#endif  // !_MSC_VER

s2p_recommend_seed_msg::s2p_recommend_seed_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void s2p_recommend_seed_msg::InitAsDefaultInstance() {
}

s2p_recommend_seed_msg::s2p_recommend_seed_msg(const s2p_recommend_seed_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void s2p_recommend_seed_msg::SharedCtor() {
  _cached_size_ = 0;
  ttl_ = 6u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

s2p_recommend_seed_msg::~s2p_recommend_seed_msg() {
  SharedDtor();
}

void s2p_recommend_seed_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void s2p_recommend_seed_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const s2p_recommend_seed_msg& s2p_recommend_seed_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

s2p_recommend_seed_msg* s2p_recommend_seed_msg::default_instance_ = NULL;

s2p_recommend_seed_msg* s2p_recommend_seed_msg::New() const {
  return new s2p_recommend_seed_msg;
}

void s2p_recommend_seed_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ttl_ = 6u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool s2p_recommend_seed_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ttl = 1 [default = 6];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ttl_)));
          set_has_ttl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void s2p_recommend_seed_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ttl = 1 [default = 6];
  if (has_ttl()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ttl(), output);
  }

}

int s2p_recommend_seed_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ttl = 1 [default = 6];
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ttl());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void s2p_recommend_seed_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const s2p_recommend_seed_msg*>(&from));
}

void s2p_recommend_seed_msg::MergeFrom(const s2p_recommend_seed_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ttl()) {
      set_ttl(from.ttl());
    }
  }
}

void s2p_recommend_seed_msg::CopyFrom(const s2p_recommend_seed_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool s2p_recommend_seed_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void s2p_recommend_seed_msg::Swap(s2p_recommend_seed_msg* other) {
  if (other != this) {
    std::swap(ttl_, other->ttl_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string s2p_recommend_seed_msg::GetTypeName() const {
  return "p2message.s2p_recommend_seed_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int s2p_piece_notify::kBuffermapFieldNumber;
#endif  // !_MSC_VER

s2p_piece_notify::s2p_piece_notify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void s2p_piece_notify::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buffermap_ = const_cast< ::p2message::buffermap_info*>(
      ::p2message::buffermap_info::internal_default_instance());
#else
  buffermap_ = const_cast< ::p2message::buffermap_info*>(&::p2message::buffermap_info::default_instance());
#endif
}

s2p_piece_notify::s2p_piece_notify(const s2p_piece_notify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void s2p_piece_notify::SharedCtor() {
  _cached_size_ = 0;
  buffermap_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

s2p_piece_notify::~s2p_piece_notify() {
  SharedDtor();
}

void s2p_piece_notify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete buffermap_;
  }
}

void s2p_piece_notify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const s2p_piece_notify& s2p_piece_notify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

s2p_piece_notify* s2p_piece_notify::default_instance_ = NULL;

s2p_piece_notify* s2p_piece_notify::New() const {
  return new s2p_piece_notify;
}

void s2p_piece_notify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_buffermap()) {
      if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool s2p_piece_notify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2message.buffermap_info buffermap = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void s2p_piece_notify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .p2message.buffermap_info buffermap = 1;
  if (has_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->buffermap(), output);
  }

}

int s2p_piece_notify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .p2message.buffermap_info buffermap = 1;
    if (has_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buffermap());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void s2p_piece_notify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const s2p_piece_notify*>(&from));
}

void s2p_piece_notify::MergeFrom(const s2p_piece_notify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buffermap()) {
      mutable_buffermap()->::p2message::buffermap_info::MergeFrom(from.buffermap());
    }
  }
}

void s2p_piece_notify::CopyFrom(const s2p_piece_notify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool s2p_piece_notify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void s2p_piece_notify::Swap(s2p_piece_notify* other) {
  if (other != this) {
    std::swap(buffermap_, other->buffermap_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string s2p_piece_notify::GetTypeName() const {
  return "p2message.s2p_piece_notify";
}


// ===================================================================

#ifndef _MSC_VER
const int p2s_info_report_msg::kUploadSpeedFieldNumber;
const int p2s_info_report_msg::kLostRateFieldNumber;
#endif  // !_MSC_VER

p2s_info_report_msg::p2s_info_report_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2s_info_report_msg::InitAsDefaultInstance() {
}

p2s_info_report_msg::p2s_info_report_msg(const p2s_info_report_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2s_info_report_msg::SharedCtor() {
  _cached_size_ = 0;
  upload_speed_ = 0u;
  lost_rate_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2s_info_report_msg::~p2s_info_report_msg() {
  SharedDtor();
}

void p2s_info_report_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2s_info_report_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2s_info_report_msg& p2s_info_report_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2s_info_report_msg* p2s_info_report_msg::default_instance_ = NULL;

p2s_info_report_msg* p2s_info_report_msg::New() const {
  return new p2s_info_report_msg;
}

void p2s_info_report_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    upload_speed_ = 0u;
    lost_rate_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2s_info_report_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 upload_speed = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_speed_)));
          set_has_upload_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_lost_rate;
        break;
      }

      // required float lost_rate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_lost_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lost_rate_)));
          set_has_lost_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2s_info_report_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 upload_speed = 1;
  if (has_upload_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->upload_speed(), output);
  }

  // required float lost_rate = 2;
  if (has_lost_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->lost_rate(), output);
  }

}

int p2s_info_report_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 upload_speed = 1;
    if (has_upload_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_speed());
    }

    // required float lost_rate = 2;
    if (has_lost_rate()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2s_info_report_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2s_info_report_msg*>(&from));
}

void p2s_info_report_msg::MergeFrom(const p2s_info_report_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_upload_speed()) {
      set_upload_speed(from.upload_speed());
    }
    if (from.has_lost_rate()) {
      set_lost_rate(from.lost_rate());
    }
  }
}

void p2s_info_report_msg::CopyFrom(const p2s_info_report_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2s_info_report_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void p2s_info_report_msg::Swap(p2s_info_report_msg* other) {
  if (other != this) {
    std::swap(upload_speed_, other->upload_speed_);
    std::swap(lost_rate_, other->lost_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2s_info_report_msg::GetTypeName() const {
  return "p2message.p2s_info_report_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2p_handshake_msg::kPlayingChannelIdFieldNumber;
const int p2p_handshake_msg::kPeerInfoFieldNumber;
const int p2p_handshake_msg::kBuffermapFieldNumber;
const int p2p_handshake_msg::kCompressedBuffermapFieldNumber;
const int p2p_handshake_msg::kChunkmapFieldNumber;
#endif  // !_MSC_VER

p2p_handshake_msg::p2p_handshake_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2p_handshake_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  peer_info_ = const_cast< ::p2message::peer_info*>(
      ::p2message::peer_info::internal_default_instance());
#else
  peer_info_ = const_cast< ::p2message::peer_info*>(&::p2message::peer_info::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buffermap_ = const_cast< ::p2message::buffermap_info*>(
      ::p2message::buffermap_info::internal_default_instance());
#else
  buffermap_ = const_cast< ::p2message::buffermap_info*>(&::p2message::buffermap_info::default_instance());
#endif
}

p2p_handshake_msg::p2p_handshake_msg(const p2p_handshake_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2p_handshake_msg::SharedCtor() {
  _cached_size_ = 0;
  playing_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  peer_info_ = NULL;
  buffermap_ = NULL;
  compressed_buffermap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  chunkmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2p_handshake_msg::~p2p_handshake_msg() {
  SharedDtor();
}

void p2p_handshake_msg::SharedDtor() {
  if (playing_channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete playing_channel_id_;
  }
  if (compressed_buffermap_ != &::google::protobuf::internal::kEmptyString) {
    delete compressed_buffermap_;
  }
  if (chunkmap_ != &::google::protobuf::internal::kEmptyString) {
    delete chunkmap_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete peer_info_;
    delete buffermap_;
  }
}

void p2p_handshake_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2p_handshake_msg& p2p_handshake_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2p_handshake_msg* p2p_handshake_msg::default_instance_ = NULL;

p2p_handshake_msg* p2p_handshake_msg::New() const {
  return new p2p_handshake_msg;
}

void p2p_handshake_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_playing_channel_id()) {
      if (playing_channel_id_ != &::google::protobuf::internal::kEmptyString) {
        playing_channel_id_->clear();
      }
    }
    if (has_peer_info()) {
      if (peer_info_ != NULL) peer_info_->::p2message::peer_info::Clear();
    }
    if (has_buffermap()) {
      if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
    }
    if (has_compressed_buffermap()) {
      if (compressed_buffermap_ != &::google::protobuf::internal::kEmptyString) {
        compressed_buffermap_->clear();
      }
    }
    if (has_chunkmap()) {
      if (chunkmap_ != &::google::protobuf::internal::kEmptyString) {
        chunkmap_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2p_handshake_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes playing_channel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_playing_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_peer_info;
        break;
      }

      // required .p2message.peer_info peer_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_peer_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_buffermap;
        break;
      }

      // optional .p2message.buffermap_info buffermap = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buffermap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_compressed_buffermap;
        break;
      }

      // optional bytes compressed_buffermap = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_compressed_buffermap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_compressed_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_chunkmap;
        break;
      }

      // optional bytes chunkmap = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chunkmap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_chunkmap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2p_handshake_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes playing_channel_id = 1;
  if (has_playing_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->playing_channel_id(), output);
  }

  // required .p2message.peer_info peer_info = 2;
  if (has_peer_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->peer_info(), output);
  }

  // optional .p2message.buffermap_info buffermap = 3;
  if (has_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->buffermap(), output);
  }

  // optional bytes compressed_buffermap = 4;
  if (has_compressed_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->compressed_buffermap(), output);
  }

  // optional bytes chunkmap = 5;
  if (has_chunkmap()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->chunkmap(), output);
  }

}

int p2p_handshake_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes playing_channel_id = 1;
    if (has_playing_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->playing_channel_id());
    }

    // required .p2message.peer_info peer_info = 2;
    if (has_peer_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->peer_info());
    }

    // optional .p2message.buffermap_info buffermap = 3;
    if (has_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buffermap());
    }

    // optional bytes compressed_buffermap = 4;
    if (has_compressed_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->compressed_buffermap());
    }

    // optional bytes chunkmap = 5;
    if (has_chunkmap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->chunkmap());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2p_handshake_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2p_handshake_msg*>(&from));
}

void p2p_handshake_msg::MergeFrom(const p2p_handshake_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playing_channel_id()) {
      set_playing_channel_id(from.playing_channel_id());
    }
    if (from.has_peer_info()) {
      mutable_peer_info()->::p2message::peer_info::MergeFrom(from.peer_info());
    }
    if (from.has_buffermap()) {
      mutable_buffermap()->::p2message::buffermap_info::MergeFrom(from.buffermap());
    }
    if (from.has_compressed_buffermap()) {
      set_compressed_buffermap(from.compressed_buffermap());
    }
    if (from.has_chunkmap()) {
      set_chunkmap(from.chunkmap());
    }
  }
}

void p2p_handshake_msg::CopyFrom(const p2p_handshake_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2p_handshake_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_peer_info()) {
    if (!this->peer_info().IsInitialized()) return false;
  }
  return true;
}

void p2p_handshake_msg::Swap(p2p_handshake_msg* other) {
  if (other != this) {
    std::swap(playing_channel_id_, other->playing_channel_id_);
    std::swap(peer_info_, other->peer_info_);
    std::swap(buffermap_, other->buffermap_);
    std::swap(compressed_buffermap_, other->compressed_buffermap_);
    std::swap(chunkmap_, other->chunkmap_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2p_handshake_msg::GetTypeName() const {
  return "p2message.p2p_handshake_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2p_buffermap_request_msg::kMinSeqnoFieldNumber;
const int p2p_buffermap_request_msg::kMaxSeqnoFieldNumber;
#endif  // !_MSC_VER

p2p_buffermap_request_msg::p2p_buffermap_request_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2p_buffermap_request_msg::InitAsDefaultInstance() {
}

p2p_buffermap_request_msg::p2p_buffermap_request_msg(const p2p_buffermap_request_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2p_buffermap_request_msg::SharedCtor() {
  _cached_size_ = 0;
  min_seqno_ = 0u;
  max_seqno_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2p_buffermap_request_msg::~p2p_buffermap_request_msg() {
  SharedDtor();
}

void p2p_buffermap_request_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2p_buffermap_request_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2p_buffermap_request_msg& p2p_buffermap_request_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2p_buffermap_request_msg* p2p_buffermap_request_msg::default_instance_ = NULL;

p2p_buffermap_request_msg* p2p_buffermap_request_msg::New() const {
  return new p2p_buffermap_request_msg;
}

void p2p_buffermap_request_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    min_seqno_ = 0u;
    max_seqno_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2p_buffermap_request_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed32 min_seqno = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &min_seqno_)));
          set_has_min_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_max_seqno;
        break;
      }

      // required fixed32 max_seqno = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &max_seqno_)));
          set_has_max_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2p_buffermap_request_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed32 min_seqno = 1;
  if (has_min_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->min_seqno(), output);
  }

  // required fixed32 max_seqno = 2;
  if (has_max_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->max_seqno(), output);
  }

}

int p2p_buffermap_request_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed32 min_seqno = 1;
    if (has_min_seqno()) {
      total_size += 1 + 4;
    }

    // required fixed32 max_seqno = 2;
    if (has_max_seqno()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2p_buffermap_request_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2p_buffermap_request_msg*>(&from));
}

void p2p_buffermap_request_msg::MergeFrom(const p2p_buffermap_request_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_min_seqno()) {
      set_min_seqno(from.min_seqno());
    }
    if (from.has_max_seqno()) {
      set_max_seqno(from.max_seqno());
    }
  }
}

void p2p_buffermap_request_msg::CopyFrom(const p2p_buffermap_request_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2p_buffermap_request_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void p2p_buffermap_request_msg::Swap(p2p_buffermap_request_msg* other) {
  if (other != this) {
    std::swap(min_seqno_, other->min_seqno_);
    std::swap(max_seqno_, other->max_seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2p_buffermap_request_msg::GetTypeName() const {
  return "p2message.p2p_buffermap_request_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int p2p_neighbor_table_exchange::kSameChannelPeerInfoListFieldNumber;
const int p2p_neighbor_table_exchange::kCachePeerInfoListFieldNumber;
const int p2p_neighbor_table_exchange::kKnownNeighborListFieldNumber;
#endif  // !_MSC_VER

p2p_neighbor_table_exchange::p2p_neighbor_table_exchange()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2p_neighbor_table_exchange::InitAsDefaultInstance() {
}

p2p_neighbor_table_exchange::p2p_neighbor_table_exchange(const p2p_neighbor_table_exchange& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2p_neighbor_table_exchange::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2p_neighbor_table_exchange::~p2p_neighbor_table_exchange() {
  SharedDtor();
}

void p2p_neighbor_table_exchange::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void p2p_neighbor_table_exchange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2p_neighbor_table_exchange& p2p_neighbor_table_exchange::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2p_neighbor_table_exchange* p2p_neighbor_table_exchange::default_instance_ = NULL;

p2p_neighbor_table_exchange* p2p_neighbor_table_exchange::New() const {
  return new p2p_neighbor_table_exchange;
}

void p2p_neighbor_table_exchange::Clear() {
  same_channel_peer_info_list_.Clear();
  cache_peer_info_list_.Clear();
  known_neighbor_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2p_neighbor_table_exchange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .p2message.peer_info same_channel_peer_info_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_same_channel_peer_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_same_channel_peer_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_same_channel_peer_info_list;
        if (input->ExpectTag(18)) goto parse_cache_peer_info_list;
        break;
      }

      // repeated .p2message.peer_info cache_peer_info_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cache_peer_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cache_peer_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cache_peer_info_list;
        if (input->ExpectTag(26)) goto parse_known_neighbor_list;
        break;
      }

      // repeated bytes known_neighbor_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_known_neighbor_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_known_neighbor_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_known_neighbor_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2p_neighbor_table_exchange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .p2message.peer_info same_channel_peer_info_list = 1;
  for (int i = 0; i < this->same_channel_peer_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->same_channel_peer_info_list(i), output);
  }

  // repeated .p2message.peer_info cache_peer_info_list = 2;
  for (int i = 0; i < this->cache_peer_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->cache_peer_info_list(i), output);
  }

  // repeated bytes known_neighbor_list = 3;
  for (int i = 0; i < this->known_neighbor_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->known_neighbor_list(i), output);
  }

}

int p2p_neighbor_table_exchange::ByteSize() const {
  int total_size = 0;

  // repeated .p2message.peer_info same_channel_peer_info_list = 1;
  total_size += 1 * this->same_channel_peer_info_list_size();
  for (int i = 0; i < this->same_channel_peer_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->same_channel_peer_info_list(i));
  }

  // repeated .p2message.peer_info cache_peer_info_list = 2;
  total_size += 1 * this->cache_peer_info_list_size();
  for (int i = 0; i < this->cache_peer_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cache_peer_info_list(i));
  }

  // repeated bytes known_neighbor_list = 3;
  total_size += 1 * this->known_neighbor_list_size();
  for (int i = 0; i < this->known_neighbor_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->known_neighbor_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2p_neighbor_table_exchange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2p_neighbor_table_exchange*>(&from));
}

void p2p_neighbor_table_exchange::MergeFrom(const p2p_neighbor_table_exchange& from) {
  GOOGLE_CHECK_NE(&from, this);
  same_channel_peer_info_list_.MergeFrom(from.same_channel_peer_info_list_);
  cache_peer_info_list_.MergeFrom(from.cache_peer_info_list_);
  known_neighbor_list_.MergeFrom(from.known_neighbor_list_);
}

void p2p_neighbor_table_exchange::CopyFrom(const p2p_neighbor_table_exchange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2p_neighbor_table_exchange::IsInitialized() const {

  for (int i = 0; i < same_channel_peer_info_list_size(); i++) {
    if (!this->same_channel_peer_info_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < cache_peer_info_list_size(); i++) {
    if (!this->cache_peer_info_list(i).IsInitialized()) return false;
  }
  return true;
}

void p2p_neighbor_table_exchange::Swap(p2p_neighbor_table_exchange* other) {
  if (other != this) {
    same_channel_peer_info_list_.Swap(&other->same_channel_peer_info_list_);
    cache_peer_info_list_.Swap(&other->cache_peer_info_list_);
    known_neighbor_list_.Swap(&other->known_neighbor_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2p_neighbor_table_exchange::GetTypeName() const {
  return "p2message.p2p_neighbor_table_exchange";
}


// ===================================================================

#ifndef _MSC_VER
const int p2p_supervise_request_msg::kBuffermapFieldNumber;
const int p2p_supervise_request_msg::kPeerKeyFieldNumber;
#endif  // !_MSC_VER

p2p_supervise_request_msg::p2p_supervise_request_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void p2p_supervise_request_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buffermap_ = const_cast< ::p2message::buffermap_info*>(
      ::p2message::buffermap_info::internal_default_instance());
#else
  buffermap_ = const_cast< ::p2message::buffermap_info*>(&::p2message::buffermap_info::default_instance());
#endif
}

p2p_supervise_request_msg::p2p_supervise_request_msg(const p2p_supervise_request_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void p2p_supervise_request_msg::SharedCtor() {
  _cached_size_ = 0;
  buffermap_ = NULL;
  peer_key_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

p2p_supervise_request_msg::~p2p_supervise_request_msg() {
  SharedDtor();
}

void p2p_supervise_request_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete buffermap_;
  }
}

void p2p_supervise_request_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const p2p_supervise_request_msg& p2p_supervise_request_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

p2p_supervise_request_msg* p2p_supervise_request_msg::default_instance_ = NULL;

p2p_supervise_request_msg* p2p_supervise_request_msg::New() const {
  return new p2p_supervise_request_msg;
}

void p2p_supervise_request_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_buffermap()) {
      if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
    }
    peer_key_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool p2p_supervise_request_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2message.buffermap_info buffermap = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_peer_key;
        break;
      }

      // required uint32 peer_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_peer_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_key_)));
          set_has_peer_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void p2p_supervise_request_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .p2message.buffermap_info buffermap = 1;
  if (has_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->buffermap(), output);
  }

  // required uint32 peer_key = 2;
  if (has_peer_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->peer_key(), output);
  }

}

int p2p_supervise_request_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .p2message.buffermap_info buffermap = 1;
    if (has_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buffermap());
    }

    // required uint32 peer_key = 2;
    if (has_peer_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void p2p_supervise_request_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const p2p_supervise_request_msg*>(&from));
}

void p2p_supervise_request_msg::MergeFrom(const p2p_supervise_request_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buffermap()) {
      mutable_buffermap()->::p2message::buffermap_info::MergeFrom(from.buffermap());
    }
    if (from.has_peer_key()) {
      set_peer_key(from.peer_key());
    }
  }
}

void p2p_supervise_request_msg::CopyFrom(const p2p_supervise_request_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool p2p_supervise_request_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void p2p_supervise_request_msg::Swap(p2p_supervise_request_msg* other) {
  if (other != this) {
    std::swap(buffermap_, other->buffermap_);
    std::swap(peer_key_, other->peer_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string p2p_supervise_request_msg::GetTypeName() const {
  return "p2message.p2p_supervise_request_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int relay_msg::kLevelFieldNumber;
const int relay_msg::kMsgIdFieldNumber;
const int relay_msg::kSrcPeerIdFieldNumber;
const int relay_msg::kDstPeerIdFieldNumber;
const int relay_msg::kTtlFieldNumber;
const int relay_msg::kMsgDataFieldNumber;
const int relay_msg::kChannelUuidFieldNumber;
#endif  // !_MSC_VER

relay_msg::relay_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void relay_msg::InitAsDefaultInstance() {
}

relay_msg::relay_msg(const relay_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void relay_msg::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  msg_id_ = GOOGLE_ULONGLONG(0);
  src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dst_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ttl_ = 4u;
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

relay_msg::~relay_msg() {
  SharedDtor();
}

void relay_msg::SharedDtor() {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete src_peer_id_;
  }
  if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete dst_peer_id_;
  }
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void relay_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const relay_msg& relay_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

relay_msg* relay_msg::default_instance_ = NULL;

relay_msg* relay_msg::New() const {
  return new relay_msg;
}

void relay_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    level_ = 0;
    msg_id_ = GOOGLE_ULONGLONG(0);
    if (has_src_peer_id()) {
      if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
        src_peer_id_->clear();
      }
    }
    if (has_dst_peer_id()) {
      if (dst_peer_id_ != &::google::protobuf::internal::kEmptyString) {
        dst_peer_id_->clear();
      }
    }
    ttl_ = 4u;
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
        msg_data_->clear();
      }
    }
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool relay_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 level = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_msg_id;
        break;
      }

      // required uint64 msg_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_msg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_src_peer_id;
        break;
      }

      // required bytes src_peer_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_src_peer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_src_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_dst_peer_id;
        break;
      }

      // required bytes dst_peer_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dst_peer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dst_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ttl;
        break;
      }

      // required uint32 ttl = 5 [default = 4];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ttl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ttl_)));
          set_has_ttl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_channel_uuid;
        break;
      }

      // optional bytes channel_uuid = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void relay_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  // required uint64 msg_id = 2;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->msg_id(), output);
  }

  // required bytes src_peer_id = 3;
  if (has_src_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->src_peer_id(), output);
  }

  // required bytes dst_peer_id = 4;
  if (has_dst_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->dst_peer_id(), output);
  }

  // required uint32 ttl = 5 [default = 4];
  if (has_ttl()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ttl(), output);
  }

  // required bytes msg_data = 6;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->msg_data(), output);
  }

  // optional bytes channel_uuid = 7;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->channel_uuid(), output);
  }

}

int relay_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // required uint64 msg_id = 2;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->msg_id());
    }

    // required bytes src_peer_id = 3;
    if (has_src_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->src_peer_id());
    }

    // required bytes dst_peer_id = 4;
    if (has_dst_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dst_peer_id());
    }

    // required uint32 ttl = 5 [default = 4];
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ttl());
    }

    // required bytes msg_data = 6;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

    // optional bytes channel_uuid = 7;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void relay_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const relay_msg*>(&from));
}

void relay_msg::MergeFrom(const relay_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_src_peer_id()) {
      set_src_peer_id(from.src_peer_id());
    }
    if (from.has_dst_peer_id()) {
      set_dst_peer_id(from.dst_peer_id());
    }
    if (from.has_ttl()) {
      set_ttl(from.ttl());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
  }
}

void relay_msg::CopyFrom(const relay_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool relay_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void relay_msg::Swap(relay_msg* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(src_peer_id_, other->src_peer_id_);
    std::swap(dst_peer_id_, other->dst_peer_id_);
    std::swap(ttl_, other->ttl_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string relay_msg::GetTypeName() const {
  return "p2message.relay_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int broadcast_msg::kLevelFieldNumber;
const int broadcast_msg::kMsgIdFieldNumber;
const int broadcast_msg::kSrcPeerIdFieldNumber;
const int broadcast_msg::kTtlFieldNumber;
const int broadcast_msg::kBloomfilterFieldNumber;
const int broadcast_msg::kMsgDataFieldNumber;
#endif  // !_MSC_VER

broadcast_msg::broadcast_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void broadcast_msg::InitAsDefaultInstance() {
}

broadcast_msg::broadcast_msg(const broadcast_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void broadcast_msg::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  msg_id_ = GOOGLE_ULONGLONG(0);
  src_peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ttl_ = 4u;
  bloomfilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

broadcast_msg::~broadcast_msg() {
  SharedDtor();
}

void broadcast_msg::SharedDtor() {
  if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete src_peer_id_;
  }
  if (bloomfilter_ != &::google::protobuf::internal::kEmptyString) {
    delete bloomfilter_;
  }
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void broadcast_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const broadcast_msg& broadcast_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

broadcast_msg* broadcast_msg::default_instance_ = NULL;

broadcast_msg* broadcast_msg::New() const {
  return new broadcast_msg;
}

void broadcast_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    level_ = 0;
    msg_id_ = GOOGLE_ULONGLONG(0);
    if (has_src_peer_id()) {
      if (src_peer_id_ != &::google::protobuf::internal::kEmptyString) {
        src_peer_id_->clear();
      }
    }
    ttl_ = 4u;
    if (has_bloomfilter()) {
      if (bloomfilter_ != &::google::protobuf::internal::kEmptyString) {
        bloomfilter_->clear();
      }
    }
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
        msg_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool broadcast_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 level = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_msg_id;
        break;
      }

      // required uint64 msg_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_msg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_src_peer_id;
        break;
      }

      // required bytes src_peer_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_src_peer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_src_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ttl;
        break;
      }

      // required uint32 ttl = 4 [default = 4];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ttl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ttl_)));
          set_has_ttl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_bloomfilter;
        break;
      }

      // optional bytes bloomfilter = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bloomfilter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bloomfilter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void broadcast_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  // required uint64 msg_id = 2;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->msg_id(), output);
  }

  // required bytes src_peer_id = 3;
  if (has_src_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->src_peer_id(), output);
  }

  // required uint32 ttl = 4 [default = 4];
  if (has_ttl()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->ttl(), output);
  }

  // optional bytes bloomfilter = 5;
  if (has_bloomfilter()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->bloomfilter(), output);
  }

  // required bytes msg_data = 6;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->msg_data(), output);
  }

}

int broadcast_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // required uint64 msg_id = 2;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->msg_id());
    }

    // required bytes src_peer_id = 3;
    if (has_src_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->src_peer_id());
    }

    // required uint32 ttl = 4 [default = 4];
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ttl());
    }

    // optional bytes bloomfilter = 5;
    if (has_bloomfilter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bloomfilter());
    }

    // required bytes msg_data = 6;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void broadcast_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const broadcast_msg*>(&from));
}

void broadcast_msg::MergeFrom(const broadcast_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_src_peer_id()) {
      set_src_peer_id(from.src_peer_id());
    }
    if (from.has_ttl()) {
      set_ttl(from.ttl());
    }
    if (from.has_bloomfilter()) {
      set_bloomfilter(from.bloomfilter());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
  }
}

void broadcast_msg::CopyFrom(const broadcast_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool broadcast_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000002f) != 0x0000002f) return false;

  return true;
}

void broadcast_msg::Swap(broadcast_msg* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(src_peer_id_, other->src_peer_id_);
    std::swap(ttl_, other->ttl_);
    std::swap(bloomfilter_, other->bloomfilter_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string broadcast_msg::GetTypeName() const {
  return "p2message.broadcast_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int buffermap_exchange_msg::kBuffermapFieldNumber;
const int buffermap_exchange_msg::kCurrentPlayingTimestampFieldNumber;
#endif  // !_MSC_VER

buffermap_exchange_msg::buffermap_exchange_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void buffermap_exchange_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buffermap_ = const_cast< ::p2message::buffermap_info*>(
      ::p2message::buffermap_info::internal_default_instance());
#else
  buffermap_ = const_cast< ::p2message::buffermap_info*>(&::p2message::buffermap_info::default_instance());
#endif
}

buffermap_exchange_msg::buffermap_exchange_msg(const buffermap_exchange_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void buffermap_exchange_msg::SharedCtor() {
  _cached_size_ = 0;
  buffermap_ = NULL;
  current_playing_timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

buffermap_exchange_msg::~buffermap_exchange_msg() {
  SharedDtor();
}

void buffermap_exchange_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete buffermap_;
  }
}

void buffermap_exchange_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const buffermap_exchange_msg& buffermap_exchange_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

buffermap_exchange_msg* buffermap_exchange_msg::default_instance_ = NULL;

buffermap_exchange_msg* buffermap_exchange_msg::New() const {
  return new buffermap_exchange_msg;
}

void buffermap_exchange_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_buffermap()) {
      if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
    }
    current_playing_timestamp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool buffermap_exchange_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2message.buffermap_info buffermap = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_current_playing_timestamp;
        break;
      }

      // optional sfixed32 current_playing_timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_current_playing_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &current_playing_timestamp_)));
          set_has_current_playing_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void buffermap_exchange_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .p2message.buffermap_info buffermap = 1;
  if (has_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->buffermap(), output);
  }

  // optional sfixed32 current_playing_timestamp = 2;
  if (has_current_playing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(2, this->current_playing_timestamp(), output);
  }

}

int buffermap_exchange_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .p2message.buffermap_info buffermap = 1;
    if (has_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buffermap());
    }

    // optional sfixed32 current_playing_timestamp = 2;
    if (has_current_playing_timestamp()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void buffermap_exchange_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const buffermap_exchange_msg*>(&from));
}

void buffermap_exchange_msg::MergeFrom(const buffermap_exchange_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buffermap()) {
      mutable_buffermap()->::p2message::buffermap_info::MergeFrom(from.buffermap());
    }
    if (from.has_current_playing_timestamp()) {
      set_current_playing_timestamp(from.current_playing_timestamp());
    }
  }
}

void buffermap_exchange_msg::CopyFrom(const buffermap_exchange_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool buffermap_exchange_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void buffermap_exchange_msg::Swap(buffermap_exchange_msg* other) {
  if (other != this) {
    std::swap(buffermap_, other->buffermap_);
    std::swap(current_playing_timestamp_, other->current_playing_timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string buffermap_exchange_msg::GetTypeName() const {
  return "p2message.buffermap_exchange_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int join_channel_msg::kChannelIdFieldNumber;
#endif  // !_MSC_VER

join_channel_msg::join_channel_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void join_channel_msg::InitAsDefaultInstance() {
}

join_channel_msg::join_channel_msg(const join_channel_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void join_channel_msg::SharedCtor() {
  _cached_size_ = 0;
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

join_channel_msg::~join_channel_msg() {
  SharedDtor();
}

void join_channel_msg::SharedDtor() {
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void join_channel_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const join_channel_msg& join_channel_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

join_channel_msg* join_channel_msg::default_instance_ = NULL;

join_channel_msg* join_channel_msg::New() const {
  return new join_channel_msg;
}

void join_channel_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool join_channel_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes channel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void join_channel_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes channel_id = 1;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->channel_id(), output);
  }

}

int join_channel_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes channel_id = 1;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void join_channel_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const join_channel_msg*>(&from));
}

void join_channel_msg::MergeFrom(const join_channel_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
  }
}

void join_channel_msg::CopyFrom(const join_channel_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool join_channel_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void join_channel_msg::Swap(join_channel_msg* other) {
  if (other != this) {
    std::swap(channel_id_, other->channel_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string join_channel_msg::GetTypeName() const {
  return "p2message.join_channel_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int media_request_msg::kDirectRequestFieldNumber;
const int media_request_msg::kPeerIdFieldNumber;
const int media_request_msg::kSeqnoFieldNumber;
const int media_request_msg::kCurrentPlayingTimestampFieldNumber;
const int media_request_msg::kChannelIdFieldNumber;
const int media_request_msg::kBuffermapFieldNumber;
#endif  // !_MSC_VER

media_request_msg::media_request_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void media_request_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buffermap_ = const_cast< ::p2message::buffermap_info*>(
      ::p2message::buffermap_info::internal_default_instance());
#else
  buffermap_ = const_cast< ::p2message::buffermap_info*>(&::p2message::buffermap_info::default_instance());
#endif
}

media_request_msg::media_request_msg(const media_request_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void media_request_msg::SharedCtor() {
  _cached_size_ = 0;
  direct_request_ = false;
  peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  current_playing_timestamp_ = 0;
  channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buffermap_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

media_request_msg::~media_request_msg() {
  SharedDtor();
}

void media_request_msg::SharedDtor() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete buffermap_;
  }
}

void media_request_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const media_request_msg& media_request_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

media_request_msg* media_request_msg::default_instance_ = NULL;

media_request_msg* media_request_msg::New() const {
  return new media_request_msg;
}

void media_request_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    direct_request_ = false;
    if (has_peer_id()) {
      if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
        peer_id_->clear();
      }
    }
    current_playing_timestamp_ = 0;
    if (has_channel_id()) {
      if (channel_id_ != &::google::protobuf::internal::kEmptyString) {
        channel_id_->clear();
      }
    }
    if (has_buffermap()) {
      if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
    }
  }
  seqno_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool media_request_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool direct_request = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &direct_request_)));
          set_has_direct_request();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_peer_id;
        break;
      }

      // required bytes peer_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_peer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_seqno;
        break;
      }

      // repeated fixed32 seqno = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 29, input, this->mutable_seqno())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_seqno())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_seqno;
        if (input->ExpectTag(37)) goto parse_current_playing_timestamp;
        break;
      }

      // optional sfixed32 current_playing_timestamp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_current_playing_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &current_playing_timestamp_)));
          set_has_current_playing_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_channel_id;
        break;
      }

      // optional bytes channel_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_buffermap;
        break;
      }

      // optional .p2message.buffermap_info buffermap = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buffermap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void media_request_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool direct_request = 1;
  if (has_direct_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->direct_request(), output);
  }

  // required bytes peer_id = 2;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->peer_id(), output);
  }

  // repeated fixed32 seqno = 3;
  for (int i = 0; i < this->seqno_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      3, this->seqno(i), output);
  }

  // optional sfixed32 current_playing_timestamp = 4;
  if (has_current_playing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(4, this->current_playing_timestamp(), output);
  }

  // optional bytes channel_id = 5;
  if (has_channel_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->channel_id(), output);
  }

  // optional .p2message.buffermap_info buffermap = 6;
  if (has_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->buffermap(), output);
  }

}

int media_request_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool direct_request = 1;
    if (has_direct_request()) {
      total_size += 1 + 1;
    }

    // required bytes peer_id = 2;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->peer_id());
    }

    // optional sfixed32 current_playing_timestamp = 4;
    if (has_current_playing_timestamp()) {
      total_size += 1 + 4;
    }

    // optional bytes channel_id = 5;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_id());
    }

    // optional .p2message.buffermap_info buffermap = 6;
    if (has_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buffermap());
    }

  }
  // repeated fixed32 seqno = 3;
  {
    int data_size = 0;
    data_size = 4 * this->seqno_size();
    total_size += 1 * this->seqno_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void media_request_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const media_request_msg*>(&from));
}

void media_request_msg::MergeFrom(const media_request_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  seqno_.MergeFrom(from.seqno_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_direct_request()) {
      set_direct_request(from.direct_request());
    }
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_current_playing_timestamp()) {
      set_current_playing_timestamp(from.current_playing_timestamp());
    }
    if (from.has_channel_id()) {
      set_channel_id(from.channel_id());
    }
    if (from.has_buffermap()) {
      mutable_buffermap()->::p2message::buffermap_info::MergeFrom(from.buffermap());
    }
  }
}

void media_request_msg::CopyFrom(const media_request_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool media_request_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void media_request_msg::Swap(media_request_msg* other) {
  if (other != this) {
    std::swap(direct_request_, other->direct_request_);
    std::swap(peer_id_, other->peer_id_);
    seqno_.Swap(&other->seqno_);
    std::swap(current_playing_timestamp_, other->current_playing_timestamp_);
    std::swap(channel_id_, other->channel_id_);
    std::swap(buffermap_, other->buffermap_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string media_request_msg::GetTypeName() const {
  return "p2message.media_request_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int media_subscription_msg::kSubstreamIdFieldNumber;
const int media_subscription_msg::kBuffermapFieldNumber;
const int media_subscription_msg::kIgnoreSeqnoListFieldNumber;
const int media_subscription_msg::kCurrentPlayingTimestampFieldNumber;
#endif  // !_MSC_VER

media_subscription_msg::media_subscription_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void media_subscription_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buffermap_ = const_cast< ::p2message::buffermap_info*>(
      ::p2message::buffermap_info::internal_default_instance());
#else
  buffermap_ = const_cast< ::p2message::buffermap_info*>(&::p2message::buffermap_info::default_instance());
#endif
}

media_subscription_msg::media_subscription_msg(const media_subscription_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void media_subscription_msg::SharedCtor() {
  _cached_size_ = 0;
  buffermap_ = NULL;
  current_playing_timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

media_subscription_msg::~media_subscription_msg() {
  SharedDtor();
}

void media_subscription_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete buffermap_;
  }
}

void media_subscription_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const media_subscription_msg& media_subscription_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

media_subscription_msg* media_subscription_msg::default_instance_ = NULL;

media_subscription_msg* media_subscription_msg::New() const {
  return new media_subscription_msg;
}

void media_subscription_msg::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_buffermap()) {
      if (buffermap_ != NULL) buffermap_->::p2message::buffermap_info::Clear();
    }
    current_playing_timestamp_ = 0;
  }
  substream_id_.Clear();
  ignore_seqno_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool media_subscription_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 substream_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_substream_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_substream_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_substream_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_substream_id;
        if (input->ExpectTag(18)) goto parse_buffermap;
        break;
      }

      // required .p2message.buffermap_info buffermap = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buffermap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buffermap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_ignore_seqno_list;
        break;
      }

      // repeated fixed32 ignore_seqno_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ignore_seqno_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 29, input, this->mutable_ignore_seqno_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_ignore_seqno_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_ignore_seqno_list;
        if (input->ExpectTag(37)) goto parse_current_playing_timestamp;
        break;
      }

      // optional sfixed32 current_playing_timestamp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_current_playing_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &current_playing_timestamp_)));
          set_has_current_playing_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void media_subscription_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 substream_id = 1;
  for (int i = 0; i < this->substream_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->substream_id(i), output);
  }

  // required .p2message.buffermap_info buffermap = 2;
  if (has_buffermap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->buffermap(), output);
  }

  // repeated fixed32 ignore_seqno_list = 3;
  for (int i = 0; i < this->ignore_seqno_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      3, this->ignore_seqno_list(i), output);
  }

  // optional sfixed32 current_playing_timestamp = 4;
  if (has_current_playing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(4, this->current_playing_timestamp(), output);
  }

}

int media_subscription_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required .p2message.buffermap_info buffermap = 2;
    if (has_buffermap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buffermap());
    }

    // optional sfixed32 current_playing_timestamp = 4;
    if (has_current_playing_timestamp()) {
      total_size += 1 + 4;
    }

  }
  // repeated uint32 substream_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->substream_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->substream_id(i));
    }
    total_size += 1 * this->substream_id_size() + data_size;
  }

  // repeated fixed32 ignore_seqno_list = 3;
  {
    int data_size = 0;
    data_size = 4 * this->ignore_seqno_list_size();
    total_size += 1 * this->ignore_seqno_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void media_subscription_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const media_subscription_msg*>(&from));
}

void media_subscription_msg::MergeFrom(const media_subscription_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  substream_id_.MergeFrom(from.substream_id_);
  ignore_seqno_list_.MergeFrom(from.ignore_seqno_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_buffermap()) {
      mutable_buffermap()->::p2message::buffermap_info::MergeFrom(from.buffermap());
    }
    if (from.has_current_playing_timestamp()) {
      set_current_playing_timestamp(from.current_playing_timestamp());
    }
  }
}

void media_subscription_msg::CopyFrom(const media_subscription_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool media_subscription_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void media_subscription_msg::Swap(media_subscription_msg* other) {
  if (other != this) {
    substream_id_.Swap(&other->substream_id_);
    std::swap(buffermap_, other->buffermap_);
    ignore_seqno_list_.Swap(&other->ignore_seqno_list_);
    std::swap(current_playing_timestamp_, other->current_playing_timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string media_subscription_msg::GetTypeName() const {
  return "p2message.media_subscription_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int punch_request_msg::kIpFieldNumber;
const int punch_request_msg::kPortFieldNumber;
const int punch_request_msg::kMsgDataFieldNumber;
#endif  // !_MSC_VER

punch_request_msg::punch_request_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void punch_request_msg::InitAsDefaultInstance() {
}

punch_request_msg::punch_request_msg(const punch_request_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void punch_request_msg::SharedCtor() {
  _cached_size_ = 0;
  ip_ = 0u;
  port_ = 0u;
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

punch_request_msg::~punch_request_msg() {
  SharedDtor();
}

void punch_request_msg::SharedDtor() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void punch_request_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const punch_request_msg& punch_request_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

punch_request_msg* punch_request_msg::default_instance_ = NULL;

punch_request_msg* punch_request_msg::New() const {
  return new punch_request_msg;
}

void punch_request_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ip_ = 0u;
    port_ = 0u;
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
        msg_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool punch_request_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ip_)));
          set_has_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void punch_request_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ip(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

  // required bytes msg_data = 3;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->msg_data(), output);
  }

}

int punch_request_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ip());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // required bytes msg_data = 3;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void punch_request_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const punch_request_msg*>(&from));
}

void punch_request_msg::MergeFrom(const punch_request_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
  }
}

void punch_request_msg::CopyFrom(const punch_request_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool punch_request_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void punch_request_msg::Swap(punch_request_msg* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string punch_request_msg::GetTypeName() const {
  return "p2message.punch_request_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int media_sent_confirm_msg::kSeqnoFieldNumber;
#endif  // !_MSC_VER

media_sent_confirm_msg::media_sent_confirm_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void media_sent_confirm_msg::InitAsDefaultInstance() {
}

media_sent_confirm_msg::media_sent_confirm_msg(const media_sent_confirm_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void media_sent_confirm_msg::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

media_sent_confirm_msg::~media_sent_confirm_msg() {
  SharedDtor();
}

void media_sent_confirm_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void media_sent_confirm_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const media_sent_confirm_msg& media_sent_confirm_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

media_sent_confirm_msg* media_sent_confirm_msg::default_instance_ = NULL;

media_sent_confirm_msg* media_sent_confirm_msg::New() const {
  return new media_sent_confirm_msg;
}

void media_sent_confirm_msg::Clear() {
  seqno_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool media_sent_confirm_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated fixed32 seqno = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 13, input, this->mutable_seqno())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_seqno())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(13)) goto parse_seqno;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void media_sent_confirm_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated fixed32 seqno = 1;
  for (int i = 0; i < this->seqno_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      1, this->seqno(i), output);
  }

}

int media_sent_confirm_msg::ByteSize() const {
  int total_size = 0;

  // repeated fixed32 seqno = 1;
  {
    int data_size = 0;
    data_size = 4 * this->seqno_size();
    total_size += 1 * this->seqno_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void media_sent_confirm_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const media_sent_confirm_msg*>(&from));
}

void media_sent_confirm_msg::MergeFrom(const media_sent_confirm_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  seqno_.MergeFrom(from.seqno_);
}

void media_sent_confirm_msg::CopyFrom(const media_sent_confirm_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool media_sent_confirm_msg::IsInitialized() const {

  return true;
}

void media_sent_confirm_msg::Swap(media_sent_confirm_msg* other) {
  if (other != this) {
    seqno_.Swap(&other->seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string media_sent_confirm_msg::GetTypeName() const {
  return "p2message.media_sent_confirm_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int no_piece_msg::kSeqnoFieldNumber;
const int no_piece_msg::kMinSeqnoFieldNumber;
const int no_piece_msg::kMaxSeqnoFieldNumber;
const int no_piece_msg::kWaitTimeFieldNumber;
#endif  // !_MSC_VER

no_piece_msg::no_piece_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void no_piece_msg::InitAsDefaultInstance() {
}

no_piece_msg::no_piece_msg(const no_piece_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void no_piece_msg::SharedCtor() {
  _cached_size_ = 0;
  seqno_ = 0u;
  min_seqno_ = 0u;
  max_seqno_ = 0u;
  wait_time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

no_piece_msg::~no_piece_msg() {
  SharedDtor();
}

void no_piece_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void no_piece_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const no_piece_msg& no_piece_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

no_piece_msg* no_piece_msg::default_instance_ = NULL;

no_piece_msg* no_piece_msg::New() const {
  return new no_piece_msg;
}

void no_piece_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seqno_ = 0u;
    min_seqno_ = 0u;
    max_seqno_ = 0u;
    wait_time_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool no_piece_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed32 seqno = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &seqno_)));
          set_has_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_min_seqno;
        break;
      }

      // optional fixed32 min_seqno = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &min_seqno_)));
          set_has_min_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_max_seqno;
        break;
      }

      // optional fixed32 max_seqno = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &max_seqno_)));
          set_has_max_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_wait_time;
        break;
      }

      // optional int32 wait_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_wait_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wait_time_)));
          set_has_wait_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void no_piece_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed32 seqno = 1;
  if (has_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->seqno(), output);
  }

  // optional fixed32 min_seqno = 2;
  if (has_min_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->min_seqno(), output);
  }

  // optional fixed32 max_seqno = 3;
  if (has_max_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->max_seqno(), output);
  }

  // optional int32 wait_time = 4;
  if (has_wait_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->wait_time(), output);
  }

}

int no_piece_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed32 seqno = 1;
    if (has_seqno()) {
      total_size += 1 + 4;
    }

    // optional fixed32 min_seqno = 2;
    if (has_min_seqno()) {
      total_size += 1 + 4;
    }

    // optional fixed32 max_seqno = 3;
    if (has_max_seqno()) {
      total_size += 1 + 4;
    }

    // optional int32 wait_time = 4;
    if (has_wait_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wait_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void no_piece_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const no_piece_msg*>(&from));
}

void no_piece_msg::MergeFrom(const no_piece_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seqno()) {
      set_seqno(from.seqno());
    }
    if (from.has_min_seqno()) {
      set_min_seqno(from.min_seqno());
    }
    if (from.has_max_seqno()) {
      set_max_seqno(from.max_seqno());
    }
    if (from.has_wait_time()) {
      set_wait_time(from.wait_time());
    }
  }
}

void no_piece_msg::CopyFrom(const no_piece_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool no_piece_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void no_piece_msg::Swap(no_piece_msg* other) {
  if (other != this) {
    std::swap(seqno_, other->seqno_);
    std::swap(min_seqno_, other->min_seqno_);
    std::swap(max_seqno_, other->max_seqno_);
    std::swap(wait_time_, other->wait_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string no_piece_msg::GetTypeName() const {
  return "p2message.no_piece_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int time_server_2_tracker::kCurrTimeFieldNumber;
#endif  // !_MSC_VER

time_server_2_tracker::time_server_2_tracker()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void time_server_2_tracker::InitAsDefaultInstance() {
}

time_server_2_tracker::time_server_2_tracker(const time_server_2_tracker& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void time_server_2_tracker::SharedCtor() {
  _cached_size_ = 0;
  curr_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

time_server_2_tracker::~time_server_2_tracker() {
  SharedDtor();
}

void time_server_2_tracker::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void time_server_2_tracker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const time_server_2_tracker& time_server_2_tracker::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

time_server_2_tracker* time_server_2_tracker::default_instance_ = NULL;

time_server_2_tracker* time_server_2_tracker::New() const {
  return new time_server_2_tracker;
}

void time_server_2_tracker::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    curr_time_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool time_server_2_tracker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 curr_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &curr_time_)));
          set_has_curr_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void time_server_2_tracker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 curr_time = 1;
  if (has_curr_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->curr_time(), output);
  }

}

int time_server_2_tracker::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 curr_time = 1;
    if (has_curr_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->curr_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void time_server_2_tracker::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const time_server_2_tracker*>(&from));
}

void time_server_2_tracker::MergeFrom(const time_server_2_tracker& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_curr_time()) {
      set_curr_time(from.curr_time());
    }
  }
}

void time_server_2_tracker::CopyFrom(const time_server_2_tracker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool time_server_2_tracker::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void time_server_2_tracker::Swap(time_server_2_tracker* other) {
  if (other != this) {
    std::swap(curr_time_, other->curr_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string time_server_2_tracker::GetTypeName() const {
  return "p2message.time_server_2_tracker";
}


// ===================================================================

#ifndef _MSC_VER
const int ctrl2m_create_channel_msg::kTypeFieldNumber;
const int ctrl2m_create_channel_msg::kNameFieldNumber;
const int ctrl2m_create_channel_msg::kChannelLinkFieldNumber;
const int ctrl2m_create_channel_msg::kChannelUuidFieldNumber;
const int ctrl2m_create_channel_msg::kInternalAddressFieldNumber;
const int ctrl2m_create_channel_msg::kExternalAddressFieldNumber;
const int ctrl2m_create_channel_msg::kTrackerAddressFieldNumber;
const int ctrl2m_create_channel_msg::kEnableLiveCacheFieldNumber;
const int ctrl2m_create_channel_msg::kStreamRecvUrlFieldNumber;
const int ctrl2m_create_channel_msg::kLiveCacheDirFieldNumber;
const int ctrl2m_create_channel_msg::kMaxDurationFieldNumber;
const int ctrl2m_create_channel_msg::kMaxLengthPerFileFieldNumber;
const int ctrl2m_create_channel_msg::kMediaDirectoryFieldNumber;
const int ctrl2m_create_channel_msg::kDurationFieldNumber;
const int ctrl2m_create_channel_msg::kLengthFieldNumber;
const int ctrl2m_create_channel_msg::kChannelKeyFieldNumber;
#endif  // !_MSC_VER

ctrl2m_create_channel_msg::ctrl2m_create_channel_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ctrl2m_create_channel_msg::InitAsDefaultInstance() {
}

ctrl2m_create_channel_msg::ctrl2m_create_channel_msg(const ctrl2m_create_channel_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ctrl2m_create_channel_msg::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  internal_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  external_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  enable_live_cache_ = false;
  stream_recv_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  live_cache_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  max_duration_ = GOOGLE_ULONGLONG(0);
  max_length_per_file_ = GOOGLE_ULONGLONG(0);
  media_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  duration_ = GOOGLE_ULONGLONG(0);
  length_ = GOOGLE_ULONGLONG(0);
  channel_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ctrl2m_create_channel_msg::~ctrl2m_create_channel_msg() {
  SharedDtor();
}

void ctrl2m_create_channel_msg::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_link_;
  }
  if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_uuid_;
  }
  if (internal_address_ != &::google::protobuf::internal::kEmptyString) {
    delete internal_address_;
  }
  if (external_address_ != &::google::protobuf::internal::kEmptyString) {
    delete external_address_;
  }
  if (stream_recv_url_ != &::google::protobuf::internal::kEmptyString) {
    delete stream_recv_url_;
  }
  if (live_cache_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete live_cache_dir_;
  }
  if (media_directory_ != &::google::protobuf::internal::kEmptyString) {
    delete media_directory_;
  }
  if (channel_key_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ctrl2m_create_channel_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ctrl2m_create_channel_msg& ctrl2m_create_channel_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ctrl2m_create_channel_msg* ctrl2m_create_channel_msg::default_instance_ = NULL;

ctrl2m_create_channel_msg* ctrl2m_create_channel_msg::New() const {
  return new ctrl2m_create_channel_msg;
}

void ctrl2m_create_channel_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_channel_link()) {
      if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
        channel_link_->clear();
      }
    }
    if (has_channel_uuid()) {
      if (channel_uuid_ != &::google::protobuf::internal::kEmptyString) {
        channel_uuid_->clear();
      }
    }
    if (has_internal_address()) {
      if (internal_address_ != &::google::protobuf::internal::kEmptyString) {
        internal_address_->clear();
      }
    }
    if (has_external_address()) {
      if (external_address_ != &::google::protobuf::internal::kEmptyString) {
        external_address_->clear();
      }
    }
    enable_live_cache_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_stream_recv_url()) {
      if (stream_recv_url_ != &::google::protobuf::internal::kEmptyString) {
        stream_recv_url_->clear();
      }
    }
    if (has_live_cache_dir()) {
      if (live_cache_dir_ != &::google::protobuf::internal::kEmptyString) {
        live_cache_dir_->clear();
      }
    }
    max_duration_ = GOOGLE_ULONGLONG(0);
    max_length_per_file_ = GOOGLE_ULONGLONG(0);
    if (has_media_directory()) {
      if (media_directory_ != &::google::protobuf::internal::kEmptyString) {
        media_directory_->clear();
      }
    }
    duration_ = GOOGLE_ULONGLONG(0);
    length_ = GOOGLE_ULONGLONG(0);
    if (has_channel_key()) {
      if (channel_key_ != &::google::protobuf::internal::kEmptyString) {
        channel_key_->clear();
      }
    }
  }
  tracker_address_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ctrl2m_create_channel_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required bytes name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_link;
        break;
      }

      // required bytes channel_link = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_link:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_link()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_channel_uuid;
        break;
      }

      // required bytes channel_uuid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_internal_address;
        break;
      }

      // required bytes internal_address = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_internal_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_internal_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_external_address;
        break;
      }

      // required bytes external_address = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_external_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_external_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_tracker_address;
        break;
      }

      // repeated bytes tracker_address = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tracker_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_tracker_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_tracker_address;
        if (input->ExpectTag(64)) goto parse_enable_live_cache;
        break;
      }

      // optional bool enable_live_cache = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enable_live_cache:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_live_cache_)));
          set_has_enable_live_cache();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_stream_recv_url;
        break;
      }

      // optional bytes stream_recv_url = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stream_recv_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_stream_recv_url()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_live_cache_dir;
        break;
      }

      // optional bytes live_cache_dir = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_live_cache_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_live_cache_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_max_duration;
        break;
      }

      // optional uint64 max_duration = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_duration_)));
          set_has_max_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_max_length_per_file;
        break;
      }

      // optional uint64 max_length_per_file = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_length_per_file:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_length_per_file_)));
          set_has_max_length_per_file();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_media_directory;
        break;
      }

      // optional bytes media_directory = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_media_directory:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_media_directory()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_duration;
        break;
      }

      // optional uint64 duration = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_length;
        break;
      }

      // optional uint64 length = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_channel_key;
        break;
      }

      // optional bytes channel_key = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_channel_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ctrl2m_create_channel_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required bytes name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->name(), output);
  }

  // required bytes channel_link = 3;
  if (has_channel_link()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->channel_link(), output);
  }

  // required bytes channel_uuid = 4;
  if (has_channel_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->channel_uuid(), output);
  }

  // required bytes internal_address = 5;
  if (has_internal_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->internal_address(), output);
  }

  // required bytes external_address = 6;
  if (has_external_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->external_address(), output);
  }

  // repeated bytes tracker_address = 7;
  for (int i = 0; i < this->tracker_address_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->tracker_address(i), output);
  }

  // optional bool enable_live_cache = 8;
  if (has_enable_live_cache()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->enable_live_cache(), output);
  }

  // optional bytes stream_recv_url = 9;
  if (has_stream_recv_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->stream_recv_url(), output);
  }

  // optional bytes live_cache_dir = 10;
  if (has_live_cache_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->live_cache_dir(), output);
  }

  // optional uint64 max_duration = 11;
  if (has_max_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->max_duration(), output);
  }

  // optional uint64 max_length_per_file = 12;
  if (has_max_length_per_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->max_length_per_file(), output);
  }

  // optional bytes media_directory = 13;
  if (has_media_directory()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      13, this->media_directory(), output);
  }

  // optional uint64 duration = 14;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->duration(), output);
  }

  // optional uint64 length = 15;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->length(), output);
  }

  // optional bytes channel_key = 16;
  if (has_channel_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      16, this->channel_key(), output);
  }

}

int ctrl2m_create_channel_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required bytes name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // required bytes channel_link = 3;
    if (has_channel_link()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_link());
    }

    // required bytes channel_uuid = 4;
    if (has_channel_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_uuid());
    }

    // required bytes internal_address = 5;
    if (has_internal_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->internal_address());
    }

    // required bytes external_address = 6;
    if (has_external_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->external_address());
    }

    // optional bool enable_live_cache = 8;
    if (has_enable_live_cache()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes stream_recv_url = 9;
    if (has_stream_recv_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->stream_recv_url());
    }

    // optional bytes live_cache_dir = 10;
    if (has_live_cache_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->live_cache_dir());
    }

    // optional uint64 max_duration = 11;
    if (has_max_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_duration());
    }

    // optional uint64 max_length_per_file = 12;
    if (has_max_length_per_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_length_per_file());
    }

    // optional bytes media_directory = 13;
    if (has_media_directory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->media_directory());
    }

    // optional uint64 duration = 14;
    if (has_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->duration());
    }

    // optional uint64 length = 15;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->length());
    }

    // optional bytes channel_key = 16;
    if (has_channel_key()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->channel_key());
    }

  }
  // repeated bytes tracker_address = 7;
  total_size += 1 * this->tracker_address_size();
  for (int i = 0; i < this->tracker_address_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->tracker_address(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ctrl2m_create_channel_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ctrl2m_create_channel_msg*>(&from));
}

void ctrl2m_create_channel_msg::MergeFrom(const ctrl2m_create_channel_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  tracker_address_.MergeFrom(from.tracker_address_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_channel_link()) {
      set_channel_link(from.channel_link());
    }
    if (from.has_channel_uuid()) {
      set_channel_uuid(from.channel_uuid());
    }
    if (from.has_internal_address()) {
      set_internal_address(from.internal_address());
    }
    if (from.has_external_address()) {
      set_external_address(from.external_address());
    }
    if (from.has_enable_live_cache()) {
      set_enable_live_cache(from.enable_live_cache());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_stream_recv_url()) {
      set_stream_recv_url(from.stream_recv_url());
    }
    if (from.has_live_cache_dir()) {
      set_live_cache_dir(from.live_cache_dir());
    }
    if (from.has_max_duration()) {
      set_max_duration(from.max_duration());
    }
    if (from.has_max_length_per_file()) {
      set_max_length_per_file(from.max_length_per_file());
    }
    if (from.has_media_directory()) {
      set_media_directory(from.media_directory());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_channel_key()) {
      set_channel_key(from.channel_key());
    }
  }
}

void ctrl2m_create_channel_msg::CopyFrom(const ctrl2m_create_channel_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ctrl2m_create_channel_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void ctrl2m_create_channel_msg::Swap(ctrl2m_create_channel_msg* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(name_, other->name_);
    std::swap(channel_link_, other->channel_link_);
    std::swap(channel_uuid_, other->channel_uuid_);
    std::swap(internal_address_, other->internal_address_);
    std::swap(external_address_, other->external_address_);
    tracker_address_.Swap(&other->tracker_address_);
    std::swap(enable_live_cache_, other->enable_live_cache_);
    std::swap(stream_recv_url_, other->stream_recv_url_);
    std::swap(live_cache_dir_, other->live_cache_dir_);
    std::swap(max_duration_, other->max_duration_);
    std::swap(max_length_per_file_, other->max_length_per_file_);
    std::swap(media_directory_, other->media_directory_);
    std::swap(duration_, other->duration_);
    std::swap(length_, other->length_);
    std::swap(channel_key_, other->channel_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ctrl2m_create_channel_msg::GetTypeName() const {
  return "p2message.ctrl2m_create_channel_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int ctrl2s_create_channel_msg::kIdFieldNumber;
const int ctrl2s_create_channel_msg::kReceiveUrlFieldNumber;
const int ctrl2s_create_channel_msg::kSendUrlsFieldNumber;
#endif  // !_MSC_VER

ctrl2s_create_channel_msg::ctrl2s_create_channel_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ctrl2s_create_channel_msg::InitAsDefaultInstance() {
}

ctrl2s_create_channel_msg::ctrl2s_create_channel_msg(const ctrl2s_create_channel_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ctrl2s_create_channel_msg::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  receive_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ctrl2s_create_channel_msg::~ctrl2s_create_channel_msg() {
  SharedDtor();
}

void ctrl2s_create_channel_msg::SharedDtor() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (receive_url_ != &::google::protobuf::internal::kEmptyString) {
    delete receive_url_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ctrl2s_create_channel_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ctrl2s_create_channel_msg& ctrl2s_create_channel_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

ctrl2s_create_channel_msg* ctrl2s_create_channel_msg::default_instance_ = NULL;

ctrl2s_create_channel_msg* ctrl2s_create_channel_msg::New() const {
  return new ctrl2s_create_channel_msg;
}

void ctrl2s_create_channel_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    if (has_receive_url()) {
      if (receive_url_ != &::google::protobuf::internal::kEmptyString) {
        receive_url_->clear();
      }
    }
  }
  send_urls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ctrl2s_create_channel_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_receive_url;
        break;
      }

      // required bytes receive_url = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_receive_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_receive_url()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_send_urls;
        break;
      }

      // repeated bytes send_urls = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_send_urls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_send_urls()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_send_urls;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ctrl2s_create_channel_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->id(), output);
  }

  // required bytes receive_url = 2;
  if (has_receive_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->receive_url(), output);
  }

  // repeated bytes send_urls = 3;
  for (int i = 0; i < this->send_urls_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->send_urls(i), output);
  }

}

int ctrl2s_create_channel_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->id());
    }

    // required bytes receive_url = 2;
    if (has_receive_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->receive_url());
    }

  }
  // repeated bytes send_urls = 3;
  total_size += 1 * this->send_urls_size();
  for (int i = 0; i < this->send_urls_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->send_urls(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ctrl2s_create_channel_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ctrl2s_create_channel_msg*>(&from));
}

void ctrl2s_create_channel_msg::MergeFrom(const ctrl2s_create_channel_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  send_urls_.MergeFrom(from.send_urls_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_receive_url()) {
      set_receive_url(from.receive_url());
    }
  }
}

void ctrl2s_create_channel_msg::CopyFrom(const ctrl2s_create_channel_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ctrl2s_create_channel_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ctrl2s_create_channel_msg::Swap(ctrl2s_create_channel_msg* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(receive_url_, other->receive_url_);
    send_urls_.Swap(&other->send_urls_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ctrl2s_create_channel_msg::GetTypeName() const {
  return "p2message.ctrl2s_create_channel_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int mds_cmd_msg::kSessionIdFieldNumber;
const int mds_cmd_msg::kCmdFieldNumber;
const int mds_cmd_msg::kChannelIdsFieldNumber;
const int mds_cmd_msg::kChannelInfoFieldNumber;
const int mds_cmd_msg::kShuntInfoFieldNumber;
const int mds_cmd_msg::kConfigValFieldNumber;
const int mds_cmd_msg::kIsLoginReplyFieldNumber;
#endif  // !_MSC_VER

mds_cmd_msg::mds_cmd_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void mds_cmd_msg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  shunt_info_ = const_cast< ::p2message::ctrl2s_create_channel_msg*>(
      ::p2message::ctrl2s_create_channel_msg::internal_default_instance());
#else
  shunt_info_ = const_cast< ::p2message::ctrl2s_create_channel_msg*>(&::p2message::ctrl2s_create_channel_msg::default_instance());
#endif
}

mds_cmd_msg::mds_cmd_msg(const mds_cmd_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void mds_cmd_msg::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  shunt_info_ = NULL;
  config_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_login_reply_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

mds_cmd_msg::~mds_cmd_msg() {
  SharedDtor();
}

void mds_cmd_msg::SharedDtor() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (config_val_ != &::google::protobuf::internal::kEmptyString) {
    delete config_val_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete shunt_info_;
  }
}

void mds_cmd_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const mds_cmd_msg& mds_cmd_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

mds_cmd_msg* mds_cmd_msg::default_instance_ = NULL;

mds_cmd_msg* mds_cmd_msg::New() const {
  return new mds_cmd_msg;
}

void mds_cmd_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_session_id()) {
      if (session_id_ != &::google::protobuf::internal::kEmptyString) {
        session_id_->clear();
      }
    }
    if (has_cmd()) {
      if (cmd_ != &::google::protobuf::internal::kEmptyString) {
        cmd_->clear();
      }
    }
    if (has_shunt_info()) {
      if (shunt_info_ != NULL) shunt_info_->::p2message::ctrl2s_create_channel_msg::Clear();
    }
    if (has_config_val()) {
      if (config_val_ != &::google::protobuf::internal::kEmptyString) {
        config_val_->clear();
      }
    }
    is_login_reply_ = false;
  }
  channel_ids_.Clear();
  channel_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool mds_cmd_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_session_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cmd;
        break;
      }

      // required bytes cmd = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cmd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_cmd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_ids;
        break;
      }

      // repeated bytes channel_ids = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_channel_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_ids;
        if (input->ExpectTag(34)) goto parse_channel_info;
        break;
      }

      // repeated .p2message.ctrl2m_create_channel_msg channel_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_channel_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_channel_info;
        if (input->ExpectTag(42)) goto parse_shunt_info;
        break;
      }

      // optional .p2message.ctrl2s_create_channel_msg shunt_info = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shunt_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shunt_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_config_val;
        break;
      }

      // optional bytes config_val = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_config_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_config_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_is_login_reply;
        break;
      }

      // optional bool is_login_reply = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_login_reply:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_login_reply_)));
          set_has_is_login_reply();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void mds_cmd_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->session_id(), output);
  }

  // required bytes cmd = 2;
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->cmd(), output);
  }

  // repeated bytes channel_ids = 3;
  for (int i = 0; i < this->channel_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->channel_ids(i), output);
  }

  // repeated .p2message.ctrl2m_create_channel_msg channel_info = 4;
  for (int i = 0; i < this->channel_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->channel_info(i), output);
  }

  // optional .p2message.ctrl2s_create_channel_msg shunt_info = 5;
  if (has_shunt_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->shunt_info(), output);
  }

  // optional bytes config_val = 6;
  if (has_config_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->config_val(), output);
  }

  // optional bool is_login_reply = 7;
  if (has_is_login_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_login_reply(), output);
  }

}

int mds_cmd_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->session_id());
    }

    // required bytes cmd = 2;
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->cmd());
    }

    // optional .p2message.ctrl2s_create_channel_msg shunt_info = 5;
    if (has_shunt_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shunt_info());
    }

    // optional bytes config_val = 6;
    if (has_config_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->config_val());
    }

    // optional bool is_login_reply = 7;
    if (has_is_login_reply()) {
      total_size += 1 + 1;
    }

  }
  // repeated bytes channel_ids = 3;
  total_size += 1 * this->channel_ids_size();
  for (int i = 0; i < this->channel_ids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->channel_ids(i));
  }

  // repeated .p2message.ctrl2m_create_channel_msg channel_info = 4;
  total_size += 1 * this->channel_info_size();
  for (int i = 0; i < this->channel_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->channel_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void mds_cmd_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const mds_cmd_msg*>(&from));
}

void mds_cmd_msg::MergeFrom(const mds_cmd_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  channel_ids_.MergeFrom(from.channel_ids_);
  channel_info_.MergeFrom(from.channel_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_shunt_info()) {
      mutable_shunt_info()->::p2message::ctrl2s_create_channel_msg::MergeFrom(from.shunt_info());
    }
    if (from.has_config_val()) {
      set_config_val(from.config_val());
    }
    if (from.has_is_login_reply()) {
      set_is_login_reply(from.is_login_reply());
    }
  }
}

void mds_cmd_msg::CopyFrom(const mds_cmd_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mds_cmd_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < channel_info_size(); i++) {
    if (!this->channel_info(i).IsInitialized()) return false;
  }
  if (has_shunt_info()) {
    if (!this->shunt_info().IsInitialized()) return false;
  }
  return true;
}

void mds_cmd_msg::Swap(mds_cmd_msg* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(cmd_, other->cmd_);
    channel_ids_.Swap(&other->channel_ids_);
    channel_info_.Swap(&other->channel_info_);
    std::swap(shunt_info_, other->shunt_info_);
    std::swap(config_val_, other->config_val_);
    std::swap(is_login_reply_, other->is_login_reply_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string mds_cmd_msg::GetTypeName() const {
  return "p2message.mds_cmd_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int c2s_cmd_reply_msg::kSessionIdFieldNumber;
const int c2s_cmd_reply_msg::kCodeFieldNumber;
const int c2s_cmd_reply_msg::kIdFieldNumber;
const int c2s_cmd_reply_msg::kTypeFieldNumber;
const int c2s_cmd_reply_msg::kMsgFieldNumber;
#endif  // !_MSC_VER

c2s_cmd_reply_msg::c2s_cmd_reply_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void c2s_cmd_reply_msg::InitAsDefaultInstance() {
}

c2s_cmd_reply_msg::c2s_cmd_reply_msg(const c2s_cmd_reply_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void c2s_cmd_reply_msg::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  code_ = 0u;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

c2s_cmd_reply_msg::~c2s_cmd_reply_msg() {
  SharedDtor();
}

void c2s_cmd_reply_msg::SharedDtor() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void c2s_cmd_reply_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const c2s_cmd_reply_msg& c2s_cmd_reply_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

c2s_cmd_reply_msg* c2s_cmd_reply_msg::default_instance_ = NULL;

c2s_cmd_reply_msg* c2s_cmd_reply_msg::New() const {
  return new c2s_cmd_reply_msg;
}

void c2s_cmd_reply_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_session_id()) {
      if (session_id_ != &::google::protobuf::internal::kEmptyString) {
        session_id_->clear();
      }
    }
    code_ = 0u;
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    type_ = 0;
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::kEmptyString) {
        msg_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool c2s_cmd_reply_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_session_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required uint32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_id;
        break;
      }

      // required bytes id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // required int32 type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_msg;
        break;
      }

      // optional bytes msg = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void c2s_cmd_reply_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->session_id(), output);
  }

  // required uint32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->code(), output);
  }

  // required bytes id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->id(), output);
  }

  // required int32 type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->type(), output);
  }

  // optional bytes msg = 5;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->msg(), output);
  }

}

int c2s_cmd_reply_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->session_id());
    }

    // required uint32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

    // required bytes id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->id());
    }

    // required int32 type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional bytes msg = 5;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void c2s_cmd_reply_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const c2s_cmd_reply_msg*>(&from));
}

void c2s_cmd_reply_msg::MergeFrom(const c2s_cmd_reply_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_msg()) {
      set_msg(from.msg());
    }
  }
}

void c2s_cmd_reply_msg::CopyFrom(const c2s_cmd_reply_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool c2s_cmd_reply_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void c2s_cmd_reply_msg::Swap(c2s_cmd_reply_msg* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(code_, other->code_);
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(msg_, other->msg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string c2s_cmd_reply_msg::GetTypeName() const {
  return "p2message.c2s_cmd_reply_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int c2s_auth_msg::kMessageFieldNumber;
#endif  // !_MSC_VER

c2s_auth_msg::c2s_auth_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void c2s_auth_msg::InitAsDefaultInstance() {
}

c2s_auth_msg::c2s_auth_msg(const c2s_auth_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void c2s_auth_msg::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

c2s_auth_msg::~c2s_auth_msg() {
  SharedDtor();
}

void c2s_auth_msg::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void c2s_auth_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const c2s_auth_msg& c2s_auth_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

c2s_auth_msg* c2s_auth_msg::default_instance_ = NULL;

c2s_auth_msg* c2s_auth_msg::New() const {
  return new c2s_auth_msg;
}

void c2s_auth_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool c2s_auth_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void c2s_auth_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->message(), output);
  }

}

int c2s_auth_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void c2s_auth_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const c2s_auth_msg*>(&from));
}

void c2s_auth_msg::MergeFrom(const c2s_auth_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
}

void c2s_auth_msg::CopyFrom(const c2s_auth_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool c2s_auth_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void c2s_auth_msg::Swap(c2s_auth_msg* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string c2s_auth_msg::GetTypeName() const {
  return "p2message.c2s_auth_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int alive_alarm_report_msg::kIdFieldNumber;
const int alive_alarm_report_msg::kTypeFieldNumber;
const int alive_alarm_report_msg::kPidFieldNumber;
#endif  // !_MSC_VER

alive_alarm_report_msg::alive_alarm_report_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void alive_alarm_report_msg::InitAsDefaultInstance() {
}

alive_alarm_report_msg::alive_alarm_report_msg(const alive_alarm_report_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void alive_alarm_report_msg::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  pid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

alive_alarm_report_msg::~alive_alarm_report_msg() {
  SharedDtor();
}

void alive_alarm_report_msg::SharedDtor() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void alive_alarm_report_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const alive_alarm_report_msg& alive_alarm_report_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_message_2eproto();
#endif
  return *default_instance_;
}

alive_alarm_report_msg* alive_alarm_report_msg::default_instance_ = NULL;

alive_alarm_report_msg* alive_alarm_report_msg::New() const {
  return new alive_alarm_report_msg;
}

void alive_alarm_report_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    type_ = 0;
    pid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool alive_alarm_report_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pid;
        break;
      }

      // optional int32 pid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void alive_alarm_report_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->id(), output);
  }

  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional int32 pid = 3;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pid(), output);
  }

}

int alive_alarm_report_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->id());
    }

    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 pid = 3;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void alive_alarm_report_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const alive_alarm_report_msg*>(&from));
}

void alive_alarm_report_msg::MergeFrom(const alive_alarm_report_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
}

void alive_alarm_report_msg::CopyFrom(const alive_alarm_report_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool alive_alarm_report_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void alive_alarm_report_msg::Swap(alive_alarm_report_msg* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string alive_alarm_report_msg::GetTypeName() const {
  return "p2message.alive_alarm_report_msg";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace p2message

// @@protoc_insertion_point(global_scope)
