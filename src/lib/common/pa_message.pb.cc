// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pa_message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "pa_message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace proanalytics {

void protobuf_ShutdownFile_pa_5fmessage_2eproto() {
  delete init_msg::default_instance_;
  delete sample::default_instance_;
  delete sample_msg::default_instance_;
  delete control_msg::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_pa_5fmessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_pa_5fmessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  init_msg::default_instance_ = new init_msg();
  sample::default_instance_ = new sample();
  sample_msg::default_instance_ = new sample_msg();
  control_msg::default_instance_ = new control_msg();
  init_msg::default_instance_->InitAsDefaultInstance();
  sample::default_instance_->InitAsDefaultInstance();
  sample_msg::default_instance_->InitAsDefaultInstance();
  control_msg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_pa_5fmessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_pa_5fmessage_2eproto_once_);
void protobuf_AddDesc_pa_5fmessage_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_pa_5fmessage_2eproto_once_, 
                 &protobuf_AddDesc_pa_5fmessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_pa_5fmessage_2eproto {
  StaticDescriptorInitializer_pa_5fmessage_2eproto() {
    protobuf_AddDesc_pa_5fmessage_2eproto();
  }
} static_descriptor_initializer_pa_5fmessage_2eproto_;
#endif
bool sample_type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool control_type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int init_msg::kCurrTimeFieldNumber;
const int init_msg::kSampleIntervalFieldNumber;
const int init_msg::kPacketSampleCountFieldNumber;
#endif  // !_MSC_VER

init_msg::init_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void init_msg::InitAsDefaultInstance() {
}

init_msg::init_msg(const init_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void init_msg::SharedCtor() {
  _cached_size_ = 0;
  curr_time_ = GOOGLE_ULONGLONG(0);
  sample_interval_ = 0u;
  packet_sample_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

init_msg::~init_msg() {
  SharedDtor();
}

void init_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void init_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const init_msg& init_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_pa_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_pa_5fmessage_2eproto();
#endif
  return *default_instance_;
}

init_msg* init_msg::default_instance_ = NULL;

init_msg* init_msg::New() const {
  return new init_msg;
}

void init_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    curr_time_ = GOOGLE_ULONGLONG(0);
    sample_interval_ = 0u;
    packet_sample_count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool init_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 curr_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &curr_time_)));
          set_has_curr_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sample_interval;
        break;
      }

      // required uint32 sample_interval = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sample_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sample_interval_)));
          set_has_sample_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_packet_sample_count;
        break;
      }

      // required uint32 packet_sample_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_packet_sample_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &packet_sample_count_)));
          set_has_packet_sample_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void init_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 curr_time = 1;
  if (has_curr_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->curr_time(), output);
  }

  // required uint32 sample_interval = 2;
  if (has_sample_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sample_interval(), output);
  }

  // required uint32 packet_sample_count = 3;
  if (has_packet_sample_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->packet_sample_count(), output);
  }

}

int init_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 curr_time = 1;
    if (has_curr_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->curr_time());
    }

    // required uint32 sample_interval = 2;
    if (has_sample_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sample_interval());
    }

    // required uint32 packet_sample_count = 3;
    if (has_packet_sample_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->packet_sample_count());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void init_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const init_msg*>(&from));
}

void init_msg::MergeFrom(const init_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_curr_time()) {
      set_curr_time(from.curr_time());
    }
    if (from.has_sample_interval()) {
      set_sample_interval(from.sample_interval());
    }
    if (from.has_packet_sample_count()) {
      set_packet_sample_count(from.packet_sample_count());
    }
  }
}

void init_msg::CopyFrom(const init_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool init_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void init_msg::Swap(init_msg* other) {
  if (other != this) {
    std::swap(curr_time_, other->curr_time_);
    std::swap(sample_interval_, other->sample_interval_);
    std::swap(packet_sample_count_, other->packet_sample_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string init_msg::GetTypeName() const {
  return "proanalytics.init_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int sample::kTypeFieldNumber;
const int sample::kChannelLinkFieldNumber;
const int sample::kChannelNameFieldNumber;
const int sample::kTimeSwampFieldNumber;
#endif  // !_MSC_VER

sample::sample()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void sample::InitAsDefaultInstance() {
}

sample::sample(const sample& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void sample::SharedCtor() {
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  time_swamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

sample::~sample() {
  SharedDtor();
}

void sample::SharedDtor() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_link_;
  }
  if (channel_name_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void sample::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const sample& sample::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_pa_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_pa_5fmessage_2eproto();
#endif
  return *default_instance_;
}

sample* sample::default_instance_ = NULL;

sample* sample::New() const {
  return new sample;
}

void sample::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::kEmptyString) {
        type_->clear();
      }
    }
    if (has_channel_link()) {
      if (channel_link_ != &::google::protobuf::internal::kEmptyString) {
        channel_link_->clear();
      }
    }
    if (has_channel_name()) {
      if (channel_name_ != &::google::protobuf::internal::kEmptyString) {
        channel_name_->clear();
      }
    }
    time_swamp_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool sample::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_channel_link;
        break;
      }

      // required string channel_link = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_link:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_channel_link()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_channel_name;
        break;
      }

      // optional string channel_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channel_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_channel_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_time_swamp;
        break;
      }

      // required uint64 time_swamp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_swamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_swamp_)));
          set_has_time_swamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void sample::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->type(), output);
  }

  // required string channel_link = 2;
  if (has_channel_link()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->channel_link(), output);
  }

  // optional string channel_name = 3;
  if (has_channel_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->channel_name(), output);
  }

  // required uint64 time_swamp = 4;
  if (has_time_swamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->time_swamp(), output);
  }

}

int sample::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // required string channel_link = 2;
    if (has_channel_link()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channel_link());
    }

    // optional string channel_name = 3;
    if (has_channel_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channel_name());
    }

    // required uint64 time_swamp = 4;
    if (has_time_swamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->time_swamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void sample::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const sample*>(&from));
}

void sample::MergeFrom(const sample& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_channel_link()) {
      set_channel_link(from.channel_link());
    }
    if (from.has_channel_name()) {
      set_channel_name(from.channel_name());
    }
    if (from.has_time_swamp()) {
      set_time_swamp(from.time_swamp());
    }
  }
}

void sample::CopyFrom(const sample& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sample::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  return true;
}

void sample::Swap(sample* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(channel_link_, other->channel_link_);
    std::swap(channel_name_, other->channel_name_);
    std::swap(time_swamp_, other->time_swamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string sample::GetTypeName() const {
  return "proanalytics.sample";
}


// ===================================================================

#ifndef _MSC_VER
const int sample_msg::kOperatorsFieldNumber;
const int sample_msg::kMacFieldNumber;
const int sample_msg::kSampleListFieldNumber;
#endif  // !_MSC_VER

sample_msg::sample_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void sample_msg::InitAsDefaultInstance() {
}

sample_msg::sample_msg(const sample_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void sample_msg::SharedCtor() {
  _cached_size_ = 0;
  operators_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

sample_msg::~sample_msg() {
  SharedDtor();
}

void sample_msg::SharedDtor() {
  if (operators_ != &::google::protobuf::internal::kEmptyString) {
    delete operators_;
  }
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void sample_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const sample_msg& sample_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_pa_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_pa_5fmessage_2eproto();
#endif
  return *default_instance_;
}

sample_msg* sample_msg::default_instance_ = NULL;

sample_msg* sample_msg::New() const {
  return new sample_msg;
}

void sample_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_operators()) {
      if (operators_ != &::google::protobuf::internal::kEmptyString) {
        operators_->clear();
      }
    }
    if (has_mac()) {
      if (mac_ != &::google::protobuf::internal::kEmptyString) {
        mac_->clear();
      }
    }
  }
  sample_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool sample_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string operators = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_mac;
        break;
      }

      // required string mac = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mac:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sample_list;
        break;
      }

      // repeated .proanalytics.sample sample_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sample_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sample_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sample_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void sample_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string operators = 1;
  if (has_operators()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->operators(), output);
  }

  // required string mac = 2;
  if (has_mac()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->mac(), output);
  }

  // repeated .proanalytics.sample sample_list = 3;
  for (int i = 0; i < this->sample_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->sample_list(i), output);
  }

}

int sample_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string operators = 1;
    if (has_operators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operators());
    }

    // required string mac = 2;
    if (has_mac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mac());
    }

  }
  // repeated .proanalytics.sample sample_list = 3;
  total_size += 1 * this->sample_list_size();
  for (int i = 0; i < this->sample_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sample_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void sample_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const sample_msg*>(&from));
}

void sample_msg::MergeFrom(const sample_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  sample_list_.MergeFrom(from.sample_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_operators()) {
      set_operators(from.operators());
    }
    if (from.has_mac()) {
      set_mac(from.mac());
    }
  }
}

void sample_msg::CopyFrom(const sample_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sample_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < sample_list_size(); i++) {
    if (!this->sample_list(i).IsInitialized()) return false;
  }
  return true;
}

void sample_msg::Swap(sample_msg* other) {
  if (other != this) {
    std::swap(operators_, other->operators_);
    std::swap(mac_, other->mac_);
    sample_list_.Swap(&other->sample_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string sample_msg::GetTypeName() const {
  return "proanalytics.sample_msg";
}


// ===================================================================

#ifndef _MSC_VER
const int control_msg::kTypeFieldNumber;
const int control_msg::kIntervalFieldNumber;
#endif  // !_MSC_VER

control_msg::control_msg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void control_msg::InitAsDefaultInstance() {
}

control_msg::control_msg(const control_msg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void control_msg::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  interval_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

control_msg::~control_msg() {
  SharedDtor();
}

void control_msg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void control_msg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const control_msg& control_msg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_pa_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_pa_5fmessage_2eproto();
#endif
  return *default_instance_;
}

control_msg* control_msg::default_instance_ = NULL;

control_msg* control_msg::New() const {
  return new control_msg;
}

void control_msg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    interval_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool control_msg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .proanalytics.control_type type = 1 [default = CONTROL_UNKNOW];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::proanalytics::control_type_IsValid(value)) {
            set_type(static_cast< ::proanalytics::control_type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interval;
        break;
      }

      // optional uint32 interval = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &interval_)));
          set_has_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void control_msg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .proanalytics.control_type type = 1 [default = CONTROL_UNKNOW];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 interval = 2;
  if (has_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->interval(), output);
  }

}

int control_msg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .proanalytics.control_type type = 1 [default = CONTROL_UNKNOW];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 interval = 2;
    if (has_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->interval());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void control_msg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const control_msg*>(&from));
}

void control_msg::MergeFrom(const control_msg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_interval()) {
      set_interval(from.interval());
    }
  }
}

void control_msg::CopyFrom(const control_msg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool control_msg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void control_msg::Swap(control_msg* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(interval_, other->interval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string control_msg::GetTypeName() const {
  return "proanalytics.control_msg";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proanalytics

// @@protoc_insertion_point(global_scope)
